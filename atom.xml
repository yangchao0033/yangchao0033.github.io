<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[SuperYang`s Blog]]></title>
  <link href="http://yangchao0033.github.io/atom.xml" rel="self"/>
  <link href="http://yangchao0033.github.io/"/>
  <updated>2017-07-27T00:42:44+08:00</updated>
  <id>http://yangchao0033.github.io/</id>
  <author>
    <name><![CDATA[Super Yang]]></name>
    <email><![CDATA[757097678@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa 设计规范]]></title>
    <link href="http://yangchao0033.github.io/blog/2017/07/27/reactivecocoa-she-ji-gui-fan/"/>
    <updated>2017-07-27T00:36:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2017/07/27/reactivecocoa-she-ji-gui-fan</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/DesignGuidelines.md#use-descriptive-declarations-for-methods-and-properties-that-return-a-signal">Design Guidelines</a>【译】</p>

<h4>RACSequence 的一些约定</h4>

<ol>
<li>默认情况延迟发生</li>
<li>默认会阻塞调用者</li>
<li>副作用只发生一次</li>
</ol>


<h4>RACSignal 的约定</h4>

<ol>
<li>信号事件有序串行执行，保证不会同时到达两个或多个信号，但是可以运行在不同的scheduler之上。</li>
<li>订阅事件总会在一个 scheduler 上</li>
<li>错误会立即传播（优先级最高）</li>
<li>订阅事件会产生副作用</li>
<li>订阅关系总会在complete或error时自动销毁</li>
<li>销毁会取消正在执行的任务并且清理相关的资源</li>
</ol>


<!--more-->


<h4>常用练习</h4>

<ul>
<li><p>为返回信号的方法或属性使用描述性声明
声明语义有三个维度</p>

<ol>
<li>冷信号（是否在此时被激活）还是热信号（需要订阅后激活）</li>
<li>信号返回值的个数是0个一个或更多？</li>
<li>信号是否有副作用</li>
</ol>
</li>
<li><p>举个栗子</p>

<ul>
<li><strong>没有副作用的热信号：</strong>通常声明为属性来代替方法。暗示订阅之前不需要任何初始化，并且之后附加的任何订阅不会影响当前的订阅语义（没有副作用且每次订阅都是独立的语义）。信号属性通常命名在事件之后（eg: <code>textChangedSignal</code>）</li>
<li><strong>没有副作用的冷信号：</strong>通常使用一个方法返回信号，并且通常使用名词命名（eg:<code>-currentText</code>）。方法声明暗示信号不会被保存（持有），暗示只有在订阅时才会执行任务。如果信号发送多个值，该名词必须是复数的。(-<code>currentModels</code>）</li>
<li><strong>有副作用的冷信号：</strong>通常使用方法返回，并且使用动词命名（eg:<code>-logIn</code>）.动词命名暗示该方法的执行不是幂等得并且使用该方法的调用者需要小心清楚副作用的影响，除非副作用是被需要的或允许范围内的。如果该信号包含一个或多个值，需要用一个名词命名，并且使用对应的单复数形式。</li>
</ul>
</li>
</ul>


<h4>缩进流操作一致</h4>

<p> 如果不适当的格式化，纯流式的代码将会变得很密集并且混乱。使用一致的缩进来高亮链式流的开始和结束。</p>

<p>当在单个流上调用方法时，不需要额外的缩进。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RACStream</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">stream</span> <span class="nl">startWith</span><span class="p">:</span><span class="mi">@0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">RACStream</span> <span class="o">*</span><span class="n">result2</span> <span class="o">=</span> <span class="p">[</span><span class="n">stream</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="l">@(</span><span class="n">value</span><span class="p">.</span><span class="n">integerValue</span> <span class="o">+</span> <span class="mi">1</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>当多次转换相同的流时，请确保所有步骤都对齐。 复杂运算符<code>+ zip：reduce：</code>或<code>+ combineLatest：reduce：</code>可以拆分为多行以提高可读性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RACStream</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">RACStream</span>
</span><span class='line'>    <span class="nl">zip</span><span class="p">:</span><span class="l">@[</span> <span class="n">firstStream</span><span class="p">,</span> <span class="n">secondStream</span> <span class="l">]</span>
</span><span class='line'>    <span class="nl">reduce</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="bp">NSNumber</span> <span class="o">*</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="l">@(</span><span class="n">first</span><span class="p">.</span><span class="n">integerValue</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">integerValue</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="nl">filter</span><span class="p">:</span><span class="o">^</span> <span class="kt">BOOL</span> <span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">integerValue</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="l">@(</span><span class="n">value</span><span class="p">.</span><span class="n">integerValue</span> <span class="o">+</span> <span class="mi">1</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，使用block参数嵌套的流需要从block的自然缩进开始。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">signal</span>
</span><span class='line'>    <span class="nl">then</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="p">[[</span><span class="nb">self</span>
</span><span class='line'>            <span class="n">doSomethingElse</span><span class="p">]</span>
</span><span class='line'>            <span class="nl">catch</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="p">@</span><span class="n">strongify</span><span class="p">(</span><span class="nb">self</span><span class="p">);</span>
</span><span class='line'>                <span class="p">[</span><span class="nb">self</span> <span class="nl">presentError</span><span class="p">:</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="n">empty</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}];</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="nl">subscribeCompleted</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;All done.&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>单个流中的所有值类型必须保持一致。</h4>

<p>使用不同类型需要使用复杂的操作流程，且会给使用流的消费者增加额外的负担。</p>

<h4>避免过久的持有流</h4>

<p>如果持有流的时间超过他本身需要存活的时间时，将会导致流本身持有的或依赖的资源无法释放，潜在的造成内存使用过高。</p>

<h4>只处理需要的信号</h4>

<p>除了会增加内存使用，不必要的持有流或者 <code>RACSignal</code> 订阅关系会导致 CPU 使用增加, 因为不必要的任务执行所得出的结果永远不会被使用到。一般可以使用<code>-take</code>或<code>-takeUntil</code>可以自动在不必要的时候取消流执行</p>

<h4>在已知的 Scheduler 上传送信号事件</h4>

<p>流信号返回的值可能会来自很多复杂的场景，很可能是在底层线程中造作得出，所以在给UI元素这是返回的信号值时，一定要保证其赋值造作发成在<code>mainScheduler</code> (主线程)只上。</p>

<h4>尽可能少的切换调度者（<code>scheduler</code>）</h4>

<p>非必须的情况下，务必让流信号的执行发生在同一 <code>Scheduler</code> 之上。因为切换 <code>Scheduler</code> 会引入不必要的延迟并且会增加CPU资源的消耗。</p>

<p>通常 <code>-deliverOn:</code>严格限制只会在信号链的尾部使用，比如在订阅之前，或为属性绑定值时</p>

<h4>明确信号的副作用</h4>

<p>通常一定要避免副作用的发生，但是有一些副作用是我们所期望的,一般应用在一些hook方法进行调试，例如 <code>-doNext:</code>、<code>-doError:</code>、<code>-doCompleted:</code>等</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">nexts</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'><span class="k">__block</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">receivedError</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">__block</span> <span class="kt">BOOL</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="n">RACSignal</span> <span class="o">*</span><span class="n">bookkeepingSignal</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">valueSignal</span>
</span><span class='line'>    <span class="nl">doNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">nexts</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">x</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="nl">doError</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">receivedError</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="nl">doCompleted</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">success</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="n">RAC</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="n">bookkeepingSignal</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>使用组播分享带有副作用的信号</h4>

<p>使用组播可以允许单个信号拥有任意数量的订阅关系。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// This signal starts a new request on each subscription.</span>
</span><span class='line'><span class="n">RACSignal</span> <span class="o">*</span><span class="n">networkRequest</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nl">createSignal</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[</span><span class="n">client</span>
</span><span class='line'>        <span class="nl">HTTPRequestOperationWithRequest</span><span class="p">:</span><span class="n">request</span>
</span><span class='line'>        <span class="nl">success</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="kt">id</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendNext</span><span class="p">:</span><span class="n">response</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">subscriber</span> <span class="n">sendCompleted</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nl">failure</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">AFHTTPRequestOperation</span> <span class="o">*</span><span class="n">operation</span><span class="p">,</span> <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendError</span><span class="p">:</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">client</span> <span class="nl">enqueueHTTPRequestOperation</span><span class="p">:</span><span class="n">operation</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">RACDisposable</span> <span class="nl">disposableWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">operation</span> <span class="n">cancel</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Starts a single request, no matter how many subscriptions `connection.signal`</span>
</span><span class='line'><span class="c1">// gets. This is equivalent to the -replay operator, or similar to</span>
</span><span class='line'><span class="c1">// +startEagerlyWithScheduler:block:.</span>
</span><span class='line'><span class="n">RACMulticastConnection</span> <span class="o">*</span><span class="n">connection</span> <span class="o">=</span> <span class="p">[</span><span class="n">networkRequest</span> <span class="nl">multicast</span><span class="p">:[</span><span class="n">RACReplaySubject</span> <span class="n">subject</span><span class="p">]];</span>
</span><span class='line'><span class="p">[</span><span class="n">connection</span> <span class="n">connect</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">connection</span><span class="p">.</span><span class="n">signal</span> <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;subscriber one: %@&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">connection</span><span class="p">.</span><span class="n">signal</span> <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;subscriber two: %@&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>通过给信号命名进行调试</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RACSignal</span> <span class="o">*</span><span class="n">signal</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">RACObserve</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
</span><span class='line'>    <span class="n">distinctUntilChanged</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">take</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">filter</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="n">newUsername</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">[</span><span class="n">newUsername</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;joshaber&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">signal</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 打印结果 [[[RACObserve(self, username)] -distinctUntilChanged] -take: 3] -filter:</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACStream.h">-setNameWithFormat:</a> 对信号自定义信号名。
此外，<code>RACSignal</code> 还提供了 <code>-logNext</code>, <code>-logError</code>,<code>-logCompleted</code>, <code>-logAll</code>方法，当信号事件执行时自动打印信号的信息（包括 <code>name</code>），更方便检测到信号的实时状况。</p>

<h4>避免显式的订阅和销毁</h4>

<p>虽然-subscribeNext：error：completed：和它的变体是处理信号的最基本的方式，但是它们较少的声明性，鼓励使用副作用和潜在地复制内置功能而使代码复杂化。</p>

<p>同时，显式的调用 <code>RACDisposable</code> 类会快速导致一堆乱七八糟的资源管理并且清理代码。</p>

<ul>
<li>解决方案 ：使用较高级别的模式来替换手动订阅和销毁

<ul>
<li>使用 <code>RAC()</code> 或者 <code>RACChannelTo</code> 宏定义可以用来绑定信号或者属性，代替在状态变化时手动更新。</li>
<li>例如 <code>-takeUntil:</code> 等操作符可以用来当参数中的事件发生时自动销毁一段订阅关系（比如 <code>取消按钮</code> 被点击时）。</li>
</ul>
</li>
</ul>


<p>通常 ，相比于使用订阅的回调，使用内置的 <code>stream</code> 和 <code>signal</code> 操作符将会让代码变得更简洁并且能产生更少的易错代码。</p>

<h4>尽可能避免使用 subjects</h4>

<p><code>Subject</code> 是一个用来桥接代码到 signal 世界的强大工具，但是就像 RAC 中的可变变量一样，当发生滥用时，他们会更快的导致程序变得复杂。</p>

<p>Subjects 通常会被 ReactiveCocoa 的其他模式所代替：
  * 相比于给 <code>Subject</code> 提供初始值，不如考虑使用  <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACSignal.h">+createSignal:</a> block 产生值代替。
  * 相比于将一些中间值发送给发送给 subject，不如使用 <code>+combineLatest:</code> 或者 <code>+zip:</code>操作符组合多个信号的输出值。
  * 基于一个 Signal 使用 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/DesignGuidelines.md#share-the-side-effects-of-a-signal-by-multicasting">multicast</a> (组播)，而不是使用多个 订阅者共享 <code>subjects</code> 的结果。
  * 使用 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACCommand.h">command</a> 或者 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/NSObject+RACSelectorSignal.h">-rac_signalForSelector:</a> ，而不是为了简单的控制一个 subject 实现一个事件方法。</p>

<p>  当不得不使用 subject 时，他们必须是信号链中最基本的输入，而不是其中的一个。</p>

<h3>支持自定义操作符</h3>

<h4>推荐使用 RACStream 的方法</h4>

<h4>尽可能使用现有的操作符进行构思</h4>

<h3>尽量避免引入并发</h3>

<p>尽量使用 RACScheduler 代替</p>

<h4>在 disposable 中取消任务和清理所有关联资源。</h4>

<p>当使用 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACSignal.h">+createSignal:</a> 创建信号是，通常会返回一个 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACDisposable.h">RACDisposable</a> 对象。而这个 disposable 对象应该：
* 尽可能方便优雅的取消正在进行的由 <code>signal</code> 开启的任务。
* 立即销毁任何信号的订阅关系，由此来触发他们的取消和清除代码。
* 释放任何信号开辟的内存和占用的资源。</p>

<h4>不要在操作符中分块</h4>

<p>流操作符应该立即返回一个新的流。操作符需要执行的任何操作都应该是执行新流的一部分，而不是运算符调用本身的一部分。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// WRONG!</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">RACSequence</span> <span class="o">*</span><span class="p">)</span><span class="nf">map:</span><span class="p">(</span><span class="kt">id</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span><span class="p">))</span><span class="nv">block</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">RACSequence</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSequence</span> <span class="n">empty</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">obj</span> <span class="k">in</span> <span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">id</span> <span class="n">mappedObj</span> <span class="o">=</span> <span class="n">block</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span> <span class="nl">concat</span><span class="p">:[</span><span class="n">RACSequence</span> <span class="k">return</span><span class="o">:</span><span class="n">mappedObj</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Right!</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">RACSequence</span> <span class="o">*</span><span class="p">)</span><span class="nf">map:</span><span class="p">(</span><span class="kt">id</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">id</span><span class="p">))</span><span class="nv">block</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">flattenMap</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">id</span> <span class="n">mappedObj</span> <span class="o">=</span> <span class="n">block</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">[</span><span class="n">RACSequence</span> <span class="k">return</span><span class="o">:</span><span class="n">mappedObj</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>避免深度递归导致的堆栈溢出</h4>

<p>任何可能无限递归的操作符都应该使用 <code>-scheduleRecursiveBlock:</code>  <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACScheduler.h">RACScheduler</a> 方法。这个方法将会把递归转换为迭代来防止堆栈溢出。
例如：下面的例子将会错误地实现 <code>-repeat</code> ,应为这将潜在的引起堆栈溢出并且崩溃。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="nf">repeat</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nl">createSignal</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">RACCompoundDisposable</span> <span class="o">*</span><span class="n">compoundDisposable</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACCompoundDisposable</span> <span class="n">compoundDisposable</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">__block</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">resubscribe</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="n">RACDisposable</span> <span class="o">*</span><span class="n">disposable</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendNext</span><span class="p">:</span><span class="n">x</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span> <span class="nl">error</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendError</span><span class="p">:</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span> <span class="nl">completed</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                <span class="n">resubscribe</span><span class="p">();</span>
</span><span class='line'>            <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">[</span><span class="n">compoundDisposable</span> <span class="nl">addDisposable</span><span class="p">:</span><span class="n">disposable</span><span class="p">];</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">compoundDisposable</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>相比之下，下面的版本将会避免。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="p">)</span><span class="nf">repeat</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="nl">createSignal</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">RACCompoundDisposable</span> <span class="o">*</span><span class="n">compoundDisposable</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACCompoundDisposable</span> <span class="n">compoundDisposable</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">RACScheduler</span> <span class="o">*</span><span class="n">scheduler</span> <span class="o">=</span> <span class="n">RACScheduler</span><span class="p">.</span><span class="n">currentScheduler</span> <span class="o">?:</span> <span class="p">[</span><span class="n">RACScheduler</span> <span class="n">scheduler</span><span class="p">];</span>
</span><span class='line'>        <span class="n">RACDisposable</span> <span class="o">*</span><span class="n">disposable</span> <span class="o">=</span> <span class="p">[</span><span class="n">scheduler</span> <span class="nl">scheduleRecursiveBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">reschedule</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">RACDisposable</span> <span class="o">*</span><span class="n">disposable</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">subscribeNext</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendNext</span><span class="p">:</span><span class="n">x</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span> <span class="nl">error</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendError</span><span class="p">:</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span> <span class="nl">completed</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>                <span class="n">reschedule</span><span class="p">();</span>
</span><span class='line'>            <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">[</span><span class="n">compoundDisposable</span> <span class="nl">addDisposable</span><span class="p">:</span><span class="n">disposable</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">compoundDisposable</span> <span class="nl">addDisposable</span><span class="p">:</span><span class="n">disposable</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">compoundDisposable</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 骨骼动画 (DragonBones) 在 iOS 端截屏功能]]></title>
    <link href="http://yangchao0033.github.io/blog/2017/07/25/js-gu-ge-dong-hua-dragonbones-zai-ios-duan-jie-ping-gong-neng/"/>
    <updated>2017-07-25T23:30:10+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2017/07/25/js-gu-ge-dong-hua-dragonbones-zai-ios-duan-jie-ping-gong-neng</id>
    <content type="html"><![CDATA[<h3>需求背景：</h3>

<p>使用 DragonBones 在 Webview 中绘制骨骼动画，并对当前的骨骼页面进行图层截取，实现保存本地和分享功能。</p>

<h3>问题：</h3>

<p>使用 DragonBones 制作骨骼动画时遇到一个问题，使用 WKWebView 加载骨骼动画正常，再对 WKWebView 的父容器 view （控制器 view ）进行截图是出现空白。</p>

<h4>解决思路及方案一：</h4>

<!--more-->


<p>通过资料查阅，发现 WKWebView 在截图时比较特殊,需要调用 UIView 的分类，也就是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">nullable</span> <span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nf">snapshotViewAfterScreenUpdates:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">afterUpdates</span> <span class="n">NS_AVAILABLE_IOS</span><span class="p">(</span><span class="mi">7</span><span class="n">_0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>进行View图层的快照获取，推测和 WKWebView 的渲染原理相关。因为正常流程都是通过 UIGraphics 去捕捉 UIView 的上下文来生成 UIImage 对象，进而分享或保存到本地。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">getSharingImageWithView:</span><span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">originView</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">UIImage</span> <span class="o">*</span><span class="n">snapshotImage</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="n">UIGraphicsBeginImageContextWithOptions</span><span class="p">(</span><span class="n">originView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="nb">NO</span><span class="p">,</span> <span class="p">[</span><span class="bp">UIScreen</span> <span class="n">mainScreen</span><span class="p">].</span><span class="n">scale</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">originView</span><span class="p">.</span><span class="n">layer</span> <span class="nl">renderInContext</span><span class="p">:</span><span class="n">UIGraphicsGetCurrentContext</span><span class="p">()];</span>
</span><span class='line'>    <span class="n">snapshotImage</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class='line'>    <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">snapshotImage</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对 WkWebView、TableView 等滚动视图循环截屏可参考 <a href="https://github.com/TonyReet/TYSnapshotScroll">TYSnapshotScroll</a>。
当然，例如 TYSnapshotScroll 提供的 WKWebView 截图方式（snapshotViewAfterScreenUpdates）截取方式对类似 github、google 等首页的截取非常完美。</p>

<p>但是，在加载骨骼动画时只有动画背景，没有任务形象。</p>

<h4>解决思路及方案二：</h4>

<p>根据从安卓和前端收集的信息来看:
1. h5 骨骼动画底层使用了 canvas 绘图(一个类似于 iOS CoreGraphic 的库，专门负责绘制复杂图形。)
2. JavaScript 使用 canvas 绘图时，会存在这样的关系，直接上图</p>

<p><img src="http://upload-images.jianshu.io/upload_images/1445110-6f6cd7e375e337f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="canvas 的七大姑八大姨" /></p>

<ol>
<li>上图中最有价值的线索是，canvas 会调用 webGL 进行渲染，同时会调用硬件加速功能</li>
<li>安卓端在手动关闭硬件加速后，该页面截屏恢复正常。</li>
</ol>


<p>然鹅，只有 Safari 中有对 WebGL 有控制权，WKWebView 并不能通过代码关闭硬件加速。
所以只能放弃使用 canvas 动态绘制的 webView 进行图像提取。</p>

<p>所以，我们采取了采取了双端结合的思路：
* 由 JavaScript 通过 canvas 输出 base64 图片字符串，以及人物背景图片的URL
JavaScript生成图片：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">fullQuality</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">toDataURL</span><span class="p">(</span><span class="s1">&#39;image/jpeg&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// 参数二控制图片质量</span>
</span><span class='line'><span class="c1">// data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ...9oADAMBAAIRAxEAPwD/AD/6AP/Z&quot;</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">mediumQuality</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">toDataURL</span><span class="p">(</span><span class="s1">&#39;image/jpeg&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">lowQuality</span> <span class="o">=</span> <span class="nx">canvas</span><span class="p">.</span><span class="nx">toDataURL</span><span class="p">(</span><span class="s1">&#39;image/jpeg&#39;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Native 解析图片：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSData</span> <span class="o">*</span><span class="n">decodedImageData</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="n">base64String</span><span class="p">]];</span>
</span><span class='line'><span class="bp">UIImage</span> <span class="o">*</span><span class="n">decodedImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">decodedImageData</span>
</span><span class='line'>                                         <span class="nl">scale</span><span class="p">:[</span><span class="bp">UIScreen</span> <span class="n">mainScreen</span><span class="p">].</span><span class="n">scale</span><span class="p">];</span>
</span><span class='line'><span class="n">personImageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">decodedImage</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>由 Native 对使用这些资源进行布局渲染，并且控制截屏时用户信息、二维码等元素的展示，效果如图：</li>
</ul>


<p><img src="http://upload-images.jianshu.io/upload_images/1445110-9d3101208a5f022e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="骨骼动画截屏" /></p>

<h3>总结</h3>

<p>对于部分特殊控件的图像处理可能要会出现位置的异常，需要对对应的底层实现技术点进行剖析，倒推引起的原因。</p>

<h4>参考：</h4>

<p><a href="http://www.zhangxinxu.com/wordpress/2011/10/html5-canvas-webgl-css-shaders-glsl%E7%9A%84%E6%9A%A7%E6%98%A7%E5%85%B3%E7%B3%BB/">HTML5 Canvas,WebGL,CSS Shaders,GLSL的暧昧关系</a>
<a href="https://www.egret.com/">egret</a>
<a href="http://dragonbones.com/cn/index.html">dragonBone</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让 iOS/Android 网络API开发更加自由-charles模拟服务器返回本地数据]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/03/05/develop-moblie-api-with-charles-and-server-data-with-charles/"/>
    <updated>2016-03-05T14:52:25+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/03/05/develop-moblie-api-with-charles-and-server-data-with-charles</id>
    <content type="html"><![CDATA[<blockquote><p><strong>原因：</strong>在与服务器联调接口之后，所有的API都能正常跑通，但是涉及到具体的业务逻辑时，比如界面遇到不同的数据做出特定的布局操作或弹框提示，再或者只有当数据字段符合特定的值时才能做出更多复杂的逻辑操作。如果依赖于服务器或者数据库，那么需要他们去帮你制造假数据来检测你的代码的正确性，这样是一次两次没问题，但是量大的时候，会影响双方的开发进度。能不能采取解耦的思想让移动端和服务端分隔开，在移动端测试开发阶段，自己根据接口文档制造自己需要的特定的返回数据呢？</p></blockquote>

<p><strong>解决方案：</strong>这时候我们需要自己的代理服务器来实现&ndash;使用 Charles 制作代理服务器。</p>

<p><strong>具体需求：</strong>当API有所改动时，服务器正在开发相应功能，但是还没有部署到服务器上去，只是在原接口的返回数据中多加了一个字段“id”。现在移动端的业务逻辑写好了，就等数据测试了。</p>

<p><strong>具体操作步骤：</strong></p>

<!--more-->


<p><strong>一、</strong>首先你需要下载一个 Charles，并且安装起来，具体的使用方法这里不做赘述。可以移步<a href="http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles">这里</a>学习。
<strong>二、</strong>抓取你需要修改的接口
<img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%8A%93%E5%8F%96%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3.png?raw=true" alt="抓取一个接口.png" />
大家可以看到，这个接口返回的是一个json串。这个请求是手机发起的，我们看到的只是软件抓到的包数据。那么如何加入新的“id”字段呢？)
大家可以看到，这个接口返回的是一个json串。这个请求是手机发起的，我们看到的只是软件抓到的包数据。那么如何加入新的“id”字段呢？</p>

<p><strong>三、</strong>使用 Charles 的 local map 功能</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%BF%9D%E5%AD%98response%E6%95%B0%E6%8D%AE.png?raw=true" alt="保存response数据.png" /></p>

<p>保存 response 数据到本地电脑上去</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E9%80%89%E6%8B%A9localmap.png?raw=true" alt="选择localmap.png" /></p>

<p>选择local map</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%B7%BB%E5%8A%A0%E9%9C%80%E8%A6%81map%E7%9A%84%E6%8E%A5%E5%8F%A3.png?raw=true" alt="添加需要map的接口.png" /></p>

<p>点击 Add 添加 map 规则</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/map%E8%A7%84%E5%88%99.png?raw=true" alt="map规则.png" />
这些地方填入你的API信息，以及刚才保存的 response 文件地址</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E7%82%B9%E5%87%BB%E4%BF%9D%E5%AD%98map.png?raw=true" alt="点击保存map.png" />
点击ok保存map规则。之后，只要是从你手机通过 Charles 代理发出的这个接口的请求，都会被重定向到你电脑上本地的 response 文件中。</p>

<p>现在，我们在通过手机调用一下之前的接口，结果呢？结果是还不如原来的，呵呵哒。。。</p>

<p>之前我们还能获取到 title、content和type三个字段以及他们的值，现在直接返回的数据为nil。</p>

<p>找了半天原因，最终通过对比发现了一个问题，两种请求的响应头不一样</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE.png?raw=true" alt="从服务器取到的数据.png" /></p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%9C%AC%E5%9C%B0map%E7%9A%84%E6%95%B0%E6%8D%AE.png?raw=true" alt="本地map的数据.png" /></p>

<p>所以怎么修改 response 的 content type 类型为 json/application 呢？</p>

<p><strong>三、</strong>使用 Rewrite 替换特定接口的响应头参数</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%89%93%E5%BC%80rewrite.png?raw=true" alt="打开rewrite.png" /></p>

<p>打开 Rewrite</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/rewrite%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2.png?raw=true" alt="rewrite配置页面.png" /></p>

<p>Rewrite 配置页面简介</p>

<p>1、首先创建一个规则集</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%B7%BB%E5%8A%A0%E6%8E%A5%E5%8F%A3%E9%9B%86%E5%90%88%E5%92%8C%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4.png?raw=true" alt="添加接口集合和适用范围.png" /></p>

<p>添加 Rewrite 替换规则</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%B9%A6%E5%86%99rewrite%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99.png?raw=true" alt="书写rewrite替换规则.png" /></p>

<p>这里相当于是在响应回来之前，通过字段的匹配，替换掉原有的响应头中的Content-Type 类型为 json/application</p>

<p>所有的对话框都点击 ok 或者 apply 确定保存</p>

<p>现在我们开始测试啦，继续调用该接口。</p>

<p>四、根据需求修改数据</p>

<p>数据修改前刚才看过了，只有 title/content/type 三个字段</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'><span class="nt">&quot;title&quot;</span><span class="p">:</span><span class="s2">&quot;标题&quot;</span><span class="p">,</span>
</span><span class='line'><span class="nt">&quot;content&quot;</span><span class="p">:</span><span class="s2">&quot;内容正文&quot;</span><span class="p">,</span>
</span><span class='line'><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;类型&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而现在需要添加 “id” 字段。所以，用 vim 或者其他文本编辑器打开刚才保存的 response 文件，将他修改成这样</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="s2">&quot;00000001&quot;</span><span class="p">,</span>
</span><span class='line'><span class="nt">&quot;title&quot;</span><span class="p">:</span><span class="s2">&quot;标题&quot;</span><span class="p">,</span>
</span><span class='line'><span class="nt">&quot;content&quot;</span><span class="p">:</span><span class="s2">&quot;内容正文&quot;</span><span class="p">,</span>
</span><span class='line'><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;类型&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>修改后记得保存一下，现在重新开始请求该接口，查看log日志。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'><span class="nt">&quot;id&quot;</span><span class="p">:</span><span class="s2">&quot;00000001&quot;</span><span class="p">,</span>
</span><span class='line'><span class="nt">&quot;title&quot;</span><span class="p">:</span><span class="s2">&quot;标题&quot;</span><span class="p">,</span>
</span><span class='line'><span class="nt">&quot;content&quot;</span><span class="p">:</span><span class="s2">&quot;内容正文&quot;</span><span class="p">,</span>
</span><span class='line'><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;类型&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>完美！下面开始愉快的测试我们自己的代码吧~</p>

<hr />

<h2>总结：</h2>

<h2>本文的目的主要是为了提高客户端和服务器各自独立开发的能力，像制造特定的假数据这种很简单的需求，如果不借助 Charles 代理去自己制造，恐怕你需要自己搭建一个服务器去各种恶补服务器的知识了。其实我们的原理十分简单，就是通过代理软件对网络请求进行拦截，并且返回我们想要的数据。这样做的好处就是，大大加强了客户端的自主开发能力，不需要依赖服务器对我们的特定逻辑进行开发，缩短开发周期。节约大家的时间，试想如果我们自己制造的数据如果在app中能跑通，即便服务器开发出来，如果出现跑不通的错误，那问题最有可能出现在服务器端，当然还要看具体的反馈信息。Charles 还有很多强大的功能，有待大家慢慢探索，祝大家玩得开心~</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HLS-iOS视频播放服务架构深入探究（二）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/02/14/hls-2/"/>
    <updated>2016-02-14T18:51:24+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/02/14/hls-2</id>
    <content type="html"><![CDATA[<p>HLS-Demo地址：<a href="https://github.com/yangchao0033/HLS-Demo">https://github.com/yangchao0033/HLS-Demo</a></p>

<p><strong>使用demo前请注意下面的问题，我在代码中也做了注释。</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//#warning 注意，不要直接使用切换流的主索引，当前代码的协议只提供对.ts定位的子索引的下载和播放，而且其中只有点播协议那一小段是可以下载的，直播协议只能播放，无法下载，无法下载的原因是因为m3u8的那个库中只对特定的一种m3u8的格式做了解析，而m3u8的格式有很多种，所以无法加息出来，该demo只做演示，不会对所有格式进行全解析，如果大家感兴趣的话可以对m3u8的库进行扩展，在github 上 pull request 我做一个补充扩展😁，我会及时在博客中进行更新。博客地址：superyang.gitcafe.io或yangchao0033.github.io 同简书：http://www.jianshu.com/users/f37a8f0ba6f8/latest_articles</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** 点播协议 (只有这个是可以下载的，但是苦于太短，没办法播放出来，正在寻找可以下载并播放的新的点播或直播源,希望有读者可以帮忙提供哈，不甚感激~)*/</span>
</span><span class='line'><span class="c1">//#define TEST_HLS_URL @&quot;http://m3u8.tdimg.com/147/806/921/3.m3u8&quot;</span>
</span><span class='line'><span class="cm">/** 视频直播协议 */</span>
</span><span class='line'><span class="cm">/** 父索引(无法下载，只作为结构分析) */</span>
</span><span class='line'><span class="c1">//#define TEST_HLS_URL @&quot;http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5.m3u8&quot;</span>
</span><span class='line'><span class="cm">/** 子索引(无法下载，只作为结构分析) */</span>
</span><span class='line'><span class="c1">//#define TEST_HLS_URL @&quot;http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5&quot;</span>
</span><span class='line'><span class="cm">/** wwcd视频，果然苹果自己就用这个协议(无法下载，只作为结构分析) */</span>
</span><span class='line'><span class="c1">//#define TEST_HLS_URL @&quot;http://devstreaming.apple.com/videos/wwdc/2015/413eflf3lrh1tyo/413/hls_vod_mvp.m3u8&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果觉得文章有用的话，请读者在github上点个star😁，或者在<a href="http://www.jianshu.com/users/f37a8f0ba6f8/latest_articles">简书</a>上点个赞。</p>

<p>Demo配置原理：</p>

<p>1、 需要导入第三方库：ASIHttpRequest，CocoaHTTPServer，m3u8（其中ASI用于网络请求，CocoaHTTPServer用于在ios端搭建服务器使用，m3u8是用来对返回的索引文件进行解析的）</p>

<!--more-->


<p><img src="https://github.com/yangchao0033/HLS-Demo/blob/master/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%831.png?raw=true" alt="ASI配置注意事项" /></p>

<p><img src="https://github.com/yangchao0033/HLS-Demo/blob/master/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%832.png?raw=true" alt="MRC报错处理" /></p>

<p>2、导入系统库：libsqlite3.dylib、libz.dylib、libxml2.dylib、CoreTelephony.framework、SystemConfiguration.framework、MobileCoreServices.framework、Security.framework、CFNetwork.framework、MediaPlayer.framework</p>

<p>3、添加头文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">YCHLS</span><span class="o">-</span><span class="n">Demo</span><span class="p">.</span><span class="n">h</span>
</span></code></pre></td></tr></table></div></figure>


<p>4、demo介绍
<img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/2/HLS_demo_UI.png?raw=true" alt="demo样式" /></p>

<ul>
<li><strong>播放：</strong>直接播放在线的直播链接，是由系统的MPMoviePlayer完成的，它自带解析HLS直播链的功能。</li>
<li><strong>下载：</strong>遵循HLS的协议，通过索引文件的资源路径下载相关的视频切片并保存到手机本地。</li>
<li><strong>播放本地视频：</strong>使用下载好的视频文件片段进行连续播放。</li>
<li><strong>清除缓存：</strong>删除下载好的视频片段</li>
</ul>


<p>原理：</p>

<ol>
<li>通过ASI请求链接，通过m3u8库解析返回的m3u8索引文件。</li>
<li>再通过ASI下载解析出的视频资源地址，仿照HLS中文件存储路径存储。</li>
<li>利用CocoaHTTPServer在iOS端搭建本地服务器，并开启服务，端口号为：12345（高位端口即可）。配置服务器路径与步骤二存储路径一致。</li>
<li>设置播放器直播链接为本地服务器地址，直接播放，由于播放器遵守HLS协议，所以能够解析我们之前使用HLS协议搭建的本地服务器地址。</li>
<li>点击在线播放，校验是否与本地播放效果一致。</li>
</ol>


<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/2/HLS%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%20.png?raw=true" alt="HLS协议文件存储结构" /></p>

<p>上面是HLS中服务器存储视频文件切片和索引文件的结构图</p>

<p>整个操作流程就是：</p>

<ol>
<li>先点击下载，通过解析m3u8的第三方库解析资源。（m3u8的那个库只能解析一种特定格式的m3u8文件，代码里会有标注）</li>
<li>点击播放本地视频播放下载好的资源。</li>
<li>点击播放是用来预览直播的效果，与整个流程无关。</li>
<li>其中进度条用来显示下载进度。</li>
</ol>


<blockquote><p>总结：
整个Demo并不只是让我们搭建一个Hls服务器或者一个支持Hls的播放器。目的在于了解Hls协议的具体实现，以及服务器端的一些物理架构。通过Demo的学习，可以详细的了解Hls直播具体的实现流程。</p></blockquote>

<p>部分源码贴出：</p>

<p>开启本地服务器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">openHttpServer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">httpServer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">HTTPServer</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">httpServer</span> <span class="nl">setType</span><span class="p">:</span><span class="s">@&quot;_http._tcp.&quot;</span><span class="p">];</span>  <span class="c1">// 设置服务类型</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">httpServer</span> <span class="nl">setPort</span><span class="p">:</span><span class="mi">12345</span><span class="p">];</span> <span class="c1">// 设置服务器端口</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 获取本地Library/Cache路径下downloads路径</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">webPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">kLibraryCache</span> <span class="nl">stringByAppendingPathComponent</span><span class="p">:</span><span class="n">kPathDownload</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;-------------</span><span class="se">\n</span><span class="s">Setting document root: %@</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">webPath</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// 设置服务器路径</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">httpServer</span> <span class="nl">setDocumentRoot</span><span class="p">:</span><span class="n">webPath</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">httpServer</span> <span class="nl">start</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">])</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;-------------</span><span class="se">\n</span><span class="s">Error starting HTTP Server: %@</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>视频下载：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">downloadStreamingMedia:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UIButton</span> <span class="o">*</span><span class="n">downloadButton</span> <span class="o">=</span> <span class="n">sender</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 获取本地Library/Cache路径</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">localDownloadsPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">kLibraryCache</span> <span class="nl">stringByAppendingPathComponent</span><span class="p">:</span><span class="n">kPathDownload</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 获取视频本地路径</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">filePath</span> <span class="o">=</span> <span class="p">[</span><span class="n">localDownloadsPath</span> <span class="nl">stringByAppendingPathComponent</span><span class="p">:</span><span class="s">@&quot;XNjUxMTE4NDAw/movie.m3u8&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSFileManager</span> <span class="o">*</span><span class="n">fileManager</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSFileManager</span> <span class="n">defaultManager</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 判断视频是否缓存完成，如果完成则播放本地缓存</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">fileManager</span> <span class="nl">fileExistsAtPath</span><span class="p">:</span><span class="n">filePath</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">downloadButton</span> <span class="nl">setTitle</span><span class="p">:</span><span class="s">@&quot;已完成&quot;</span> <span class="nl">forState</span><span class="p">:</span><span class="n">UIControlStateNormal</span><span class="p">];</span>
</span><span class='line'>        <span class="n">downloadButton</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>        <span class="n">M3U8Handler</span> <span class="o">*</span><span class="n">handler</span> <span class="o">=</span> <span class="p">[[</span><span class="n">M3U8Handler</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="n">handler</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// 解析m3u8视频地址</span>
</span><span class='line'>        <span class="p">[</span><span class="n">handler</span> <span class="nl">praseUrl</span><span class="p">:</span><span class="n">TEST_HLS_URL</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 开启网络指示器</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">setNetworkActivityIndicatorVisible</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>播放本地视频：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">playVideoFromLocal:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span> <span class="n">playurl</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;http://127.0.0.1:12345/XNjUxMTE4NDAw/movie.m3u8&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;本地视频地址-----%@&quot;</span><span class="p">,</span> <span class="n">playurl</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 获取本地Library/Cache路径</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">localDownloadsPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">kLibraryCache</span> <span class="nl">stringByAppendingPathComponent</span><span class="p">:</span><span class="n">kPathDownload</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 获取视频本地路径</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">filePath</span> <span class="o">=</span> <span class="p">[</span><span class="n">localDownloadsPath</span> <span class="nl">stringByAppendingPathComponent</span><span class="p">:</span><span class="s">@&quot;XNjUxMTE4NDAw/movie.m3u8&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSFileManager</span> <span class="o">*</span><span class="n">fileManager</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSFileManager</span> <span class="n">defaultManager</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 判断视频是否缓存完成，如果完成则播放本地缓存</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">fileManager</span> <span class="nl">fileExistsAtPath</span><span class="p">:</span><span class="n">filePath</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">MPMoviePlayerViewController</span> <span class="o">*</span><span class="n">playerViewController</span> <span class="o">=</span><span class="p">[[</span><span class="bp">MPMoviePlayerViewController</span> <span class="n">alloc</span><span class="p">]</span><span class="nl">initWithContentURL</span><span class="p">:[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span> <span class="n">playurl</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">presentMoviePlayerViewControllerAnimated</span><span class="p">:</span><span class="n">playerViewController</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span><span class="p">{</span>
</span><span class='line'>        <span class="bp">UIAlertView</span> <span class="o">*</span><span class="n">alertView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle</span><span class="p">:</span><span class="s">@&quot;Sorry&quot;</span> <span class="nl">message</span><span class="p">:</span><span class="s">@&quot;当前视频未缓存&quot;</span> <span class="nl">delegate</span><span class="p">:</span><span class="nb">self</span> <span class="nl">cancelButtonTitle</span><span class="p">:</span><span class="s">@&quot;确定&quot;</span> <span class="nl">otherButtonTitles</span><span class="p">:</span><span class="nb">nil</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">alertView</span> <span class="n">show</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>播放在线视频</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">playLiveStreaming</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSURL</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithString</span><span class="p">:</span><span class="n">TEST_HLS_URL</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">MPMoviePlayerViewController</span> <span class="o">*</span><span class="n">player</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">MPMoviePlayerViewController</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithContentURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">presentMoviePlayerViewControllerAnimated</span><span class="p">:</span><span class="n">player</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><del>当然，《芈月传》的直播链接到现在也还没有找到，各位热心读者如果有链接的话可以留言给我，也让这篇文章能实至名归了，能对得文章的标题了😁。</del></p>

<p>同志们，找到了官方的切片工具，已将《芈月传》切片放到了服务器上，1080P高清无码，敬请观看😁
具体代码我也做了更新，请大家更新代码后测试<a href="https://github.com/yangchao0033/HLS-Demo">Demo</a>~</p>

<p>具体播放地址为:<a href="http://yangchao0033.github.io/hlsSegement/0640.m3u8">http://yangchao0033.github.io/hlsSegement/0640.m3u8</a>(可在safari中直接观看)
切片工具博客：<a href="http://www.henishuo.com/hls-streaming-tool/">http://www.henishuo.com/hls-streaming-tool/</a>
总算不用做标题党了，摔🤓~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HLS-iOS视频播放服务架构深入探究（一）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/29/hls-1/"/>
    <updated>2016-01-29T18:10:36+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/29/hls-1</id>
    <content type="html"><![CDATA[<h1>HTTP Live Streaming (HLS)</h1>

<p>苹果官方对于视频直播服务提出了 HLS 解决方案，该方案主要适用范围在于：</p>

<ul>
<li>使用 iPhone 、iPod touch、 iPad 以及 Apple TV 进行流媒体直播功能。（MAC 也能用）</li>
<li>不使用特殊的服务软件进行流媒体直播。</li>
<li>需要通过加密和鉴定（authentication）的视频点播服务。</li>
</ul>


<p>首先，需要大家先对 HLS 的概念进行预览。</p>

<!--more-->


<p>HLS 的目的在于，让用户可以在苹果设备（包括MAC OS X）上通过普通的网络服务完成流媒体的播放。 HLS 同时支持流媒体的<strong>实时广播</strong>和<strong>点播服务</strong>。同时也支持不同 bit 速率的<strong>多个备用流</strong>（平时根据当前网速去自适应视频的清晰度），这样客户端也好根据当前网络的带宽去只能调整当前使用的视频流。安全方面，HLS 提供了通过 HTTPS 加密对媒体文件进行加密 并 对用户进行验证，允许视频发布者去保护自己的网络。</p>

<p>HLS 是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p>

<p>HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p>

<p>苹果对于自家的 HLS 推广也是采取了强硬措施，当你的直播内容持续十分钟
或者每五分钟内超过 5 MB 大小时，你的 APP 直播服务必须采用 HLS 架构，否则不允许上架。（<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW5">详情</a>）</p>

<h1>相关服务支持环境 （重要组成）</h1>

<ul>
<li><code>Adobe Flash Media Server</code>：从4.5开始支持HLS、Protected HLS（PHLS）。5.0改名为Adobe Media Server</li>
<li><a href="http://www.flussonic.com/">Flussonic Media Server</a>：2009年1月21日，版本3.0开始支持VOD、HLS、时移等。</li>
<li>RealNetworks的 <code>Helix Universal Server</code> ：2010年4月，版本15.0开始支持iPhone, iPad和iPod的HTTP直播、点播H.264/AAC内容，最新更新在2012年11月。</li>
<li>微软的IIS Media Services：从4.0开始支持HLS。</li>
<li><code>Nginx RTMP Module</code>：支持直播模式的HLS。</li>
<li><a href="https://wmspanel.com/nimble">Nimber Streamer</a></li>
<li><a href="http://www.unified-streaming.com/">Unified Streaming Platform</a></li>
<li><a href="https://zh.wikipedia.org/wiki/VLC_Media_Player">VLC Media Player</a>：从2.0开始支持直播和点播HLS。</li>
<li>Wowza Media Server：2009年12月9日发布2.0，开始全面支持HLS。</li>
<li>VODOBOX Live Server：始支持HLS。</li>
<li><a href="http://github.com/i4tv/gstreamill">Gstreamill</a>是一个支持hls输出的，基于gstreamer的实时编码器。</li>
</ul>


<h1>相关客户端支持环境</h1>

<ul>
<li>iOS从3.0开始成为标准功能。</li>
<li>Adobe Flash Player从11.0开始支持HLS。</li>
<li>Google的Android自Honeycomb（3.0）开始支持HLS。</li>
<li>VODOBOX HLS Player (Android,iOS, Adobe Flash Player)</li>
<li>JW Player (Adobe Flash player)</li>
<li>Windows 10 的 EDGE 浏览器开始支持HLS。</li>
</ul>


<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/art/transport_stream_2x.png" alt="HLS架构" /></p>

<p>其中输入视频源是由摄像机预先录制好的。之后这些源会被编码 <code>MPEG-4</code>（H.264 video 和 AAC audio）格式然后用硬件打包到 <code>MPEG-2</code> 的传输流中。<code>MPEG-2</code> 传输流会被分散为小片段然后保存为一个或多个系列的 .ts 格式的媒体文件。这个过程需要借助编码工具来完成，比如 Apple stream segmenter。</p>

<p>纯音频会被编码为一些音频小片段，通常为 ADTS头的AAC、MP3、或者 AC-3格式。</p>

<p>同时上面提到的那个切片器（segmenter）也会创建一个索引文件，通常会包含这些媒体文件的一个列表，也能包含元数据。他一般都是一个.M38U 个hi的列表。列表元素会关联一个 URL 用于客户端访问。然后按序去请求这些 URL。</p>

<h3>服务器端</h3>

<p>服务端可以采用硬件编码和软件编码两种形式，其功能都是按照上文描述的规则对现有的媒体文件进行切片并使用索引文件进行管理。而软件切片通常会使用 Apple 公司提供的工具或者第三方的集成工具。</p>

<h4>媒体编码</h4>

<p>媒体编码器获取到音视频设备的实时信号，将其编码后压缩用于传输。而编码格式必须配置为客户端所支持的格式，比如 H.264 视频和HE-AAC 音频。当前，支持 用于视频的 MPEG-2 传输流和 纯音频 MPEG 基本流。编码器通过本地网络将 MPEG-2 传输流分发出去，送到流切片器那里。标准传输流和压缩传输流无法混合使用。传输流可以被打包成很多种不同的压缩格式，这里有两个表详细列举了支持的压缩格式类型。
* <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2">Audio Technologies</a>
* <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6">Vedio Technologies</a></p>

<h5>[重点]在编码中图，不要修改视频编码器的设置，比如视频大小或者编码解码器类型。如果避免不了，那修改动作必须发生在一个片段边界。并且需要早之后相连的片段上用 <code>EXT-X-DISCONTINUITY</code> 进行标记。</h5>

<h4>流切片器</h4>

<p>流切片器（通常是一个软件）会通过本地网络从上面的媒体编码器中读取数据，然后将着这些数据一组相等时间间隔的 <code>小</code> 媒体文件。虽然没一个片段都是一个单独的文件，但是他们的来源是一个连续的流，切完照样可以无缝重构回去。</p>

<p>切片器在切片同时会创建一个索引文件，索引文件会包含这些切片文件的引用。每当一个切片文件生成后，索引文件都会进行更新。索引用于追踪切片文件的有效性和定位切片文件的位置。切片器同时也可以对你的媒体片段进行加密并且创建一个密钥文件作为整个过程的一部分。</p>

<h4>文件切片器（相对于上面的流切片器）</h4>

<p>如果已近有编码后的文件（而不是编码流），你可以使用文件切片器，通过它对编码后的媒体文件进行 MPEG-2 流的封装并且将它们分割为等长度的小片段。切片器允许你使用已经存在的音视频库用于 HLS 服务。它和流切片器的功能相似，但是处理的源从流替换流为了文件。</p>

<h3>媒体片段文件</h3>

<p>媒体片段是由切片器生成的，基于编码后的媒体源，并且是由一系列的 <code>.ts</code> 格式的文件组成，其中包含了你想通过 MPEG-2 传送流携带的 H.264 视频 和 AAC
/MP3/AC-3 音频。对于纯音频的广播，切片器可以生产 MPEG 基础音频流，其中包含了 ADTS头的AAC、MP3、或者AC3等音频。</p>

<h3>索引文件（PlayLists）</h3>

<p>通常由切片器附带生成，保存为 <code>.M3U8</code> 格式，<code>.m3u</code> 一般用于 MP3 音频的索引文件。
<a href="">Note</a>如果你的扩展名是.m3u,并且系统支持.mp3文件，那客户的软件可能要与典型的 MP3 playList 保持一致来完成 流网络音频的播放。</p>

<p>下面是一个 <code>.M3U8</code> 的 playlist 文件样例，其中包含了三个没有加密的十秒钟的媒体文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#EXT-X-VERSION:3
</span><span class='line'>#EXTM3U
</span><span class='line'>#EXT-X-TARGETDURATION:10
</span><span class='line'>#EXT-X-MEDIA-SEQUENCE:1
</span><span class='line'> 
</span><span class='line'># Old-style integer duration; avoid for newer clients.
</span><span class='line'>#EXTINF:10,
</span><span class='line'>http://media.example.com/segment0.ts
</span><span class='line'> 
</span><span class='line'># New-style floating-point duration; use for modern clients.
</span><span class='line'>#EXTINF:10.0,
</span><span class='line'>http://media.example.com/segment1.ts
</span><span class='line'>#EXTINF:9.5,
</span><span class='line'>http://media.example.com/segment2.ts
</span><span class='line'>#EXT-X-ENDLIST</span></code></pre></td></tr></table></div></figure>


<p>为了更精确，你可以在 version 3 或者之后的协议版本中使用 float 数来标记媒体片段的时长，并且要明确写明版本号，如果没有版本号，则必须与 version 1 协议保持一致。你可以使用官方提供的切片器去生产各种各样的 playlist 索引文件，详见 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7">媒体文件切片器</a></p>

<h3>分布式部分</h3>

<p>分布式系统是一个网络服务或者一个网络缓存系统，用于通过 HTTP 向客户端发送媒体文件和索引文件。不用自定义模块发送内容。通常仅仅需要很简单的网络配置即可使用。而且这种配置一般就是限制指定 .M38U 文件和 .ts 文件的 MIME 类型。详见 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3">部署 HTTP Live Streaming</a></p>

<h3>客户端部分</h3>

<p>客户端开始时回去抓取 索引文件(.m3u8/.m3u)，其中用URL来标记不同的流。索引文件可以指定可用媒体文件的位置，解密的密钥，以及任何可以切换的流。对于选中的流，客户端会有序的下载每一个可获得的文件。每一个文件都包含流中的连环碎片。一旦下载到足够量的数据，客户端会开始向用户展示重新装配好的媒体资源。</p>

<p>客户端负责抓取任何解密密钥，认证或者展示一个用于认证的界面，之后再解密需要的文件。</p>

<p>这个过程会一直持续知道出现 结束标记 <code>#EXT-X-ENDLIST</code>。如果结束标记不出现，该索引就是用于持续广播的。客户端会定期的加载一些新的索引文件。客户端会从新更新的索引文件中去查找加密密钥并且将关联的URL加入到请求队列中去。</p>

<h3>HLS 的使用</h3>

<p>使用 HLS 需要使用一些工具，当然大部分工具都是服务器端使用的，这里简单了解一下就行，包括 media stream segmenter, a media file segmenter, a stream validator, an id3 tag generator, a variant playlist generator.这些工具用英文注明是为了当你在<a href="https://developer.apple.com/">苹果开发中心</a>中寻找时方便一些。</p>

<h3>会话模式</h3>

<p>通常包含 Live 和 VOD （点播）两种</p>

<p><strong>点播VOD</strong>的特点就是可以获取到一个静态的索引文件，其中那个包含一套完整的资源文件地址。这种模式允许客户端访问全部节目。VOD点播拥有先进的下载技术，包括加密认证技术和动态切换文件传输速率的功能（通常用于不同分辨率视频之间的切换）。</p>

<p><strong>Live</strong> 会话就是实时事件的录制展示。它的索引文件一直处于动态变化的，你需要不断的更新索引文件 playlist 然后移除旧的索引文件。这种类型通过向索引文件添加媒体地址可以很容易的转化为VOD类型。在转化时不要移除原来旧的源，而是通过添加一个 <code>#ET-X-ENDLIST</code> 标记来终止实时事件。转化时如果你的索引文件中包含 <code>EXT-X-PLAYLIST-TYPE</code> 标签，你需要将值从 <code>EVENT</code> 改为 <code>VOD</code>。</p>

<p>ps:自己抓了一个直播的源，从索引中看到的结果是第一次回抓到代表不同带宽的playList(抓取地址：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5.m3u8</code>)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#EXTM3U
</span><span class='line'>#EXT-X-VERSION:3
</span><span class='line'>#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056509,BANDWIDTH=700000,RESOLUTION=1280x720
</span><span class='line'>34338_PVMT5_700/index.m3u8?Dnion_vsnae=34338_PVMT5
</span><span class='line'>#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056535,BANDWIDTH=400000
</span><span class='line'>34338_PVMT5_400/index.m3u8?Dnion_vsnae=34338_PVMT5
</span><span class='line'>#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056535,BANDWIDTH=1024000
</span><span class='line'>34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5</span></code></pre></td></tr></table></div></figure>


<p>这里面的链接不是视频源URL，而是一个用于流切换的主索（下面会有介绍）引我猜想是需要对上一次的抓包地址做一个拼接</p>

<p>组合的结果就是：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5</code>(纯属小学智力题😂。。。)将它作为抓取地址再一次的结果</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#EXTM3U
</span><span class='line'>#EXT-X-VERSION:3
</span><span class='line'>#EXT-X-MEDIA-SEQUENCE:134611
</span><span class='line'>#EXT-X-TARGETDURATION:10
</span><span class='line'>#EXTINF:9.960,
</span><span class='line'>35/1454056634183_128883.ts?Dnion_vsnae=34338_PVMT5
</span><span class='line'>#EXTINF:9.960,
</span><span class='line'>35/1454056644149_128892.ts?Dnion_vsnae=34338_PVMT5
</span><span class='line'>#EXTINF:9.960,
</span><span class='line'>35/1454056654075_128901.ts?Dnion_vsnae=34338_PVMT5</span></code></pre></td></tr></table></div></figure>


<p>同理，继续向下抓：（拼接地址：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5/35/1454056634183_128883.ts?Dnion_vsnae=34338_PVMT5/36/1454059958599_131904.ts?Dnion_vsnae=34338_PVMT5</code>）
抓取结果：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#EXTM3U
</span><span class='line'>#EXT-X-VERSION:3
</span><span class='line'>#EXT-X-MEDIA-SEQUENCE:134984
</span><span class='line'>#EXT-X-TARGETDURATION:10
</span><span class='line'>#EXTINF:9.280,
</span><span class='line'>36/1454059988579_131931.ts?Dnion_vsnae=34338_PVMT5
</span><span class='line'>#EXTINF:9.960,
</span><span class='line'>36/1454059998012_131940.ts?Dnion_vsnae=34338_PVMT5
</span><span class='line'>#EXTINF:9.960,
</span><span class='line'>36/1454060007871_131949.ts?Dnion_vsnae=34338_PVMT5</span></code></pre></td></tr></table></div></figure>


<p>相比于第二次又获取了一个片段的索引，而且只要是第二次之后，资源地址都会包含 <code>.ts</code>，说明里面是有视频资源URL的，不过具体的截取方法还是需要查看前面提到的IETF的那套标准的HLS的协议，利用里面的协议应该就能拼接出完整的资源路径进行下载。反正我用苹果自带的MPMoviePlayerController直接播放是没有问题的，的确是直播资源。与之前说过的苹果自带的QuickTime类似，都遵循了HLS协议用于流媒体播放。而每次通过拼接获取下一次的索引，符合协议里提到的不断的更替索引的动作。</p>

<h3>内容加密</h3>

<p>如果内容需要加密，你可以在索引文件中找到密钥的相关信息。如果索引文件中包含了一个密钥文件的信息，那接下来的媒体文件就必须使用密钥解密后才能解密打开了。当前的 HLS 支持使用16-octet 类型密钥的 AES-128 加密。这个密钥格式是一个由着在二进制格式中的16个八进制组的数组打包而成的。</p>

<p>加密的配置模式通常包含三种：
1. 模式一：允许你在磁盘上制定一个密钥文件路径，切片器会在索引文件中插入存在的密钥文件的 URL。所有的媒体文件都使用该密钥进行加密。
2. 模式二：切片器会生成一个随机密钥文件，将它保存在指定的路径，并在索引文件中引用它。所有的媒体文件都会使用这个随机密钥进行加密。
3. 模式三：每 n 个片段生成一个随机密钥文件，并保存到指定的位置，在索引中引用它。这个模式的密钥处于轮流加密状态。每一组 n 个片段文件会使用不同的密钥加密。</p>

<blockquote><p>理论上，不定期的碎片个数生成密钥会更安全，但是定期的生成密钥不会对系统的性能产生太大的影响。</p></blockquote>

<p>你可以通过 HTTP 或者 HTTPS 提供密钥。也可以选择使用你自己的基于会话的认证安排去保护发送的key。更多详情可以参考 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW2">通过 HTTPS 安全的提供预约</a></p>

<p>密钥文件需要一个 initialization vector (IV) 去解码加密的媒体文件。IV 可以随着密钥定期的改变。</p>

<h3>缓存和发送协议</h3>

<p>HTTPS通常用于发送密钥，同时，他也可以用于平时的媒体片段和索引文件的传输。但是当扩展性更重要时，这样做是不推荐的。HTTPS 请求通常都是绕开 web 服务缓存，导致所有内容请求都是通过你的服务进行转发，这有悖于分布式网络连接系统的目的。</p>

<p>处于这个原因，确保你发送的网络内容都明白非常重要。当处于实况广播模式时索引文件不会像分片媒体文件一样长时间的被缓存，他会动态不停地变化。</p>

<h3>流切换</h3>

<p>如果你的视频具备流切换功能，这对于用户来说是一个非常棒的体验，处于不同的带宽、不同的网速播放不同清晰度的视频流，这样只能的流切换可以保证用户感觉到非常流畅的观影体验，同时不同的设备也可以作为选择的条件，比如视网膜屏可以再网速良好的情况下播放清晰度更高的视频流。</p>

<p>这种功能的实现在于，索引文件的特殊结构</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/art/indexing_2x.png" alt="流切换索引文件结构" /></p>

<p>有别于普通的索引，具备流热切换的索引通常由主索引和链接不同带宽速率的资源的子索引，由子索引再链接对引得.ts视频切片文件。其中主索引只下载一次，而子索引则会不停定期的下载，通常会先使用主索引中列出的第一个子索引，之后才会根据当时的网络情况去动态切换合适的流。客户端会在任何时间去切换不同的流。比如连入或者退出一个 wifi 热点。所有的切换都会使用相同的音频文件（换音频没多大意思相对于视频）在不同的流之间平滑的进行切换。
这一套不同速率的视频都是有工具生成的，使用<code>variantplaylistcreator</code> 工具并且为 <code>mediafilesegmenter</code> 或者 <code>mediastreamsegmenter</code> 指定 -generate-variant-playlist 选项,详情参考 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW3">下载工具</a></p>

<p>概念先写到这吧，前面的知识够对HSL的整体结构做一个初步的了解。</p>

<p>后面一篇博客会结合代码对整个流程进行说明。</p>

<h4>参考文献：</h4>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html#//apple_ref/doc/uid/TP40008332-CH101-SW4">苹果官方文档</a></p>

<p><a href="https://zh.wikipedia.org/wiki/HTTP_Live_Streaming#.E5.AE.A2.E6.88.B7.E7.AB.AF.E6.94.AF.E6.8C.81">维基百科</a></p>

<p><a href="http://my.oschina.net/CgShare/blog/302303">http://my.oschina.net/CgShare/blog/302303</a></p>

<p><a href="http://blog.csdn.net/woaifen3344/article/details/40837803">http://blog.csdn.net/woaifen3344/article/details/40837803</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreText基础概念（扫盲篇）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/26/coretextji-chu/"/>
    <updated>2016-01-26T18:00:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/26/coretextji-chu</id>
    <content type="html"><![CDATA[<h2>CoreText 基础扫盲（阅读源码必看了）</h2>

<p>这段时间阅读ibireme神的源码，看到了 CoreText 排版这一块，里面包含了很多文字排版的专有名词，这里做一下整理，顺便帮大家安利一下。</p>

<p>CoreText 框架中最常用的几个类：</p>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFontRef/Reference/reference.html#//apple_ref/doc/uid/TP40005110">CTFont</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFontCollectionRef/Reference/reference.html#//apple_ref/doc/uid/TP40005104">CTFontCollection</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFontDescriptorRef/Reference/reference.html#//apple_ref/doc/uid/TP40005107">CTFontDescriptor</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFrameRef/Reference/reference.html#//apple_ref/doc/uid/TP40005113">CTFrame</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFramesetterRef/Reference/reference.html#//apple_ref/doc/uid/TP40005105">CTFramesetter</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTGlyphInfoRef/Reference/reference.html#//apple_ref/doc/uid/TP40005108">CTGlyphInfo</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTLineRef/Reference/reference.html#//apple_ref/doc/uid/TP40005111">CTLine</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTParagraphStyleRef/Reference/reference.html#//apple_ref/doc/uid/TP40005114">CTParagraphStyle</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTRunRef/Reference/reference.html#//apple_ref/doc/uid/TP40005106">CTRun</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTTextTabRef/Reference/reference.html#//apple_ref/doc/uid/TP40005109">CTTextTab</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTTypesetterRef/Reference/reference.html#//apple_ref/doc/uid/TP40005112">CTTypesett</a></li>
</ul>


<p>下面是该框架的结构图</p>

<!--more-->


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/CoreText%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt="coretext架构图" /></p>

<p>CTFrame 作为一个整体的画布(Canvas)，其中由行(CTLine)组成，而每行可以分为一个或多个小方块（CTRun）。
注意：你不需要自己创建CTRun，Core Text将根据NSAttributedString的属性来自动创建CTRun。每个CTRun对象对应不同的属性，正因此，你可以自由的控制字体、颜色、字间距等等信息。
通常处理步聚：
1.使用core text就是先有一个要显示的string，然后定义这个string每个部分的样式－>attributedString －> 生成 CTFramesetter -> 得到CTFrame -> 绘制（CTFrameDraw）
其中可以更详细的设置换行方式，对齐方式，绘制区域的大小等。
2.绘制只是显示，点击事件就需要一个判断了。
CTFrame 包含了多个CTLine,并且可以得到各个line的其实位置与大小。判断点击处在不在某个line上。CTLine 又可以判断这个点(相对于ctline的坐标)处的文字范围。然后遍历这个string的所有NSTextCheckingResult，根据result的rang判断点击处在不在这个rang上，从而得到点击的链接与位置。</p>

<h3>字体的基本知识</h3>

<p><strong>字体(Font):</strong>是一系列字号、样式和磅值相同的字符(例如:10磅黑体Palatino)。现多被视为字样的同义词</p>

<p><strong>字面(Face):</strong>是所有字号的磅值和格式的综合</p>

<p><strong>字体集(Font family):</strong>是一组相关字体(例如:Franklin family包括Franklin Gothic、Fran-klinHeavy和Franklin Compressed)</p>

<p><strong>磅值(Weight):</strong>用于描述字体粗度。典型的磅值,从最粗到最细,有极细、细、book、中等、半粗、粗、较粗、极粗</p>

<p><strong>样式(Style):</strong>字形有三种形式:Roman type是直体;oblique type是斜体;utakuc type是斜体兼曲线(比Roman type更像书法体)。</p>

<p><strong>x高度(X height):</strong>指小写字母的平均高度(以x为基准)。磅值相同的两字母,x高度越大的字母看起来比x高度小的字母要大</p>

<p><strong>Cap高度(Cap height):</strong>与x高度相似。指大写字母的平均高度(以C为基准)</p>

<p><strong>下行字母(Descender):</strong>例如在字母q中,基线以下的字母部分叫下伸部分</p>

<p><strong>上行字母(Ascender):</strong>x高度以上的部分(比如字母b)叫做上伸部分</p>

<p><strong>基线(Baseline):</strong>通常在x、v、b、m下的那条线
描边(Stroke):组成字符的线或曲线。可以加粗或改变字符形状</p>

<p><strong>衬线(Serif):</strong>用来使字符更可视的一条水平线。如字母左上角和下部的水平线。</p>

<p><strong>无衬线(Sans Serif):</strong>可以让排字员不使用衬线装饰。</p>

<p><strong>方形字(Block):</strong>这种字体的笔画使字符看起来比无衬线字更显眼,但还不到常见的衬线字的程度。例如Lubalin Graph就是方形字,这种字看起来好像是木头块刻的一样</p>

<p><strong>手写体脚本(Calligraphic script):</strong>是一种仿效手写体的字体。例如Murray Hill或者Fraktur字体</p>

<p><strong>艺术字(Decorative):</strong>像绘画般的字体</p>

<p><strong>Pi符号(Pisymbol):</strong>非标准的字母数字字符的特殊符号。例如Wingdings和Mathematical Pi</p>

<p><strong>连写(Ligature):</strong>是一系列连写字母如fi、fl、ffi或ffl。由于字些字母形状的原因经常被连写,故排字员已习惯将它们连写。</p>

<p>读完了上面这些概念，可以参考一下下面的图片，看看具体的位置</p>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/%E6%96%87%E5%AD%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%860.gif?raw=true" alt="文字结构" />
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/%E6%96%87%E5%AD%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861.gif?raw=true" alt="文字结构" /></p>

<p>其中，在 Apple 的 SDK 中是这样定义这些属性的</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTCharacterShapeAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//字体形状属性  必须是CFNumberRef对象默认为0，非0则对应相应的字符形状定义，如1表示传统字符形状</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTFontAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//字体属性   必须是CTFont对象</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTKernAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//字符间隔属性 必须是CFNumberRef对象</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTLigatureAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//设置是否使用连字属性，设置为0，表示不使用连字属性。标准的英文连字有FI,FL.默认值为1，既是使用标准连字。也就是当搜索到f时候，会把fl当成一个文字。必须是CFNumberRef 默认为1,可取0,1,2</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTForegroundColorAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//字体颜色属性  必须是CGColor对象，默认为black</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTForegroundColorFromContextAttributeName</span><span class="p">;</span>
</span><span class='line'> <span class="c1">//上下文的字体颜色属性 必须为CFBooleanRef 默认为False</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTParagraphStyleAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//段落样式属性 必须是CTParagraphStyle对象 默认为NIL</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTStrokeWidthAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//笔画线条宽度 必须是CFNumberRef对象，默为0.0f，标准为3.0f</span>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTStrokeColorAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//笔画的颜色属性 必须是CGColorRef 对象，默认为前景色</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTSuperscriptAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//设置字体的上下标属性 必须是CFNumberRef对象 默认为0,可为-1为下标,1为上标，需要字体支持才行。如排列组合的样式Cn1</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTUnderlineColorAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//字体下划线颜色属性 必须是CGColorRef对象，默认为前景色</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTUnderlineStyleAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//字体下划线样式属性 必须是CFNumberRef对象,默为kCTUnderlineStyleNone 可以通过CTUnderlineStypleModifiers 进行修改下划线风格</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTVerticalFormsAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//文字的字形方向属性 必须是CFBooleanRef 默认为false，false表示水平方向，true表示竖直方向</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTGlyphInfoAttributeName</span><span class="p">;</span>
</span><span class='line'><span class="c1">//字体信息属性 必须是CTGlyphInfo对象</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">CFStringRef</span> <span class="n">kCTRunDelegateAttributeName</span>
</span><span class='line'><span class="c1">//CTRun 委托属性 必须是CTRunDelegate对象</span>
</span></code></pre></td></tr></table></div></figure>


<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSMutableAttributedString</span> <span class="o">*</span><span class="n">mabstring</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableAttributedString</span> <span class="n">alloc</span><span class="p">]</span><span class="nl">initWithString</span><span class="p">:</span><span class="s">@&quot;This is a test of characterAttribute. 中文字符&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex0.jpg?raw=true" alt="文字结构" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="c1">//设置字体属性</span>
</span><span class='line'>    <span class="n">CTFontRef</span> <span class="n">font</span> <span class="o">=</span> <span class="n">CTFontCreateWithName</span><span class="p">(</span><span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;Georgia&quot;</span><span class="p">),</span> <span class="mi">40</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTFontAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">font</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex1.jpg?raw=true" alt="文字结构" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//设置斜体字</span>
</span><span class='line'>    <span class="n">CTFontRef</span> <span class="n">font</span> <span class="o">=</span> <span class="n">CTFontCreateWithName</span><span class="p">((</span><span class="n">CFStringRef</span><span class="p">)[</span><span class="bp">UIFont</span> <span class="nl">italicSystemFontOfSize</span><span class="p">:</span><span class="mi">20</span><span class="p">].</span><span class="n">fontName</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTFontAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">font</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex2.jpg?raw=true" alt="文字结构" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//下划线</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTUnderlineStyleAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)[</span><span class="bp">NSNumber</span> <span class="nl">numberWithInt</span><span class="p">:</span><span class="n">kCTUnderlineStyleDouble</span><span class="p">]</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex3.jpg?raw=true" alt="文字结构" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//下划线颜色</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTUnderlineColorAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)[</span><span class="bp">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="bp">CGColor</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex4.jpg?raw=true" alt="文字结构" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//设置字体简隔 eg:test </span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFNumberRef</span> <span class="n">num</span> <span class="o">=</span> <span class="n">CFNumberCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span><span class="n">kCFNumberSInt8Type</span><span class="p">,</span><span class="o">&amp;</span><span class="n">number</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTKernAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">num</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex5.jpg?raw=true" alt="文字结构" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//设置连字</span>
</span><span class='line'><span class="kt">long</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFNumberRef</span> <span class="n">num</span> <span class="o">=</span> <span class="n">CFNumberCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span><span class="n">kCFNumberSInt8Type</span><span class="p">,</span><span class="o">&amp;</span><span class="n">number</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTLigatureAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">num</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">str</span> <span class="n">length</span><span class="p">])];</span>
</span></code></pre></td></tr></table></div></figure>


<p>暂时没有效果图</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//设置字体颜色</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTForegroundColorAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)[</span><span class="bp">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="bp">CGColor</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex6.jpg?raw=true" alt="文字结构" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//设置字体颜色为前影色</span>
</span><span class='line'>    <span class="n">CFBooleanRef</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">kCFBooleanTrue</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTForegroundColorFromContextAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">flag</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p>暂无效果。。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//设置空心字</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFNumberRef</span> <span class="n">num</span> <span class="o">=</span> <span class="n">CFNumberCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span><span class="n">kCFNumberSInt8Type</span><span class="p">,</span><span class="o">&amp;</span><span class="n">number</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTStrokeWidthAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">num</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">str</span> <span class="n">length</span><span class="p">])];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex7.jpg?raw=true" alt="文字结构" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//设置空心字</span>
</span><span class='line'>    <span class="kt">long</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFNumberRef</span> <span class="n">num</span> <span class="o">=</span> <span class="n">CFNumberCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span><span class="n">kCFNumberSInt8Type</span><span class="p">,</span><span class="o">&amp;</span><span class="n">number</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTStrokeWidthAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">num</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">str</span> <span class="n">length</span><span class="p">])];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//设置空心字颜色</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttribute</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTStrokeColorAttributeName</span> <span class="nl">value</span><span class="p">:(</span><span class="kt">id</span><span class="p">)[</span><span class="bp">UIColor</span> <span class="n">greenColor</span><span class="p">].</span><span class="bp">CGColor</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="n">str</span> <span class="n">length</span><span class="p">])];</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex8.jpg?raw=true" alt="文字结构" /></p>

<p><strong>在设置空心字颜色时，必须先将字体高为空心，否则设置颜色是没有效果的。</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//对同一段字体进行多属性设置    </span>
</span><span class='line'>    <span class="c1">//红色</span>
</span><span class='line'>    <span class="bp">NSMutableDictionary</span> <span class="o">*</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableDictionary</span> <span class="nl">dictionaryWithObject</span><span class="p">:(</span><span class="kt">id</span><span class="p">)[</span><span class="bp">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="bp">CGColor</span> <span class="nl">forKey</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTForegroundColorAttributeName</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//斜体</span>
</span><span class='line'>    <span class="n">CTFontRef</span> <span class="n">font</span> <span class="o">=</span> <span class="n">CTFontCreateWithName</span><span class="p">((</span><span class="n">CFStringRef</span><span class="p">)[</span><span class="bp">UIFont</span> <span class="nl">italicSystemFontOfSize</span><span class="p">:</span><span class="mi">20</span><span class="p">].</span><span class="n">fontName</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">attributes</span> <span class="nl">setObject</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">font</span> <span class="nl">forKey</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTFontAttributeName</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//下划线</span>
</span><span class='line'>    <span class="p">[</span><span class="n">attributes</span> <span class="nl">setObject</span><span class="p">:(</span><span class="kt">id</span><span class="p">)[</span><span class="bp">NSNumber</span> <span class="nl">numberWithInt</span><span class="p">:</span><span class="n">kCTUnderlineStyleDouble</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTUnderlineStyleAttributeName</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttributes</span><span class="p">:</span><span class="n">attributes</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex9.jpg?raw=true" alt="文字结构" /></p>

<p>最后 Draw 一下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">characterAttribute</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="s">@&quot;This is a test of characterAttribute. 中文字符&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSMutableAttributedString</span> <span class="o">*</span><span class="n">mabstring</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableAttributedString</span> <span class="n">alloc</span><span class="p">]</span><span class="nl">initWithString</span><span class="p">:</span><span class="n">str</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="n">beginEditing</span><span class="p">];</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    long number = 1;</span>
</span><span class='line'><span class="cm">    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTCharacterShapeAttributeName value:(id)num range:NSMakeRange(0, 4)];</span>
</span><span class='line'><span class="cm">    */</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    //设置字体属性</span>
</span><span class='line'><span class="cm">    CTFontRef font = CTFontCreateWithName(CFSTR(&quot;Georgia&quot;), 40, NULL);</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTFontAttributeName value:(id)font range:NSMakeRange(0, 4)];</span>
</span><span class='line'><span class="cm">    */</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    //设置字体简隔 eg:test </span>
</span><span class='line'><span class="cm">    long number = 10;</span>
</span><span class='line'><span class="cm">    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTKernAttributeName value:(id)num range:NSMakeRange(10, 4)];</span>
</span><span class='line'><span class="cm">    */</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    long number = 1;</span>
</span><span class='line'><span class="cm">    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTLigatureAttributeName value:(id)num range:NSMakeRange(0, [str length])];</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    //设置字体颜色</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTForegroundColorAttributeName value:(id)[UIColor redColor].CGColor range:NSMakeRange(0, 9)];</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    //设置字体颜色为前影色</span>
</span><span class='line'><span class="cm">    CFBooleanRef flag = kCFBooleanTrue;</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTForegroundColorFromContextAttributeName value:(id)flag range:NSMakeRange(5, 10)];</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    //设置空心字</span>
</span><span class='line'><span class="cm">    long number = 2;</span>
</span><span class='line'><span class="cm">    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTStrokeWidthAttributeName value:(id)num range:NSMakeRange(0, [str length])];</span>
</span><span class='line'><span class="cm">     </span>
</span><span class='line'><span class="cm">    //设置空心字颜色</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTStrokeColorAttributeName value:(id)[UIColor greenColor].CGColor range:NSMakeRange(0, [str length])];</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    long number = 1;</span>
</span><span class='line'><span class="cm">    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTSuperscriptAttributeName value:(id)num range:NSMakeRange(3, 1)];</span>
</span><span class='line'><span class="cm">    */</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    //设置斜体字</span>
</span><span class='line'><span class="cm">    CTFontRef font = CTFontCreateWithName((CFStringRef)[UIFont italicSystemFontOfSize:20].fontName, 14, NULL);</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTFontAttributeName value:(id)font range:NSMakeRange(0, 4)];</span>
</span><span class='line'><span class="cm">    */</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/*</span>
</span><span class='line'><span class="cm">    //下划线</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; </span>
</span><span class='line'><span class="cm">    //下划线颜色</span>
</span><span class='line'><span class="cm">    [mabstring addAttribute:(id)kCTUnderlineColorAttributeName value:(id)[UIColor redColor].CGColor range:NSMakeRange(0, 4)];</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//对同一段字体进行多属性设置    </span>
</span><span class='line'>    <span class="c1">//红色</span>
</span><span class='line'>    <span class="bp">NSMutableDictionary</span> <span class="o">*</span><span class="n">attributes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableDictionary</span> <span class="nl">dictionaryWithObject</span><span class="p">:(</span><span class="kt">id</span><span class="p">)[</span><span class="bp">UIColor</span> <span class="n">redColor</span><span class="p">].</span><span class="bp">CGColor</span> <span class="nl">forKey</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTForegroundColorAttributeName</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//斜体</span>
</span><span class='line'>    <span class="n">CTFontRef</span> <span class="n">font</span> <span class="o">=</span> <span class="n">CTFontCreateWithName</span><span class="p">((</span><span class="n">CFStringRef</span><span class="p">)[</span><span class="bp">UIFont</span> <span class="nl">italicSystemFontOfSize</span><span class="p">:</span><span class="mi">20</span><span class="p">].</span><span class="n">fontName</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">attributes</span> <span class="nl">setObject</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">font</span> <span class="nl">forKey</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTFontAttributeName</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">//下划线</span>
</span><span class='line'>    <span class="p">[</span><span class="n">attributes</span> <span class="nl">setObject</span><span class="p">:(</span><span class="kt">id</span><span class="p">)[</span><span class="bp">NSNumber</span> <span class="nl">numberWithInt</span><span class="p">:</span><span class="n">kCTUnderlineStyleDouble</span><span class="p">]</span> <span class="nl">forKey</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">kCTUnderlineStyleAttributeName</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="nl">addAttributes</span><span class="p">:</span><span class="n">attributes</span> <span class="nl">range</span><span class="p">:</span><span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSRange</span> <span class="n">kk</span> <span class="o">=</span> <span class="n">NSMakeRange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">NSDictionary</span> <span class="o">*</span> <span class="n">dc</span> <span class="o">=</span> <span class="p">[</span><span class="n">mabstring</span> <span class="nl">attributesAtIndex</span><span class="p">:</span><span class="mi">0</span> <span class="nl">effectiveRange</span><span class="p">:</span><span class="o">&amp;</span><span class="n">kk</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">mabstring</span> <span class="n">endEditing</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;value = %@&quot;</span><span class="p">,</span><span class="n">dc</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="n">CTFramesetterRef</span> <span class="n">framesetter</span> <span class="o">=</span> <span class="n">CTFramesetterCreateWithAttributedString</span><span class="p">((</span><span class="n">CFAttributedStringRef</span><span class="p">)</span><span class="n">mabstring</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGMutablePathRef</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">CGPathCreateMutable</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGPathAddRect</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">,</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">10</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">,</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">-</span><span class="mi">10</span> <span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="o">-</span><span class="mi">10</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CTFrameRef</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">CTFramesetterCreateFrame</span><span class="p">(</span><span class="n">framesetter</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">Path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>    
</span><span class='line'>
</span><span class='line'>    <span class="c1">//获取当前(View)上下文以便于之后的绘画，这个是一个离屏。</span>
</span><span class='line'>    <span class="n">CGContextRef</span> <span class="n">context</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGContextSetTextMatrix</span><span class="p">(</span><span class="n">context</span> <span class="p">,</span> <span class="n">CGAffineTransformIdentity</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//压栈，压入图形状态栈中.每个图形上下文维护一个图形状态栈，并不是所有的当前绘画环境的图形状态的元素都被保存。图形状态中不考虑当前路径，所以不保存</span>
</span><span class='line'>    <span class="c1">//保存现在得上下文图形状态。不管后续对context上绘制什么都不会影响真正得屏幕。</span>
</span><span class='line'>    <span class="n">CGContextSaveGState</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//x，y轴方向移动</span>
</span><span class='line'>    <span class="n">CGContextTranslateCTM</span><span class="p">(</span><span class="n">context</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">,</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//缩放x，y轴方向缩放，－1.0为反向1.0倍,坐标系转换,沿x轴翻转180度</span>
</span><span class='line'>    <span class="n">CGContextScaleCTM</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">,</span><span class="o">-</span><span class="mf">1.0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CTFrameDraw</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGPathRelease</span><span class="p">(</span><span class="n">Path</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">framesetter</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nv">rect</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="n">characterAttribute</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPod Version Update]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/18/cocoapod-version-update/"/>
    <updated>2016-01-18T15:58:44+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/18/cocoapod-version-update</id>
    <content type="html"><![CDATA[<h3>问题描述：</h3>

<p>使用 pod 安装第三方库时无法使用 <code>pod search</code> 搜索最新的版本</p>

<h3>定位问题：</h3>

<p>使用的 pod 版本过低</p>

<h3>方案：</h3>

<!--more-->


<p>升级pod版本</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ sudo gem update --system
</span><span class='line'>$ gem sources --remove https://rubygems.org/ 
</span><span class='line'>$ gem sources -a https://ruby.taobao.org/ 
</span><span class='line'>$ sudo gem install cocoapods
</span><span class='line'>$ pod setup</span></code></pre></td></tr></table></div></figure>


<p>line 1: 为 <code>gem</code> 升级到最新版<br/>
line 2: 删除 <code>gem</code> 默认的源<br/>
line 3: 添加淘宝的源，为了解除天朝对gem的隔离（ps：<code>gem</code> 到底干了啥，这么苦大仇深？）<br/>
line 4: 安装 <code>CocoaPod</code> (会去新加的源去检查是否有新的内容，有则更新，保持你本地pod拥有最新的库信息)<br/>
line 5: <code>pod</code> 安装将利用刚才的配置更新本地镜像</p>

<h3>使用：</h3>

<p>继续使用 <code>pod search 库名</code>
例如： <code>pod search ReactiveCocoa</code></p>

<p>就能搜到最新的库版本了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（五）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/18/runloop-5/"/>
    <updated>2016-01-18T12:34:58+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/18/runloop-5</id>
    <content type="html"><![CDATA[<p> 接<a href="http://superyang.gitcafe.io/blog/2016/01/08/runloopshen-du-tan-jiu-(4)/">RunLoop深度探究(四)</a></p>

<h2>使用 Run Loop 对象</h2>

<p>一个 run loop 对象提供了一些主要接口用于向你的 run loop 中添加 input source ，timers， 和run loop observer，并且运行它。每一条线程有且只有一个run loop 与他相关联。在 Cocoa 中，这个对象是 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 类的一个实例。在底层的应用中，它是指向 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/tdef/CFRunLoopRef">CFRunLoopRef</a> 这种不透明类型的一个指针。</p>

<h2>获取 Run Loop 对象</h2>

<p>你需要使用以下其中之一来获取当前线程的 Run Loop ：</p>

<!--more-->


<ul>
<li>在 Cocoa 中，使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 的类方法 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/clm/NSRunLoop/currentRunLoop">currentRunLoop</a> 去拿到一个 <code>NSRunLoop</code> 对象。</li>
<li>使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopGetCurrent">CFRunLoopGetCurrent</a> 函数。</li>
</ul>


<p>尽管这两种方法不是 <a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">toll-free bridged type</a>(在Foundation 和 Core Foundation 中拥有等价替换接口的能力的类型)的类型,但是如果你需要可以从 <code>NSRunLoop</code> 对象里拿到 CFRunLoopRef 这种<code>不透明类型</code>(苹果封装在内部的C语言类型)。<code>NSRunLoop</code> 类定义了 <code>getCFRunLoop</code> 方法用来返回一个可以传入到 Core Foundation 代码中的 <code>CFRunLoopRef</code> 类型的C语言指针对象（结构体指针）。这两种对象都可以来自于同一个 run loop，你可以根据你的需要来选择具体使用 <code>NSRunLoop</code> 和 <code>CFRunLoopRef</code> 这两种对象的哪一种。</p>

<h2>配置 Run Loop</h2>

<p>在你运行一个子线程的 run loop 之前，你必须向其添加至少一个 input source 或者 timer。如果 run loop 没有任何需要监视的 source， 它将会在你尝试运行它的时候立即退出。请参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7">配置RunLoop Sounce</a>（本文接下来的章节将有介绍）。</p>

<p>除了安装 source，你还可以 run loop observer 并且使用他们检测 runloop的处于不同执行阶段。为了安装 run loop observer ，你需要创建一个 CFRunLoopObserverRef 不透明类型的指针并使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddObserver">CFRunLoopAddObserver</a> 函数将 Observer 添加到你的 run loop 中去，Run Loop Observer 必须使用 Core Foundation 框架接口创建，在 Cocoa 应用中也一样。</p>

<p>表 3-1 展示了在线程 runloop 中，添加 run loop Observer 的主要代码流程。本例的目的旨在告诉你如何创建一个 run loop Observer， 所以代码只是简单设置了一个run loop Observer 用来监视 run loop 的所有活动 。基本的处理代码（没有展示）仅仅是日志输出 run loop 的各项活动行为 作为 timer 的事件回调。</p>

<p>表3-1 创建 runloop Observer</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">threadMain</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 应用使用垃圾回收，所以不需要 自动释放池 autorelease pool</span>
</span><span class='line'>    <span class="bp">NSRunLoop</span> <span class="o">*</span><span class="n">myRunLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 创建一个 run loop observer 并且将他添加到当前 run loop 中去</span>
</span><span class='line'>    <span class="cm">/*!</span>
</span><span class='line'><span class="cm">     *  @author 杨超, 16-01-13 15:01:45</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     *  @brief CFRunLoopObserverContext 用来配置 CFRunLoopObserver 对象行为的结构体</span>
</span><span class='line'><span class="cm">     typedef struct {</span>
</span><span class='line'><span class="cm">        CFIndex  version;</span>
</span><span class='line'><span class="cm">        void *   info;</span>
</span><span class='line'><span class="cm">        const void *(*retain)(const void *info);</span>
</span><span class='line'><span class="cm">        void (*release)(const void *info);</span>
</span><span class='line'><span class="cm">        CFStringRef  (*copyDescription)(const void *info);</span>
</span><span class='line'><span class="cm">     } CFRunLoopObserverContext;</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     *  @param version 结构体版本号，必须为0</span>
</span><span class='line'><span class="cm">     *  @param info 一个程序预定义的任意指针，可以再 run loop Observer 创建时为其关联。这个指针将被传到所有 context 多定义的所有回调中。</span>
</span><span class='line'><span class="cm">     *  @param retain 程序定义 info 指针的内存保留（retain）回调,可以为 NULL</span>
</span><span class='line'><span class="cm">     *  @param release 程序定义 info 指针的内存释放（release）回调，可以为 NULL</span>
</span><span class='line'><span class="cm">     *  @param copyDescription 程序定于 info 指针的 copy 描述回调，可以为 NULL</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     *  @since</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">CFRunLoopObserverContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span> <span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="nb">self</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'>    <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">CFRunLoopObserverCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="n">kCFRunLoopAllActivities</span><span class="p">,</span> <span class="nb">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myRunLoopObserverCallBack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">observer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CFRunLoopRef</span> <span class="n">cfLoop</span> <span class="o">=</span> <span class="p">[</span><span class="n">myRunLoop</span> <span class="n">getCFRunLoop</span><span class="p">];</span>
</span><span class='line'>        <span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">cfLoop</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建并安排好 timer</span>
</span><span class='line'>    <span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">0.1</span> <span class="nl">target</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doFireTimer</span><span class="p">)</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSInteger</span> <span class="n">loopCount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 3秒后运行 run loop 实际效果是每三秒进入一次当前 while 循环</span>
</span><span class='line'>        <span class="p">[</span><span class="n">myRunLoop</span> <span class="nl">runUntilDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="nl">dateWithTimeIntervalSinceNow</span><span class="p">:</span><span class="mi">3</span><span class="p">]];</span>
</span><span class='line'>        <span class="n">loopCount</span> <span class="o">--</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">loopCount</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">myRunLoopObserverCallBack</span><span class="p">(</span><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span> <span class="n">activity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;observer正在回调</span><span class="se">\n</span><span class="s">%@----%tu----%@&quot;</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">activity</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doFireTimer</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;计时器回调&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当为一个长期存活的现场配置 runloop 时，至少添加一个 input source 去接收消息。尽管你可以仅仅使用一个 关联的timer 就可以进入 run loop，一旦 timer 启动，通常都会被作废掉，这将会硬气 run loop 的退出。关联一个重复执行的 timer 定时器可以保持让 runloop 在很长的一段时期内得以运行，但是需要周期性的去启动定时器 timer 来唤醒你的线程，这是投票有效的另一种形式（这句莫名其妙，不懂是干吗的）。相比之下， input source 会等待事件的发生，并保持线程处于睡眠状态直到事件确实发生了。</p>

<h2>开动 run loop</h2>

<p>在应用中，只有在子线程中才是有必要开启 run loop 的，一个 run loop 必须至少有一个用来监视的 input source 。如果一个关联的都没有，run loop 将会立即退出。</p>

<p>下面有一些方法开启 run loop：
* 无条件的
* 通过一套时间限制
* 在一个特别的 mode 下</p>

<p>无条件的进入你的 run loop 是最简单的选项，但这种也是最不可取的。无条件地运行你的 run loop 将会使你的线程进入进入永久的循环中，这使你很难控制运行循环本身。你可以添加和移除 input source 和 timer，但是只有一种方式去停止 run loop，那就是将它杀死。同时也不存在在自定义 mode 中运行 run loop 的方法。</p>

<p>为了替代无条件的运行 run loop ，更好的办法是使用超时值来运行 runloop。当你使用超时值时，run loop 会一直运行直到在事件来临时 或者 分配的时间结束时。当你的事件到达时，系统会分配一个 handler 去处理它，并且之后 run loop 会退出。你可以用代码重启你的 run loop 以便处理下一个事件。如果不想继续使用刚才分配时间结束的原则，也可以简单的重启 runloop 或者使用这些时间去做任何你需要做的事。</p>

<p>除了使用超时值，你也可以使用指定的 mode 运行 run loop。mode 和超时值不会互相排斥，并且都可以用来启动一个线程。</p>

<p>表 3-2 展示了一个线程入口的常用的例行程序。示例代码的关键部分展示了一个 run loop 的基础架构。本质上，你将 input sources 和 timers 添加到你的 runloop 中，然后重复的调用其中一个例行程序来启动 run loop 。每一次例行程序返回时，你需要检查一下是否满足可能会退出线程的条件。示例使用了 Core Foundation 的框架的例行程序以便检查返回结果并且可以决定如何退出 runloop。如果你是用的是 Cocoa ，你也可以使用类似的方式通过 NSRunLoop 的方法去运行 runloop ，    并且不需要检查返回值。（使用 NSRunLoop 的方法的例子可以参考 表3-14.）</p>

<p>表 3-2 运行 runloop</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">skeletionThreadMain</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 如果你的应用没有使用垃圾回收 请在这里添加 自动释放池（ps：这示例代码也太老了，谁还用垃圾回收啊）</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 给 runloop 添加 source 或timer，然后做一些其他的配置</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 开启 runloop 并且被一个 source 被处理后要返回</span>
</span><span class='line'>        <span class="cm">/** SInt32 32位有符号整数 */</span>
</span><span class='line'>        <span class="kt">SInt32</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CFRunLoopRunInMode</span><span class="p">(</span><span class="n">kCFRunLoopDefaultMode</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">YES</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果 source 已经显式的停止了 runloop ，或者根本不存在任何 source 或 timer，将会退出。</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">==</span> <span class="n">kCFRunLoopRunStopped</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">kCFRunLoopRunFinished</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">done</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>            <span class="c1">// 在这里检查任何其他符合退出的条件并且按需设置 done 变量的值。</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 在这里清除代码。确保释放任何之前创建的自动释放池。</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以递归开启 runloop，换句话说，你可以使用 input source 或者 timer 的例行程序来调用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopRun">CFRunLoopRun</a>,<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopRunInMode">CFRunLoopRunInMode</a>或者任何 NSRunLoop 的 runloop 启动方法。这样做你可以使用任何你想用的 mode 来运行一个 嵌套的 run loop ，包括 通过外层 run loop 使用的 mode 。</p>

<h3>退出 RunLoop</h3>

<p>有两种途径可以让 runloop 在处理事件之前退出：</p>

<ul>
<li>使用超时值配置 runloop 运行。</li>
<li>直接告诉 runloop 停止（ps：。。。这条太搞了）。</li>
</ul>


<p>使用超时值无疑是更偏爱的方法，如果你能管理它，指定一个超时值使 runloop 结束所有他的正常处理的任务， 包括在退出前向 runloop observer 发送通知。</p>

<p>使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopStop">CFRunLoopStop</a> 函数显示地停止 runloop，产生的结果和超时相似。runloop 会发送任何 runloop 提醒通知然后才退出。不同的是你可以将这项技术应用在你用无条件方式开启的 runloop 上。</p>

<p>尽管移除一个 runloop 的 input source 和 timer 可以造成 runloop 的退出，但这并不是一个可靠的方式来停止 runloop 。一些系统例行程序给 runloop 添加一些 input source 来处理必要的事件。你的代码可能无法看出这些 input source，你可能不能移除这些用来防止 runloop  退出的 source。</p>

<h3>线程安全 和 Run Loop 对象</h3>

<p>线程安全大多取决于你用来操作 runloop 的API。Core Foundation 函数 一般来说都是线程安全的，所以可以被任何线程调用。假如你正在执行一个修改 runloop 配置的操作，那么继续吧，对拥有 runloop 的线程来说这样做仍然是很好的作法。</p>

<p>Cocoa 的 <code>NSRunLoop</code> 类内部不像 Core Foundation 中的接口那样是线程安全的。如果你要使用 NSRunLoop 类去修改你的 runloop，你只能在 runloop 所在的线程中这样做。先其他线程中的 runloop 中添加 input source 或 timer 会引起你的程序崩溃或出现不可预知的异常。</p>

<h3>配置 run loop source</h3>

<p>接下来的章节将展示如何在 Cocoa 和 Core Foundation 中设置不同类型的 input source。</p>

<h4>定义一个自定义自定义 input source</h4>

<p>创建一个自定义的 input source 你需要实现以下这些条件：</p>

<ul>
<li>你想要你的 source 处理的信息</li>
<li>一段调度模块的例行程序让感兴趣的客户机了解如何连接你的 input source。</li>
<li>一段处理模块例行程序用来处理任何客户机发送的请求</li>
<li>一段取消模块的例行程序用来销毁你的 source</li>
</ul>


<p>因为你创建了一个自定义的 input source 来处理自定义的信息，所以实际上的配置会设计的非常灵活。调度模块，处理模块和取消模块的例行程序几乎都是你的自定义 input source 的关键例行程序。剩下的大多数 input source 行为都发生在这些例行处理程序之外。比如，由你来定义一个工具用来将数据传到你的 input source并且传递你的 input source 的数据到其他线程中去。</p>

<p>插图 3-2 展示了一个简单的自定义 input source 的配置。在本例中，应用程序主线程维持引用了input source ， input source 的缓冲模块，还有安装 input source 的 runloop。当主线程有一个任务向切换到工作子线程中去，他会发送一个命令，命令缓冲区以及启动任务所需的任何线程的信息（因为主线程和工作子线程的 input source 都有权限去访问命令缓冲区，访问必须同步）一旦命令发送了，主线程会发送信号给 input source 来唤醒工作子线程的 runloop。一旦受到唤醒的命令， runloop 会调用 input source 的处理程序 去处理命令缓存器中缓存的命令。</p>

<p>图 3-2 操作一个自定义 input source</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt="图 3-2" /></p>

<p>接下来的章节将会解释如何通过上图实现一个自定义 input source 并展示你需要实现的关键代码。</p>

<h3>定义 input source</h3>

<p>定义一个自定义 input source 需要使用 Core Foundation 的例行程序配置你的 runloop input source 并且 将它与你的 runloop 关联。尽管基础处理程序是基于 C-语言 函数的，但这不会阻止你使用 Objective-C 或者 C++ 去封装它为面向对象的代码。</p>

<p>插图3-2中介绍的 input source 使用一个 objective-C 对象去管理一个命令缓存器，并与 runloop 进行协调。列表3-3 展示了这个对象的定义。<code>RunLoopSource</code> 对象管理一个命令缓冲器，并且使用命令缓存器接受来自其他线程的消息。该表也展示了 <code>RunLoopContext</code> 对象的定义，该对象仅仅是一个容器，用来传递一个 <code>RunLoopSource</code> 对象和应用主线程的 runloop 引用。</p>

<p>表 3-3 自定义 input source 对象的定义</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">YCRunLoopSource</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopSourceRef</span> <span class="n">runLoopSource</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">commands</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 添加</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addToCurrentRunLoop</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 销毁</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">invalidate</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 处理方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sourceFired</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用来注册需要处理的命令的客户机接口</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addCommand:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">command</span> <span class="nf">withData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fireAllCommandsOnRunLoop:</span><span class="p">(</span><span class="n">CFRunLoopSourceRef</span><span class="p">)</span><span class="nv">runloop</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 这些是CFRunLoopRef 的回调函数</span>
</span><span class='line'><span class="cm">/** 调度函数 */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourceScheduleRoutine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">r1</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span><span class='line'><span class="cm">/** 处理函数 */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourcePerformRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
</span><span class='line'><span class="cm">/** 取消函数 */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourceCancelRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// RunLoopContext 是一个 在注册 input source 时使用的容器对象</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">YCRunLoopContext</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span><span class="p">;</span>
</span><span class='line'>    <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cm">/** 持有 runloop 和 source */</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithSource:</span><span class="p">(</span><span class="n">YCRunLoopSource</span><span class="o">*</span><span class="p">)</span><span class="nv">src</span> <span class="nf">andLoop:</span><span class="p">(</span><span class="n">CFRunLoopRef</span><span class="p">)</span><span class="nv">loop</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管 Objective-C 代码管理着 input source 的自定义数据。关联一个 input source 到一个具备 基于 C-语言 的回调函数的 runloop 。其中第一个函数是当你实际将 input source 添加到 runloop 中的时刻调用。流程将展示在 表 3-4 中。因为这个 input source 仅只有一个 客户机（主线程）。它使用调度者函数通过目标线程 application 的代理发送消息在目标线程注册自己。当 application 的代理和 input source 进行通信时 ,会使用 RunLoopContext 对象中的 <code>info</code> 信息来完成这个事。</p>

<p>表 3-4 调度 run loop source</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourceScheduleRoutine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">r1</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">){</span>
</span><span class='line'>    <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 这里的 Appdelegate 是主线程的代理   </span>
</span><span class='line'>    <span class="n">AppDelegate</span> <span class="o">*</span><span class="n">del</span> <span class="o">=</span> <span class="p">[</span><span class="n">AppDelegate</span> <span class="n">sharedAppDelegate</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 上下文对象中持有source自己</span>
</span><span class='line'>    <span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="n">theContext</span> <span class="o">=</span> <span class="p">[[</span><span class="n">YCRunLoopContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSource</span><span class="p">:</span><span class="n">obj</span> <span class="nl">andLoop</span><span class="p">:</span><span class="n">r1</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 通过代理去注册 Source 自己 </span>
</span><span class='line'>    <span class="p">[</span><span class="n">del</span> <span class="nl">performSelectorOnMainThread</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">registerSource</span><span class="p">:)</span> <span class="nl">withObject</span><span class="p">:</span><span class="n">theContext</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中最重要的回调例行程序是当你的 input source 被信号激活时处理自定义数据的部分。表3-5中展示了与 <code>RunLoopSource</code> 对象关联的执行者回调例行程$序,这个函数仅仅转发用来 <code>sourceFired</code> 方法工作的请求，该请求用来处理任何 <code>command buffer</code> （命令缓冲区）中存在的命令。</p>

<p>表3-5 input source 中的执行者</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourcePerformRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">RunLoopSource</span><span class="o">*</span>  <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">RunLoopSource</span><span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">obj</span> <span class="n">sourceFired</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你使用 <code>CFRunLoopSourceInvalidate</code> 函数将 input source 从 runloop 重移除。系统会调用你的 input source 中的取消者例行程序。你可以利用这个例行程序去通知客户机你的 input source 不再可用并且他们应该移除任何自己的相关的引用。表3-6 展示了取消者例行回调程序通过 RunLoopSource 对象进行注册。这个函数发送另一个 RunLoopContext 对象给 application 代理。但是这让代理去移除 runloop surce 的相关引用。</p>

<p>表3-6 销毁一个 input source</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourceCancelRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">RunLoopSource</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">RunLoopSource</span><span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
</span><span class='line'>    <span class="n">AppDelegate</span><span class="o">*</span> <span class="n">del</span> <span class="o">=</span> <span class="p">[</span><span class="n">AppDelegate</span> <span class="n">sharedAppDelegate</span><span class="p">];</span>
</span><span class='line'>    <span class="n">RunLoopContext</span><span class="o">*</span> <span class="n">theContext</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RunLoopContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSource</span><span class="p">:</span><span class="n">obj</span> <span class="nl">andLoop</span><span class="p">:</span><span class="n">rl</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">del</span> <span class="nl">performSelectorOnMainThread</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">removeSource</span><span class="p">:)</span>
</span><span class='line'>                                <span class="nl">withObject</span><span class="p">:</span><span class="n">theContext</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>
笔记：应用代理方法  registerSource: 和 removeSource 方法在下面的章节 《协调 input source 的客户机》展示
</code></p>

<h3>为 runloop 安装 input source</h3>

<p>表3-7 展示了 <code>RunLoopSource</code> 类的 <code>init</code> 方法 和 <code>addToCurrentRunLoop</code> 方法。<code>init</code> 方法创建了 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/c/tdef/CFRunLoopSourceRef">CFRunLoopSource</a> 不透明类型的必须关联到 runloop 的对象。它会传递 <code>RunLoopSource</code> 对象自己作为 山下文信息 以便于例行回调程序有一个指向对象的指针。input source 直到线程唤起 <code>addToCurrentRunLoop</code> 方法时才会执行安装，准确将在 RunLoopSourceScheduleRoutine 回调函数调用时。 一旦 input source 安装到 runloop 中，线程将会运行自己的 runloop 去等待 input source 发出事件。</p>

<p>表3-7 安装 run loop source</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 创建上下文容器，其中会连接自己的 info，retain info release info，还会关联三个例行程序。</span>
</span><span class='line'>    <span class="n">CFRunLoopSourceContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="nb">self</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">,</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RunLoopSourceScheduleRoutine</span><span class="p">,</span> <span class="n">RunLoopSourceCancelRoutine</span><span class="p">,</span> <span class="n">RunLoopSourcePerformRoutine</span><span class="p">};</span>
</span><span class='line'>    <span class="cm">/** 通过索引，上下文，和CFAllocator创建source */</span>
</span><span class='line'>    <span class="n">runLoopSource</span> <span class="o">=</span> <span class="n">CFRunLoopSourceCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>    <span class="n">commands</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span>  <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addToCurrentRunLoop</span><span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">runLoop</span><span class="p">,</span> <span class="n">runLoopSource</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>协调 input source 的客户机</h3>

<p>对于你的 input source 会非常有用，你需要操作它并且从其他线程向它提供消息。input source 的要点是将其添加到线程并睡眠直到有事情要做时才唤醒。事实上很有必要让其他线程了解 input surce 并且有方法可以和它交流（沟通数据）。</p>

<p>通知你的 input source 客户机的方法之一是发出注册请求 当你的 input source 第一次安装到你的 runloop 中时。你可以向你的 input source 注册尽可能多的客户机。或者你仅仅只是简单的用一些中央机构，然后将你的 input source 声明为感兴趣的客户端进行注册。表3-8 展示了  通过代理 和 调用唤起定义的 注册方法 当 RunLoopSource 对象的调度者函数被调用时。这个方法将会收到 RunLoopSource 提供的 RunLoopContext 对象并且将它添加到他的 source 列表中。这个表也会展示 当 input source 从 他的 runloop 中被移除时 用来注销的例行程序。
表 3-8 使用 application 的 代理 注销并且移除 input source</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="cp">#import &quot;YCRunLoopSource.h&quot;</span>
</span><span class='line'> <span class="cp">#import &quot;YCRunLoopContext.h&quot;</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">AppDelegate</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">sourcesToPing</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** 应该是一个单例 */</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">sharedAppDelegate</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerSource:</span><span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeSource:</span><span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">AppDelegate</span> <span class="o">*</span><span class="n">_instance</span><span class="p">;</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">AppDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">sharedAppDelegate</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">_instance</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_instance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerSource:</span><span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">sourcesToPing</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">context</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeSource:</span><span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">objToRemove</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="n">contextObj</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">sourcesToPing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">([</span><span class="n">contextObj</span> <span class="nl">isEqual</span><span class="p">:</span><span class="n">context</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">objToRemove</span> <span class="o">=</span> <span class="n">contextObj</span><span class="p">;</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">objToRemove</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">sourcesToPing</span> <span class="nl">removeObject</span><span class="p">:</span><span class="n">objToRemove</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sourcesToPing</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">_sourcesToPing</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_sourcesToPing</span> <span class="o">=</span> <span class="l">@[]</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_sourcesToPing</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Note：回调函数会在之前的表3-4和3-6中调用这些函数</code></p>

<h5>信号激活 input source</h5>

<p>释放 input source 的数据之后，客户机必须发信号给 source 并且唤醒它的 runloop。发信号给 source 是让 runloop 知道 source 已经准备好被处理。因为线程可能会在发信号的时处于睡眠状态，所以那你必须显式的让 run loop 保持唤醒。除非如此，不然在处理 input source 时会出现延迟。</p>

<p>表 3-9 展示了 <code>RunLoopSource</code> 对象的 <code>fireCommandsOnRunLoop</code> 方法，客户机会在它准备好为 source 处理添加到 buffer 缓冲区中的 command 命令时调用这个方法。</p>

<p>表 3-9 唤醒 run loop</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fireCommandsOnRunLoop:</span><span class="p">(</span><span class="n">CFRunLoopRef</span><span class="p">)</span><span class="nv">runloop</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CFRunLoopSourceSignal</span><span class="p">(</span><span class="n">runLoopSource</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CFRunLoopWakeUp</span><span class="p">(</span><span class="n">runloop</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Note:你不能通过向一个自定义 input source 发信息来处理一个 SIGHUP 或者其他处理类型的信号</code>，Core Foundation 框架中用于唤醒 runloop 的函数不是信号安全的。并且不能作为你的应用程序中内置信号处理的例行程序使用。关于更多的关于信号处理程序，详见 <a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man2/sigaction.2.html#//apple_ref/doc/man/2/sigaction">sigaction</a> man 页面。</p>

<h3>配置 Timer Source</h3>

<p>为了创建 timer source，所有你需要做的就是创建一个 timer 对象，并且在你的 run loop 中调度它。在 Cocoa 中，你使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/cl/NSTimer">NSTimer</a> 类来创建一个新的 timer 对象。在 Core Foundation 框架中，你可以使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/c/tdef/CFRunLoopTimerRef]">CFRunLoopTimerRef</a> 不透明类型来创建。<code>NSTimer</code> 类只是 Core Foundation 框架中的一个扩展，是用来方便的提供一些功能，比如使用相同的方法创建和调度 timer 。
在 Cocoa 中，你能通过以下两种类方法创建和调度 timer。<br/>
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</a>
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:">scheduledTimerWithTimeInterval:invocation:repeats:</a></p>

<p>这些方法创建 timer 并且将它们添加到当前线程的 run loop 中的 default mode(<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode">NSDefaultRunLoopMode</a>) 中去。如果你使用的是 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/cl/NSTimer">NSTimer</a> 对象，那就可以手动调度 timer 并且可以使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/instm/NSRunLoop/addTimer:forMode:">addTimer:forMode:</a> 手动将它添加到 runloop 中去。这两种技术都是基于同一种，但是通过timer 的配置给你不同级别的控制。比如你手动创建 timer 并将它添加到 run loop 中，并添加到除 default mode 之外的其他 mode 中去。表3-10 展示了如何使用两种技术创建 timer。第一个 timer 初始化为 延迟一秒但是会在延迟后有规律的每个0.1秒触发一次。第二个 timer 会在 0.2 秒延迟后开始触发，并且在延迟结束后 每 0.2 秒触发一次。</p>

<p>表3-10 使用 NSTimer 创建和调度 timer</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSRunLoop</span><span class="o">*</span> <span class="n">myRunLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建并调度第一个 timer</span>
</span><span class='line'><span class="bp">NSDate</span><span class="o">*</span> <span class="n">futureDate</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="nl">dateWithTimeIntervalSinceNow</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSTimer</span><span class="o">*</span> <span class="n">myTimer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSTimer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFireDate</span><span class="p">:</span><span class="n">futureDate</span>
</span><span class='line'>                        <span class="nl">interval</span><span class="p">:</span><span class="mf">0.1</span>
</span><span class='line'>                        <span class="nl">target</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'>                        <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myDoFireTimer1</span><span class="p">:)</span>
</span><span class='line'>                        <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                        <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">myRunLoop</span> <span class="nl">addTimer</span><span class="p">:</span><span class="n">myTimer</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建并调动第二个 timer</span>
</span><span class='line'><span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">0.2</span>
</span><span class='line'>                        <span class="nl">target</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'>                        <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myDoFireTimer2</span><span class="p">:)</span>
</span><span class='line'>                        <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                        <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>表3-11 展示了使用 Core Foundation 框架时需要配置的代码。尽管实例代码中没有传递任何用户自定义的信息的上下文结构，但是你可以使>用这个结构去传递任何你的 timer 所需要自定义数据。关于更多该结构的内容可以浏览 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/doc/uid/20001444">CFRunLoopTimer 参考</a>。</p>

<p>表 3-11 使用 Core Foundation 框架创建和调度一个 timer</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopRef</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
</span><span class='line'><span class="n">CFRunLoopTimerContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'><span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">CFRunLoopTimerCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                                        <span class="o">&amp;</span><span class="n">myCFTimerCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFRunLoopAddTimer</span><span class="p">(</span><span class="n">runLoop</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">kCFRunLoopCommonModes</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>配置一个基于 port 的 input source</h3>

<p>Cocoa 和 Core Foundation 都支持用于和线程间或者进程间通信的基于 端口的对象。接下来的章节将会向你展示如何使用一些不同类型的 port 构建 port 通信。</p>

<h3>配置一个NSMachPort Object</h3>

<p>使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMachPort_Class/index.html#//apple_ref/occ/cl/NSMachPort">NSMachPort</a> 对象创建一个本地连接。你创建一个 port 对象并把它添加到你的主线程 run loop 中去。当启动你的子线程时，你要传一些相同的对象到你的线程入口点函数中去。子线程可以使用相同的对象发送信息回到你的主线程中去。</p>

<h3>实现主线程代码</h3>

<p><a href="#list3-12">表 3-12</a> 中展示了用于启动子工作线程的主线程代码。因为 Cocoa 框架执行很多介入步骤用于配置 port 和 run loop ，Cocoa 的 <code>launchThread</code> 方法相比于 Core Foundation 的等价功能<a href="#list3-17">表 3-17</a>更加简洁明了。尽管如此，这两个框架在这一模块的功能表现基本都是相同的。其中一个存在的差异是与发送本地 port 到工作线程的方式不同，这个方法是直接发送 NSPort 对象的。</p>

<p><strong>表 3-12</strong> list3-12 Main Thread lauch method</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">launchThread</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSPort</span> <span class="o">*</span><span class="n">myPort</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMachPort</span> <span class="n">port</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">myPort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 这个类处理即将过来的 port 信息</span>
</span><span class='line'>        <span class="p">[</span><span class="n">myPort</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 将此端口作为 input source 安装到当前 run loop 中去</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addPort</span><span class="p">:</span><span class="n">myPort</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 开启工作子线程，让工作子线程去释放 port</span>
</span><span class='line'>        <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">detachNewThreadSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">LaunchThreadWithPort</span><span class="p">:)</span> <span class="nl">toTarget</span><span class="p">:[</span><span class="n">MyWorkerClass</span> <span class="k">class</span><span class="p">]</span> <span class="nl">withObject</span><span class="p">:</span><span class="n">myPort</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了设置为线程间双向通信信
道，在
登记信息中，你需要让工作线程发送自己的本地 port 到主线程。接收登记信息是为了让你的主线程知道开动子线程的过程进行的非常顺利，同时也为我们为提供了一种方法去向该线程发送更多信息。</p>

<p>表 3-13 展示了用于主线程的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSPortDelegate_Protocol/index.html#//apple_ref/occ/intfm/NSPortDelegate/handlePortMessage:">handlePortMessage:</a>方法，这个方法会在线程到达自己的本地 port 时进行调用。当登记信息(check-in message)到达时，该方法将直接从 port 信息中检索子线程的 port 并保存以备后用。</p>

<p><strong>表 3-13</strong>    <span id = "listing 3-13">处理 Mach port 信息</span></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp"># define kCheckinMessage 100</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 处理工作线程的响应的代理方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePortMessage:</span><span class="p">(</span><span class="n">NSPortMessage</span> <span class="o">*</span><span class="p">)</span><span class="nv">portMessage</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">message</span> <span class="o">=</span> <span class="p">[</span><span class="n">portMessage</span> <span class="n">msgid</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 定义远程端口</span>
</span><span class='line'>    <span class="bp">NSPort</span> <span class="o">*</span><span class="n">distantPort</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="o">==</span> <span class="n">kCheckinMessage</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 获取工作线程的通信 port</span>
</span><span class='line'>        <span class="n">distantPort</span> <span class="o">=</span> <span class="p">[</span><span class="n">portMessage</span> <span class="n">sendPort</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 引用计数+1 并 保存工作端口以备后用</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">storeDistantPort</span><span class="p">:</span><span class="n">distantPort</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 处理其他信息</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">storeDistantPort:</span><span class="p">(</span><span class="bp">NSPort</span> <span class="o">*</span><span class="p">)</span><span class="nv">port</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 保存远程端口</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>实现子线程代码</h4>

<p>对于工作子线程，你必须配置它并且是使用指定的端口进行信息沟通并返回到主线程。</p>

<p>表 3-14 展示了用于设置工作线程的代码。在创建一个 qutorealease  pool 之后，该方法会创建一个工作对象去驱动线程执行。该工作对象 的 <code>sendCheckinMessage:</code> 方法（表3-15 所示）为工作线程创建一个本地端口然后回复一个 check-in 信息给主线程。
表 3-14 <span id = "liting3-14"> 使用 Mach port 启动子线程 </span></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+(</span><span class="kt">void</span><span class="p">)</span><span class="nf">LaunchThreadWithPort:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">inData</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSAutoreleasePool</span><span class="o">*</span>  <span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置本线程与主线程的连接 </span>
</span><span class='line'>    <span class="bp">NSPort</span><span class="o">*</span> <span class="n">distantPort</span> <span class="o">=</span> <span class="p">(</span><span class="bp">NSPort</span><span class="o">*</span><span class="p">)</span><span class="n">inData</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">MyWorkerClass</span><span class="o">*</span>  <span class="n">workerObj</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">workerObj</span> <span class="nl">sendCheckinMessage</span><span class="p">:</span><span class="n">distantPort</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">distantPort</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 让 run loop 处理这些逻辑 </span>
</span><span class='line'>    <span class="k">do</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">runMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span>
</span><span class='line'>                            <span class="nl">beforeDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">distantFuture</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">workerObj</span> <span class="n">shouldExit</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">workerObj</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pool</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当使用 <code>NSMachPort</code> 时,本地和远端线程都可以使用相同的 port 对象 完成线程之间的单工通信（单向通信）。换句话说，通过一个线程创建的本地对象会成为另一个线程的远端 port 对象。（ps：现在总算明白本地就是当前线程环境，远端就是其他线程环境）。</p>

<p>表 3-15展示了子线程的 check-in 例行程序 （登记信息例行程序）。这个方法设置了他自己的用于和以后进行通讯的本地端口。并且回复一个 check-in 登记信息给主线程。该方法使用 port 对象去接收 <code>LaunchThreadWithport:</code> 方法作为信息目标。</p>

<p>表 3-15 使用 Mach port 发送 check-in 登记信息</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Worker thread check-in method</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendCheckinMessage:</span><span class="p">(</span><span class="bp">NSPort</span><span class="o">*</span><span class="p">)</span><span class="nv">outPort</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 保留（retain）并保存远端的 port 以备后用</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">setRemotePort</span><span class="p">:</span><span class="n">outPort</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建和配置工作线程的端口（ps：当前线程端口） </span>
</span><span class='line'>    <span class="bp">NSPort</span><span class="o">*</span> <span class="n">myPort</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMachPort</span> <span class="n">port</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">myPort</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addPort</span><span class="p">:</span><span class="n">myPort</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建 check-in 登记信息</span>
</span><span class='line'>    <span class="n">NSPortMessage</span><span class="o">*</span> <span class="n">messageObj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSPortMessage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSendPort</span><span class="p">:</span><span class="n">outPort</span>
</span><span class='line'>                                         <span class="nl">receivePort</span><span class="p">:</span><span class="n">myPort</span> <span class="nl">components</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">messageObj</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 完成配置信息 并 立即发送出去</span>
</span><span class='line'>        <span class="p">[</span><span class="n">messageObj</span> <span class="nl">setMsgId</span><span class="p">:</span><span class="nl">setMsgid</span><span class="p">:</span><span class="n">kCheckinMessage</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">messageObj</span> <span class="nl">sendBeforeDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>配置一个 NSMessagePort 对象</h4>

<p>如果想要使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSM%20%20%20%20essagePort_Class/index.html#//apple_ref/occ/cl/NSMessagePort">NSMessagePort</a> 对象创建一个本地连接，你不能在线程间仅仅值传递一个 port 对>    象。远端信息端口必须通过名字获取。
在Cocoa中，如果你想实现这个功能，需要使用一个指定的名字去注册你的本地端口，然后向远端线程传递注册的名字以便于他可以包含一
    个合适的端口对象用于交流。表 3-16 展示了 port 创建方法和注册方法 用于你想要使用 消息端口（message port）的地方。</p>

<p>表 3-16 注册一个 message port</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSPort</span><span class="o">*</span> <span class="n">localPort</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMessagePort</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 配置对象并将它添加到当前 run loop 中去</span>
</span><span class='line'><span class="p">[</span><span class="n">localPort</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addPort</span><span class="p">:</span><span class="n">localPort</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用指定的名字注册端口。名字必须唯一。</span>
</span><span class='line'><span class="bp">NSString</span><span class="o">*</span> <span class="n">localPortName</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;MyPortName&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">NSMessagePortNameServer</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">registerPort</span><span class="p">:</span><span class="n">localPort</span>
</span><span class='line'><span class="nl">name</span><span class="p">:</span><span class="n">localPortName</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>在 Core Foundation 框架中配置一个基于端口的（Port-Based） input source</h4>

<p>这个小结描述了如歌使用 Core Foundation 框架在你的应用的主线程和辅助线程（worker thread）中创建一个双向通信信道。</p>

<p>如表3-17 所示为应用主线程启动辅助线程所使用的代码。首先要做的是创建 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessagePortRef/index.html#//apple_ref/c/tdef/CFMessagePortRef">CFMessagePortRef</a> 不透明对象去监听从辅助线程发来的消息。辅助线程需要用来创建连接的端口名，以便于字符串值可以被发送到辅助线程的入口点函数。端口名在当前用户的上线文中通常必须是唯一的。否则，可能会出现运行冲突。</p>

<p>表 3-17 给新线程关联一个 Core Foundation message port</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define kThreadStackSize        (8 *4096)</span>
</span><span class='line'>
</span><span class='line'><span class="n">OSStatus</span> <span class="nf">MySpawnThread</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 创建一个本地端口用于接受响应</span>
</span><span class='line'>    <span class="n">CFStringRef</span> <span class="n">myPortName</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFMessagePortRef</span> <span class="n">myPort</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFRunLoopSourceRef</span> <span class="n">rlSource</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFMessagePortContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'>    <span class="kt">Boolean</span> <span class="n">shouldFreeInfo</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 用端口名 创建一个符合规范的字符串</span>
</span><span class='line'>    <span class="n">myPortName</span> <span class="o">=</span> <span class="n">CFStringCreateWithFormat</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;com.myapp.MainThread&quot;</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建端口</span>
</span><span class='line'>    <span class="n">myPort</span> <span class="o">=</span> <span class="n">CFMessagePortCreateLocal</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                <span class="n">myPortName</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">MainThreadResponseHandler</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">shouldFreeInfo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">myPort</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 端口已经被成功创建</span>
</span><span class='line'>        <span class="c1">// 现在为他创建 run loop source</span>
</span><span class='line'>        <span class="n">rlSource</span> <span class="o">=</span> <span class="n">CFMessagePortCreateRunLoopSource</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">myPort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">rlSource</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 为当前 run loop 添加 source</span>
</span><span class='line'>            <span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">rlSource</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 一旦安装结束，这些资源需要被释放</span>
</span><span class='line'>            <span class="n">CFRelease</span><span class="p">(</span><span class="n">myPort</span><span class="p">);</span>
</span><span class='line'>            <span class="n">CFRelease</span><span class="p">(</span><span class="n">rlSource</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建线程并且继续处理任务</span>
</span><span class='line'>    <span class="n">MPTaskID</span>        <span class="n">taskID</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span><span class="p">(</span><span class="n">MPCreateTask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ServerThreadEntryPoint</span><span class="p">,</span>
</span><span class='line'>                    <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">myPortName</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">kThreadStackSize</span><span class="p">,</span>
</span><span class='line'>                    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                    <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                    <span class="o">&amp;</span><span class="n">taskID</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果 port 端口已经被安装并且线程已经启动，主线程就可以继续定期的执行去等待辅助线程的 check-in 登记信息。一旦 check-in 登记信息到达，它将会被指派到主线程的 <code>MainThreadResponseHandler</code> 函数中，如表 3-18 所示，这个函数提取辅助线程的端口名并且创建通信管道。</p>

<p>表 3-18 接收 check-in 登记信息</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define kCheckinMessage 100</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 主线程端口信息处理函数</span>
</span><span class='line'><span class="n">CFDataRef</span> <span class="nf">MainThreadResponseHandler</span><span class="p">(</span><span class="n">CFMessagePortRef</span> <span class="n">local</span><span class="p">,</span>
</span><span class='line'>                    <span class="kt">SInt32</span> <span class="n">msgid</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">CFDataRef</span> <span class="n">data</span><span class="p">,</span>
</span><span class='line'>                    <span class="kt">void</span><span class="o">*</span> <span class="n">info</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">msgid</span> <span class="o">==</span> <span class="n">kCheckinMessage</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">CFMessagePortRef</span> <span class="n">messagePort</span><span class="p">;</span>
</span><span class='line'>        <span class="n">CFStringRef</span> <span class="n">threadPortName</span><span class="p">;</span>
</span><span class='line'>        <span class="n">CFIndex</span> <span class="n">bufferLength</span> <span class="o">=</span> <span class="n">CFDataGetLength</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">UInt8</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">CFAllocatorAllocate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bufferLength</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CFDataGetBytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bufferLength</span><span class="p">),</span> <span class="n">buffer</span><span class="p">);</span>
</span><span class='line'>        <span class="n">threadPortName</span> <span class="o">=</span> <span class="n">CFStringCreateWithBytes</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bufferLength</span><span class="p">,</span> <span class="n">kCFStringEncodingASCII</span><span class="p">,</span> <span class="nb">FALSE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 你必须通过一个 port 名获取远端信息</span>
</span><span class='line'>        <span class="n">messagePort</span> <span class="o">=</span> <span class="n">CFMessagePortCreateRemote</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">threadPortName</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">messagePort</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 保留并保存线程的 comm 端口 以备后用</span>
</span><span class='line'>            <span class="n">AddPortToListOfActiveThreads</span><span class="p">(</span><span class="n">messagePort</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 如果端口在先前的 函数 中保留了（retain），在这里释放资源</span>
</span><span class='line'>            <span class="n">CFRelease</span><span class="p">(</span><span class="n">messagePort</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 释放资源</span>
</span><span class='line'>        <span class="n">CFRelease</span><span class="p">(</span><span class="n">threadPortName</span><span class="p">);</span>
</span><span class='line'>        <span class="n">CFAllocatorDeallocate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 处理其他信息</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>主线程配置完成后，唯一要做的就是为新创建的辅助线程创建它自己的 端口和 登记自己的 message。表 3-19 所示为辅助线程的入口点函数。函数提取了主线程的 port 名并且用它创建了一个远端的连接回复主线程。之后函数为自己创建一个本地端口，将端口 port 安装到线程的 runloop 中去，然后给主线程发送一个包含本地端口名的 check-in 登记信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">OSStatus</span> <span class="nf">ServerThreadEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 创建连接到主线程的远端端口</span>
</span><span class='line'>    <span class="n">CFMessagePortRef</span> <span class="n">mainThreadPort</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFStringRef</span> <span class="n">portName</span> <span class="o">=</span> <span class="p">(</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">param</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mainThreadPort</span> <span class="o">=</span> <span class="n">CFMessagePortCreateRemote</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">portName</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 释放被用于参数传递的字符串</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">portName</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 为辅助才女创建一个本地端口</span>
</span><span class='line'>    <span class="n">CFStringRef</span> <span class="n">myPortName</span> <span class="o">=</span> <span class="n">CFStringCreateWithFormat</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;com.MyApp.Thread-%d&quot;</span><span class="p">),</span> <span class="n">MPCurrentTaskID</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 保存线程上下文信息中的端口，以便之后使用。</span>
</span><span class='line'>    <span class="n">CFMessagePortContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">mainThreadPort</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'>    <span class="kt">Boolean</span> <span class="n">shouldFreeInfo</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">Boolean</span> <span class="n">shouldAbort</span> <span class="o">=</span> <span class="nb">TRUE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CFMessagePortRef</span> <span class="n">myPort</span> <span class="o">=</span> <span class="n">CFMessagePortCreateLocal</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                <span class="n">myPortName</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">ProcessClientRequest</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">shouldFreeInfo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">shouldFreeInfo</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 如果不能创建本地端口，则杀死线程</span>
</span><span class='line'>        <span class="n">MPExit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CFRunLoopSourceRef</span> <span class="n">rlSource</span> <span class="o">=</span> <span class="n">CFMessagePortCreateRunLoopSource</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">myPort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rlSource</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 如果不能创建本地端口，则杀死线程</span>
</span><span class='line'>        <span class="n">MPExit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 给 runloop 添加source</span>
</span><span class='line'>    <span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">rlSource</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 一旦线程安装完毕，这些资源需要释放</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">myPort</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">rlSource</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 打包端口名，并发送 check-in 信息。</span>
</span><span class='line'>    <span class="n">CFDataRef</span> <span class="n">returnData</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFDataRef</span> <span class="n">outData</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFIndex</span> <span class="n">stringLength</span> <span class="o">=</span> <span class="n">CFStringGetLength</span><span class="p">(</span><span class="n">myPortName</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">UInt8</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">CFAllocatorAllocate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">stringLength</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CFStringGetBytes</span><span class="p">(</span><span class="n">myPortName</span><span class="p">,</span>
</span><span class='line'>                <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">stringLength</span><span class="p">),</span>
</span><span class='line'>                <span class="n">kCFStringEncodingASCII</span><span class="p">,</span>
</span><span class='line'>                <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                <span class="nb">FALSE</span><span class="p">,</span>
</span><span class='line'>                <span class="n">buffer</span><span class="p">,</span>
</span><span class='line'>                <span class="n">stringLength</span><span class="p">,</span>
</span><span class='line'>                <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">outData</span> <span class="o">=</span> <span class="n">CFDataCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">stringLength</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CFMessagePortSendRequest</span><span class="p">(</span><span class="n">mainThreadPort</span><span class="p">,</span> <span class="n">kCheckinMessage</span><span class="p">,</span> <span class="n">outData</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 清除线程数据结构</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">outData</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CFAllocatorDeallocate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 进入 runloop</span>
</span><span class='line'>    <span class="n">CFRunLoopRun</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一旦进入 runloop，所有发送给线程端口的事件会被 <code>ProcessClientRequest</code> 函数处理。该函数的实现依赖于工作线程的类型，这里暂不做介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（四）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/08/runloopshen-du-tan-jiu-(4)/"/>
    <updated>2016-01-08T18:45:07+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/08/runloopshen-du-tan-jiu-(4)</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Run Loops</a></p>

<p>Run loops 是与线程相关联的基础设施的一部分。Run loop 是用来调度工作并且协调传入事件的时间处理循环。run loop 的目的是：让你的线程在有工作的任务的事后保持忙碌，并且在空闲的事后使线程保持休眠。</p>

<!--more-->


<p>Run loop 的管理并不是完全自动的，你仍然需要设计你的线程代码，并利用这些代码在合适的时机开启 run loop 并且相应传入的事件。Cocoa 和 Core Foundation 框架都提供了run loop 对象，以便于帮助你配置和管理你的线程 run loop。你的应用不需要显式的创建这些 run loop 对象。每条线程，包括应用的主线程，都会配有一个相关联的 run loop 对象。只有子线程们需要显式的（手动）运行它们的 run loop。然而，该 app 框架将会自动设置并且运行作为应用程序启动过程的一部分的处于 main thread （主线程）的 run loop。</p>

<p>接下来，我们一起看看关于 run loop 以及它们的配置相关的更多信息。参照<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/uid/TP40003725">NSRunLoop Class Reference</a> 以及 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/doc/uid/20001441-CH1g-112707">CFRunLoop Reference</a>。</p>

<h3>Run Loop 剖析</h3>

<p>run loop 是一个名副其实的循环。他会是你的线程不停地循环工作，具体包括线程的进入并且用来响应输入源所运行的事件处理程序。你的代码提供的控制状态将会被用来实现run loop具体的循环部分。换句话说，你的代码需要提供 while 或 for 循环来驱动你的 run loop。在你的 run loop 中，你使用一个 run loop 对象去“执行”接收事件的事件处理代码和调用已经安装好的 handlers。</p>

<p>run loop 通过两种不同类型的 source 来接收事件。Input source 传递异步事件，通常包括从其他线程或者其他应用发来的 message 。Timer source 也传递异步事件，通常发生在一个被安排好的时间或者重复的时间间隔。这两种类型的 source 都会使用 application-specific 处理例程来处理到来的事件。</p>

<p>插图3-1展示了 run loop 各种 source 的概念结构。input source 传递异步事件到相对应的 handler（处理程序）并且引起 <code>runUtilDate:</code> 方法（调用线程相关的 NSRunLoop 对象）退出。</p>

<p><em>插图3-1 run loop 和它的 source 结构</em>
<img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="插图3-1" /></p>

<p>除了处理 input source，run loop 同样也会生成一些关于 run loop 的行为的通知。注册 run-loop observers（观察者）去接收这些通知并且使用他们去在线程上做额外的处理。你可以使用 Core Foundation 框架去在你的线程上安装 run-loop observer 。</p>

<p>下面这些段落提供了更多地关于 runloop的组成 和 它们可以操作的modes，它们还描述了在事件处理的不同时间点生成的通知。</p>

<h3>Run Loop Modes</h3>

<p>一个 run loop mode 是一个包含 input sources 和 被监视的 timers 和 将要被通知的 run-loop 的observer 所组成的集合。每次你启动你的 run loop 时，你都会指定（隐式或者显式的）一种特定的“mode”来运行。在执行该运行循环的期间，只有与指定运行的 mode 相关联的 source 才会被检测和允许去发送他们的事件。（相同的，只有与指定运行的 mode 相关联的 observer 会被 run loop 的进度（progress）所通知）。关联到其他 modes 的 sources 直到 run loop 切换到对应的 mode 时才会继续让新的事件通行（只有到对应的mode下，相关的 source 才会继续其对应的功能）。</p>

<p>在你的代码中，可以使用名字来标记 modes，包括 Cocoa 和 Core Foundation 都定义了一些默认的mode和一些常用的mode，代码中你可以通过字符串来区别这些mode，你可以定义自定义的mode，仅仅通过指定简单的字符串来标记这些自定义的mode。尽管可以随意的对 mode 名字进行复制，但是这些 mode 的内容却不行。你必须确保你添加到得任何你创建的 mode 中的一个或多个input sources, timers, 或者 run-loop observer都是有用的。</p>

<p>你使用 modes 并通过你的 run loop 特定的扫描中过滤掉干扰的事件。大多数情况下，你都会将你的 run loop 运行在系统默认的 mode 中。模态面板可能会运行在“ modal ” mode 中。当处于这种 mode 下，只有和 source 关联的模态面板才可以发送事件到线程中去。对于子线程来说，你可能会使用自定义 modes 去防止优先级抵的 source 在时间要求严格的操作中发送事件。</br>
<code>
Note: modes 的区别取决于 event（事件） 的 source ，不是 event 的类型。比如，你可能不会用 mode 去仅仅匹配一个鼠标点击事件或者键盘点击事件。 你可能会用 mode 去监听一组不同的端口。暂停 timer ，或者改变当前监视的 source ，然后，run loop observer 会立即开始监视。
</code>
</br>
列表3-1列出了 Cocoa 和 Core Foundation 框架中你可以使用的具有官方文档描述的一些标准的 mode，列名称列出了你在代码中需要指定 mode 时需要使用的实际常量。</p>

<h4><strong>Table 3-1</strong> <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW18">预定义的 run loop modes</a></h4>

<!--
| Mode | Name |Description|
| :------ | :------ | :------ |
| Default | [NSDefaultRunLoopMode](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode) (Cocoa)</br>[kCFRunLoopDefaultMode](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopDefaultMode) (Core Foundation) | Default Mode 是用的最多的 mode 操作。在大多数情况下，你应该使用此模式启动 Run Loop 和配置您的 input source。 |
|Connection|`NSConnectionReplyMode`(Cocoa)|Cocoa 使用这个 mode 来 `NSConnection` 对象共同监视 replies （回复响应），你一般不需要自己使用该 mode |
|Modal|`NSModalPanelRunLoopMode`(Cocoa)|Cocoa 使用这个 mode 来标记确认用于 modal panel（面板、控制器）的事件|
|Event tracking|`NSEventTrackingRunLoopMode`(Cocoa)|Cocoa 使用这个 mode 来约束鼠标拖动循环和其他类型的用户界面跟踪循环的输入事件|
|Common modes |[NSRunLoopCommonModes](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSRunLoopCommonModes)(Cocoa)</br>[kCFRunLoopCommonModes](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopCommonModes) (Core Foundation)|这是一个 common mode 的可配置组，用该 mode 关联的某个 input source 同时也被组中的这些 mode 所关联。对于 Cocoa 的应用，这一套包括 default modal， 和 默认的 event tracking 这些 mode。Core Foundation 只包括开始的 default mode。你可以使用[CFRunLoopAddCommonMode](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddCommonMode) function（函数）来添加自定义的 mode 到 mode 组中。|-->




<!--内嵌官方HTML-->


<hr />

<div class="tableholder"><table class="graybox" border="0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number"><!--Table 3-1--></strong>&nbsp;&nbsp;<!--Predefined run loop modes--></br></br></caption><tbody><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Mode</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Name</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr>
<tr><td scope="row"><p>Default</p></td><td><p><code><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoo_4&quot;;return this.s_oc?this.s_oc(e):true">NSDefaultRunLoopMode</a></code> (Cocoa)</p><p><code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopDefaultMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_2&quot;;return this.s_oc?this.s_oc(e):true">kCFRunLoopDefaultMode</a></code> (Core Foundation)</p></td><td><p> Default Mode 是用的最多的 mode 操作。在大多数情况下，你应该使用此模式启动 Run Loop 和配置您的 input source。 </p></td></tr><tr><td scope="row"><p>Connection</p></td><td><p><code><!--a target="_self" -->NSConnectionReplyMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 和<code><!--a target="_self" -->NSConnection<!--/a--></code>  对象共同监视 replies （回复响应），你一般不需要自己使用该 mode 
</p></td></tr><tr><td scope="row"><p>Modal</p></td><td><p><code><!--a target="_self" -->NSModalPanelRunLoopMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 来标记确认用于 modal panel（面板、控制器）的事件</p></td></tr><tr><td scope="row"><p>Event tracking</p></td><td><p><code><!--a target="_self" -->NSEventTrackingRunLoopMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 来约束鼠标拖动循环和其他类型的用户界面跟踪循环的输入事件 </p></td></tr><tr><td scope="row"><p>Common modes</p></td><td><p><code><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSRunLoopCommonModes" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoo_5&quot;;return this.s_oc?this.s_oc(e):true">NSRunLoopCommonModes</a></code> (Cocoa)</p><p><code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopCommonModes" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_3&quot;;return this.s_oc?this.s_oc(e):true">kCFRunLoopCommonModes</a></code> (Core Foundation)</p></td><td><p>这是一个 common mode 的可配置组，用 mode 关联的某个 input source 同时也被组中的这些 mode 所关联。对于 Cocoa 的应用，这一套包括 default modal， 和 默认的 event tracking 这些 mode。Core Foundation 只包括 开始的 default mode。你可以使用 <code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddCommonMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_4&quot;;return this.s_oc?this.s_oc(e):true">CFRunLoopAddCommonMode</a></code> function 来添加自定义的 mode 到 mode 组中。</p></td></tr></tbody></table></div>


<hr />

<!--内嵌官方HTML-->


<h3>Input Sources</h3>

<p>input source 异步传递事件到你的线程中。event 的source 取决于 input source 的类型，通常是两个类型中的一个。<code>基于 port 的 input source</code> 监视着你的应用中的 Mach Port 。<code>自定义的 input source</code> 监视着你的自定义的事件 source 。至于你的run loop 来讲，他不应该在是否是基于 port 的 input source 还是 自定义 input source 出现问题。系统通常会实现这两种全部允许程序员自己使用类型的 input source 。这两种 source 之间唯一的不同在于它们是如何被发送信号的。基于 port 的 source 可以通过 kernel 内核接收发送的信号，而自定义的 source 必须手动从另一个线程发送信号过来。</p>

<p>当你创建一个 input source 时，你可以给它分配一个或多个你的 run loop 的 mode 。受 mode 影响的 input source 会在任何给定的时刻受到监视，在大多数情况下，你的 run loop 会运行在 default mode 下，但是你也可以自己指派自定义的mode给它。如果一个 input source 没有处于当前受监视的 mode 下，那么任何它产生的事件都会被挂起，除非你的 run loop 在正确的 mode 下运行（就是让你的 run loop 以你需要监视的 input source 所属的 mode 开始运行，这样 run loop 才能监视到你的 input source 产生的事件）。</p>

<p>下面介绍一些 input source 。。。</p>

<h4>基于 port 的 source</h4>

<p>Cocoa 和 Core Foundation 框架都提供了内置的支持&ndash;使用 port 相关的对象和函数来创建基于 port 的input source。例如，在 Cocoa 中，你根本不用自己直接创建一个 input source，你只需要创建一个 port 对象，并使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSPort_Class/index.html#//apple_ref/occ/cl/NSPort">NSPort</a> 的方法去将 port 添加到 run loop 中去。port 对象会为你处理好创建和配置一个你需要的 input source 这些底层的事情。</p>

<p>在 Core Foundation 中， 你必须手动的两者都创建，其中包括 port 和 它的 run loop source ，在两种情况下， 你可以使用 port 不透明类型的 (<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMachPortRef/index.html#//apple_ref/c/tdef/CFMachPortRef">CFMachPortRef</a>, <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessagePortRef/index.html#//apple_ref/c/tdef/CFMessagePortRef">CFMessagePortRef</a>, or <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/tdef/CFSocketRef">CFSocketRef</a>) 相关的函数来创建合适的对象（you use the functions associated with the port opaque type (CFMachPortRef, CFMessagePortRef, or CFSocketRef) to create the appropriate objects）。</p>

<p>如何创建和配置自定义的基于 port 的源，可以参照<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281">创建一个基于 port 的 input source</a>
</br>
</br></p>

<h4>自定义 input source</h4>

<p>为了自定义一个 input source，你必须使用 Core Foundation 框架中 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/c/tdef/CFRunLoopSourceRef">CFRunLoopSourceRef</a>的不透明类型相关联的函数。你可以使用多个回调函数来配置你的自定义 input source ，Core Foundation 框架会配置你的  source 在不同的点去调用这些函数，处理将要发生的事件，并在 source 被移出 run loop 的时候销毁 source。</p>

<p>除了定义在事件到来时自定义 source 的行为，你还必须定义事件传递机制。source 的这部分运行在一个单独的线程中，并且负责 当数据已经准备好去被处理的时候，这部分会去提供一个拥有数据的 input source，并且发信号给 input source。这个事件传递机制取决于你，但是也不用过于复杂。</p>

<p>有关如何创建一个自定义 input source 的例子，可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3">定义一个自定义 input source</a>， 关于自定义 input source 的详细信息， 可以参考 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/doc/uid/20001443">CFRunLoopSourceReference</a></p>

<h3>Run Loop 的时间执行次序</h3>

<p>每一次你运行 run loop 时，你的线程的 run loop 都会处理未完成的事件，并且为已经注册的任何观察者生成通知信息。下面是它执行的具体步骤：</p>

<ol>
<li>通知观察者 runloop 已经进入。</li>
<li>通知观察者 任何就绪的 timer 即将触发。</li>
<li>通知观察者 任何 不是基于端口的 input source （source0）即将触发</li>
<li>触发任何不是基于端口的并且准备就绪的 input source。</li>
<li>假如存在已经准备好的基于端口的 input source （source1），将会等待被触发。并立即开始处理事件。跳转至步骤 9 。</li>
<li>通知观察者 线程即将睡眠。</li>
<li>设置让线程在符合如下条件之一时从睡眠状态唤醒：

<ul>
<li>一个基于端口的 input source（source1）产生的事件到来。</li>
<li>timer 触发了。</li>
<li>超出 runloop 预定的时间。</li>
<li>run loop 明确唤醒</li>
</ul>
</li>
<li>通知观察者，线程刚刚唤醒。</li>
<li>处理剩余的事件：

<ul>
<li>  如果一个用户定义的 timer 触发，处理 timer 的事件并且重启 ru loop ，跳转值步骤 2 。</li>
<li>如果一个 input source 触发，传递这个事件。</li>
<li>run loop 已经明确地被唤醒但是还没有超时。重启 run loop，并且跳转至 第二步。</li>
</ul>
</li>
<li>通知观察者，run loop 已经退出。
因为 timer 和 input source 发出的 observer 通知是在这些事件确实是发生时被发送的，那么在事件发生的时间和 observer 收到的通知的时间会存在时间间隙。如果对事件发生时间的准确性要求非常严格，那么你需要采取 <code>睡眠</code> 和 <code>唤醒睡眠</code> 的通知方式来帮助你纠正事件实际发生的时间。</li>
</ol>


<p>由于定时器等周期性事件是在 run loop 运行的时候发送的，需要避免在发送这些事件时被打断。典型的例子比如：只要进入运行循环，并且反复实时地从应用中请求事件来实现对鼠标跟踪的常规动作。由于你的代码是直接抓取事件的，而不是像平时一样让应用分发这些事件的，所以 timer 是不能被触发的，除非鼠标追踪程序退出并返回到应用程序控制。</p>

<p>一个 run loop 可以使用 run loop 对象显示唤醒，其他的事件可能也会引起 run loop 的唤醒。比如，添加另一个 <code>不是基于端口的 input source</code>（source1） 唤醒 run loop 从而使 input source 可以被立即处理（相比于一直处于等待状态直到其他时间发生才唤醒）。</p>

<h3>在什么时候适合使用 RunLoop ？</h3>

<p><strong><code>唯一需要你显示的使用 run loop 的时候是：当你为你的应用创建了子线程的时候。</code></strong>在你的应用中，主线程的 run loop 是基础设施中至关重要的一部分。所以，app 的框架都会提供运行主线程 loop 的代码并且自动开启 loop。iOS中<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/index.html#//apple_ref/occ/cl/UIApplication">UIApplication</a>（或者OSX中<code>NSApplication</code>）的<code>run</code>方法会开启一个应用中的主 loop 作为应用程序启动步骤的一部分。如果你使用 Xcode 的项目模板来创建你的应用，你完全不用自已去显示的调用这些常规方法。</p>

<p>对子线程来讲，你需要决定是否一个 run loop 对它来说是必要的，如果是，需要你自己配置并且启动它。你并不需要在任何情况下都开启线程的 run loop。比如：你使用线程去执行一些长期的并且预先决定的任务的时候，你可能需要避免开启 run loop 。Run loop 通常服务于一些需要你和线程之间互动性更强的特殊场景。比如，你需要在以下这些场景中开启你的 run loop：</p>

<ul>
<li>使用 port 或者自定义 input source 来和其他线程进行通信。</li>
<li>在线程中使用 timer 。</li>
<li>在 Cocoa 的应用中使用任何与 <code>performSelector…</code>相关的方法。</li>
<li>让你的线程继续执行周期性的任务。</li>
</ul>


<p>如果你选择使用 run loop，配置和建立它是非常简单的。如同所有的多线程编程一样，你需要有计划的在合适的情况下退出子线程。让它（run loop）更好的退出而不是迫使它终止永远都是更好的更干净的结束线程的方法。关于如何配置并且退出的方法将在<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5">使用Run Loop对象</a>中向大家展示。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（三）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(3)/"/>
    <updated>2016-01-07T11:54:24+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(3)</id>
    <content type="html"><![CDATA[<h2>苹果用 RunLoop 实现的功能</h2>

<p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoop</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">current</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">kCFRunLoopDefaultMode</span>
</span><span class='line'>    <span class="n">common</span> <span class="n">modes</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UITrackingRunLoopMode</span>
</span><span class='line'>        <span class="n">kCFRunLoopDefaultMode</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">common</span> <span class="n">mode</span> <span class="n">items</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// source0 (manual)</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">_UIApplicationHandleEventQueue</span><span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">PurpleEventSignalCallback</span> <span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">FBSSerialQueueRunLoopSourceHandler</span><span class="p">}}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// source1 (mach port)</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="p">{</span><span class="n">port</span> <span class="o">=</span> <span class="mi">17923</span><span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="p">{</span><span class="n">port</span> <span class="o">=</span> <span class="mi">12039</span><span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>  <span class="p">{</span><span class="n">port</span> <span class="o">=</span> <span class="mi">16647</span><span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">PurpleEventCallback</span><span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="n">port</span> <span class="o">=</span> <span class="mi">2407</span><span class="p">,</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">_ZL20notify_port_callbackP12__CFMachPortPvlS1_</span><span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="n">port</span> <span class="o">=</span> <span class="mi">1</span><span class="n">c03</span><span class="p">,</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">__IOHIDEventSystemClientAvailabilityCallback</span><span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="n">port</span> <span class="o">=</span> <span class="mi">1</span><span class="n">b03</span><span class="p">,</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">__IOHIDEventSystemClientQueueCallback</span><span class="p">}}</span>
</span><span class='line'>        <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="n">port</span> <span class="o">=</span> <span class="mi">1903</span><span class="p">,</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">__IOMIGMachPortPortCallback</span><span class="p">}}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Ovserver</span>
</span><span class='line'>        <span class="n">CFRunLoopObserver</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483647</span><span class="p">,</span> <span class="n">activities</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span> <span class="c1">// Entry</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">_wrapRunLoopWithAutoreleasePoolHandler</span><span class="p">}</span>
</span><span class='line'>        <span class="n">CFRunLoopObserver</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">activities</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">,</span>          <span class="c1">// BeforeWaiting</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">_UIGestureRecognizerUpdateObserver</span><span class="p">}</span>
</span><span class='line'>        <span class="n">CFRunLoopObserver</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">1999000</span><span class="p">,</span> <span class="n">activities</span> <span class="o">=</span> <span class="mh">0xa0</span><span class="p">,</span>    <span class="c1">// BeforeWaiting | Exit</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">_afterCACommitHandler</span><span class="p">}</span>
</span><span class='line'>        <span class="n">CFRunLoopObserver</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">2000000</span><span class="p">,</span> <span class="n">activities</span> <span class="o">=</span> <span class="mh">0xa0</span><span class="p">,</span>    <span class="c1">// BeforeWaiting | Exit</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><span class="p">}</span>
</span><span class='line'>        <span class="n">CFRunLoopObserver</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">2147483647</span><span class="p">,</span> <span class="n">activities</span> <span class="o">=</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="c1">// BeforeWaiting | Exit</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">_wrapRunLoopWithAutoreleasePoolHandler</span><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Timer</span>
</span><span class='line'>        <span class="n">CFRunLoopTimer</span> <span class="p">{</span><span class="n">firing</span> <span class="o">=</span> <span class="n">No</span><span class="p">,</span> <span class="n">interval</span> <span class="o">=</span> <span class="mf">3.1536e+09</span><span class="p">,</span> <span class="n">tolerance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>            <span class="n">next</span> <span class="n">fire</span> <span class="n">date</span> <span class="o">=</span> <span class="mi">453098071</span> <span class="p">(</span><span class="o">-</span><span class="mf">4421.76019</span> <span class="p">@</span> <span class="mi">96223387169499</span><span class="p">),</span>
</span><span class='line'>            <span class="n">callout</span> <span class="o">=</span> <span class="n">_ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv</span> <span class="p">(</span><span class="n">QuartzCore</span><span class="p">.</span><span class="n">framework</span><span class="p">)}</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">modes</span> <span class="err">＝</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CFRunLoopMode</span>  <span class="p">{</span>
</span><span class='line'>            <span class="n">sources0</span> <span class="o">=</span>  <span class="p">{</span> <span class="cm">/* same as &#39;common mode items&#39; */</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">sources1</span> <span class="o">=</span>  <span class="p">{</span> <span class="cm">/* same as &#39;common mode items&#39; */</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">observers</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* same as &#39;common mode items&#39; */</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">timers</span> <span class="o">=</span>    <span class="p">{</span> <span class="cm">/* same as &#39;common mode items&#39; */</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CFRunLoopMode</span>  <span class="p">{</span>
</span><span class='line'>            <span class="n">sources0</span> <span class="o">=</span>  <span class="p">{</span> <span class="cm">/* same as &#39;common mode items&#39; */</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">sources1</span> <span class="o">=</span>  <span class="p">{</span> <span class="cm">/* same as &#39;common mode items&#39; */</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">observers</span> <span class="o">=</span> <span class="p">{</span> <span class="cm">/* same as &#39;common mode items&#39; */</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">timers</span> <span class="o">=</span>    <span class="p">{</span> <span class="cm">/* same as &#39;common mode items&#39; */</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CFRunLoopMode</span>  <span class="p">{</span>
</span><span class='line'>            <span class="n">sources0</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">callout</span> <span class="o">=</span> <span class="n">FBSSerialQueueRunLoopSourceHandler</span><span class="p">}}</span>
</span><span class='line'>            <span class="p">},</span>
</span><span class='line'>            <span class="n">sources1</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">),</span>
</span><span class='line'>            <span class="n">observers</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">CFRunLoopObserver</span> <span class="o">&gt;</span><span class="p">{</span><span class="n">activities</span> <span class="o">=</span> <span class="mh">0xa0</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="mi">2000000</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">callout</span> <span class="o">=</span> <span class="n">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><span class="p">}</span>
</span><span class='line'>            <span class="p">)},</span>
</span><span class='line'>            <span class="n">timers</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">),</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CFRunLoopMode</span>  <span class="p">{</span>
</span><span class='line'>            <span class="n">sources0</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">callout</span> <span class="o">=</span> <span class="n">PurpleEventSignalCallback</span><span class="p">}}</span>
</span><span class='line'>            <span class="p">},</span>
</span><span class='line'>            <span class="n">sources1</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">CFRunLoopSource</span> <span class="p">{</span><span class="n">order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">callout</span> <span class="o">=</span> <span class="n">PurpleEventCallback</span><span class="p">}}</span>
</span><span class='line'>            <span class="p">},</span>
</span><span class='line'>            <span class="n">observers</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">),</span>
</span><span class='line'>            <span class="n">timers</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">),</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CFRunLoopMode</span>  <span class="p">{</span>
</span><span class='line'>            <span class="n">sources0</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">),</span>
</span><span class='line'>            <span class="n">sources1</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">),</span>
</span><span class='line'>            <span class="n">observers</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">),</span>
</span><span class='line'>            <span class="n">timers</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">),</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，系统默认注册了5个Mode:</p>

<!--more-->


<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。
4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。
5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>


<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>

<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 1. 通知Observers，即将进入RunLoop</span>
</span><span class='line'>    <span class="c1">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopEntry</span><span class="p">);</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">/// 2. 通知 Observers: 即将触发 Timer 回调。</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeTimers</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeSources</span><span class="p">);</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">/// 4. 触发 Source0 (非基于port的) 回调。</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><span class="p">(</span><span class="n">source0</span><span class="p">);</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">/// 6. 通知Observers，即将进入休眠</span>
</span><span class='line'>        <span class="c1">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeWaiting</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">/// 7. sleep to wait msg.</span>
</span><span class='line'>        <span class="n">mach_msg</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">mach_msg_trap</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        <span class="c1">/// 8. 通知Observers，线程被唤醒</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopAfterWaiting</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">/// 9. 如果是被Timer唤醒的，回调Timer</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="p">(</span><span class="n">dispatched_block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span>
</span><span class='line'>        <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><span class="p">(</span><span class="n">source1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(...);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 10. 通知Observers，即将退出RunLoop</span>
</span><span class='line'>    <span class="c1">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopExit</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>AutoreleasePool</h3>

<p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>

<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>

<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>

<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>

<h3>事件响应</h3>

<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>

<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>

<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>

<h3>手势识别</h3>

<p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>

<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>

<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>

<h3>界面更新</h3>

<p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>

<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：
_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>

<p>这个函数内部的调用栈大概是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv</span><span class="p">()</span>
</span><span class='line'>    <span class="nl">QuartzCore</span><span class="p">:</span><span class="n">CA</span><span class="o">::</span><span class="n">Transaction</span><span class="o">::</span><span class="nl">observer_callback</span><span class="p">:</span>
</span><span class='line'>        <span class="n">CA</span><span class="o">::</span><span class="n">Transaction</span><span class="o">::</span><span class="n">commit</span><span class="p">();</span>
</span><span class='line'>            <span class="n">CA</span><span class="o">::</span><span class="n">Context</span><span class="o">::</span><span class="n">commit_transaction</span><span class="p">();</span>
</span><span class='line'>                <span class="n">CA</span><span class="o">::</span><span class="n">Layer</span><span class="o">::</span><span class="n">layout_and_display_if_needed</span><span class="p">();</span>
</span><span class='line'>                    <span class="n">CA</span><span class="o">::</span><span class="n">Layer</span><span class="o">::</span><span class="n">layout_if_needed</span><span class="p">();</span>
</span><span class='line'>                        <span class="p">[</span><span class="bp">CALayer</span> <span class="n">layoutSublayers</span><span class="p">];</span>
</span><span class='line'>                            <span class="p">[</span><span class="bp">UIView</span> <span class="n">layoutSubviews</span><span class="p">];</span>
</span><span class='line'>                    <span class="n">CA</span><span class="o">::</span><span class="n">Layer</span><span class="o">::</span><span class="n">display_if_needed</span><span class="p">();</span>
</span><span class='line'>                        <span class="p">[</span><span class="bp">CALayer</span> <span class="n">display</span><span class="p">];</span>
</span><span class='line'>                            <span class="p">[</span><span class="bp">UIView</span> <span class="n">drawRect</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>定时器</h3>

<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>

<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>

<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>

<h3>PerformSelector</h3>

<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>

<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>

<h3>关于GCD</h3>

<p>实际上 RunLoop 底层也会用到 GCD 的东西。同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>

<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>

<h3>关于网络请求</h3>

<p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFSocket</span>
</span><span class='line'><span class="n">CFNetwork</span>       <span class="o">-&gt;</span><span class="n">ASIHttpRequest</span>
</span><span class='line'><span class="bp">NSURLConnection</span> <span class="o">-&gt;</span><span class="n">AFNetworking</span>
</span><span class='line'><span class="bp">NSURLSession</span>    <span class="o">-&gt;</span><span class="n">AFNetworking2</span><span class="p">,</span> <span class="n">Alamofire</span>
</span></code></pre></td></tr></table></div></figure>


<p>• CFSocket 是最底层的接口，只负责 socket 通信。
• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。
• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。
• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</p>

<p>下面主要介绍下 NSURLConnection 的工作过程。</p>

<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>

<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_network.png?raw=true" alt="NSURLConnection" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>

<h2>RunLoop 的实际应用举例</h2>

<h3>AFNetworking</h3>

<p><a href="https://github.com/AFNetworking/AFNetworking/blob/2.6.3/AFNetworking/AFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">networkRequestThreadEntryPoint:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">__unused</span> <span class="n">object</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]</span> <span class="nl">setName</span><span class="p">:</span><span class="s">@&quot;AFNetworking&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSRunLoop</span> <span class="o">*</span><span class="n">runLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="nl">addPort</span><span class="p">:[</span><span class="bp">NSMachPort</span> <span class="n">port</span><span class="p">]</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="n">run</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">+</span> <span class="p">(</span><span class="bp">NSThread</span> <span class="o">*</span><span class="p">)</span><span class="n">networkRequestThread</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="bp">NSThread</span> <span class="o">*</span><span class="n">_networkRequestThread</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">oncePredicate</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oncePredicate</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">_networkRequestThread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkRequestThreadEntryPoint</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_networkRequestThread</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_networkRequestThread</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">start</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">lock</span> <span class="n">lock</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="n">isCancelled</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">cancelConnection</span><span class="p">)</span> <span class="nl">onThread</span><span class="p">:[[</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="n">networkRequestThread</span><span class="p">]</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span> <span class="nl">modes</span><span class="p">:[</span><span class="nb">self</span><span class="p">.</span><span class="n">runLoopModes</span> <span class="n">allObjects</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="n">isReady</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">AFOperationExecutingState</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">operationDidStart</span><span class="p">)</span> <span class="nl">onThread</span><span class="p">:[[</span><span class="nb">self</span> <span class="k">class</span><span class="p">]</span> <span class="n">networkRequestThread</span><span class="p">]</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span> <span class="nl">modes</span><span class="p">:[</span><span class="nb">self</span><span class="p">.</span><span class="n">runLoopModes</span> <span class="n">allObjects</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">lock</span> <span class="n">unlock</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>

<h3>AsyncDisplayKit</h3>

<p><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>

<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>

<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。
绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。
UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>

<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>

<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>

<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。
具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>

<h4>特别致谢：</h4>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<h4>参考文章</h4>

<p>深入理解RunLoop(ibireme)：</p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p>iPhoneDevWiki :</p>

<p><a href="http://iphonedevwiki.net/index.php/CFRunLoop">iphonedevwiki.net/index.php/CFRunLoop</a>
<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">iphonedevwiki.net/index.php/IOHIDFamily</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（二）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(er-)/"/>
    <updated>2016-01-07T10:38:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(er-)</id>
    <content type="html"><![CDATA[<h2>RunLoop 的内部逻辑</h2>

<p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，RunLoop 内部的逻辑大致如下:
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_1.png?raw=true" alt="内部逻辑" /></p>

<p>内部代码整理为：</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// 用DefaultMode启动</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">CFRunLoopRun</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopRunSpecific</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">,</span> <span class="mf">1.0e10</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// 用指定的Mode启动，允许设置RunLoop超时时间</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">CFRunLoopRunInMode</span><span class="p">(</span><span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">,</span> <span class="n">CFTimeInterval</span> <span class="n">seconds</span><span class="p">,</span> <span class="kt">Boolean</span> <span class="n">stopAfterHandle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">CFRunLoopRunSpecific</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">modeName</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">returnAfterSourceHandled</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// RunLoop的实现</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">CFRunLoopRunSpecific</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">modeName</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">stopAfterHandle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 首先根据modeName找到对应mode</span>
</span><span class='line'>    <span class="n">CFRunLoopModeRef</span> <span class="n">currentMode</span> <span class="o">=</span> <span class="n">__CFRunLoopFindMode</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">modeName</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">/// 如果mode里没有source/timer/observer, 直接返回。</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopModeIsEmpty</span><span class="p">(</span><span class="n">currentMode</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span>
</span><span class='line'>    <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopEntry</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 内部函数，进入loop</span>
</span><span class='line'>    <span class="n">__CFRunLoopRun</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">seconds</span><span class="p">,</span> <span class="n">returnAfterSourceHandled</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">Boolean</span> <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">retVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeTimers</span><span class="p">);</span>
</span><span class='line'>            <span class="c1">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeSources</span><span class="p">);</span>
</span><span class='line'>            <span class="c1">/// 执行被加入的block</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 4. RunLoop 触发 Source0 (非port) 回调。</span>
</span><span class='line'>            <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="n">__CFRunLoopDoSources0</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">stopAfterHandle</span><span class="p">);</span>
</span><span class='line'>            <span class="c1">/// 执行被加入的block</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">__Source0DidDispatchPortLastTime</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="kt">Boolean</span> <span class="n">hasMsg</span> <span class="o">=</span> <span class="n">__CFRunLoopServiceMachPort</span><span class="p">(</span><span class="n">dispatchPort</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">hasMsg</span><span class="p">)</span> <span class="k">goto</span> <span class="n">handle_msg</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sourceHandledThisLoop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopBeforeWaiting</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span>
</span><span class='line'>            <span class="c1">/// • 一个基于 port 的Source 的事件。</span>
</span><span class='line'>            <span class="c1">/// • 一个 Timer 到时间了</span>
</span><span class='line'>            <span class="c1">/// • RunLoop 自身的超时时间到了</span>
</span><span class='line'>            <span class="c1">/// • 被其他什么调用者手动唤醒</span>
</span><span class='line'>            <span class="n">__CFRunLoopServiceMachPort</span><span class="p">(</span><span class="n">waitSet</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg_buffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">livePort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">mach_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">MACH_RCV_MSG</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span> <span class="c1">// thread wait for receive msg</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopAfterWaiting</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 收到消息，处理消息。</span>
</span><span class='line'>            <span class="nl">handle_msg</span><span class="p">:</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">msg_is_timer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">__CFRunLoopDoTimers</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">mach_absolute_time</span><span class="p">())</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 9.2 如果有dispatch到main_queue的block，执行block。</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg_is_dispatch</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span>
</span><span class='line'>            <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">CFRunLoopSourceRef</span> <span class="n">source1</span> <span class="o">=</span> <span class="n">__CFRunLoopModeFindSourceForMachPort</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">livePort</span><span class="p">);</span>
</span><span class='line'>                <span class="n">sourceHandledThisLoop</span> <span class="o">=</span> <span class="n">__CFRunLoopDoSource1</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">source1</span><span class="p">,</span> <span class="n">msg</span><span class="p">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">sourceHandledThisLoop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">mach_msg</span><span class="p">(</span><span class="n">reply</span><span class="p">,</span> <span class="n">MACH_SEND_MSG</span><span class="p">,</span> <span class="n">reply</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 执行加入到Loop的block</span>
</span><span class='line'>            <span class="n">__CFRunLoopDoBlocks</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">sourceHandledThisLoop</span> <span class="o">&amp;&amp;</span> <span class="n">stopAfterHandle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">/// 进入loop时参数说处理完事件就返回。</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunHandledSource</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">/// 超出传入参数标记的超时时间了</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunTimedOut</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopIsStopped</span><span class="p">(</span><span class="n">runloop</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">/// 被外部调用者强制停止了</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunStopped</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">__CFRunLoopModeIsEmpty</span><span class="p">(</span><span class="n">runloop</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">/// source/timer/observer一个都没有了</span>
</span><span class='line'>                <span class="n">retVal</span> <span class="o">=</span> <span class="n">kCFRunLoopRunFinished</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">retVal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 10. 通知 Observers: RunLoop 即将退出。</span>
</span><span class='line'>    <span class="n">__CFRunLoopDoObservers</span><span class="p">(</span><span class="n">rl</span><span class="p">,</span> <span class="n">currentMode</span><span class="p">,</span> <span class="n">kCFRunLoopExit</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回</p>

<h2>RunLoop 的底层实现</h2>

<p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。</p>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_3.png?raw=true" alt="底层逻辑" /></p>

<p>苹果官方将整个系统大致划分为上述4个层次：
应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。
应用框架层即开发人员接触到的 Cocoa 等框架。
核心框架层包括各种核心框架、OpenGL 等内容。
Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/">opensource.apple.com</a> 里找到。</p>

<p>我们在深入看一下 Darwin 这个核心的架构
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_4.png?raw=true" alt="Darwin" />
其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。
XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。
BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。
IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>

<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为"对象"。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。"消息"是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>

<p>Mach 的消息定义是在 &lt;mach/message.h> 头文件的，很简单：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">mach_msg_header_t</span> <span class="n">header</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_body_t</span> <span class="n">body</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="kt">mach_msg_base_t</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">mach_msg_bits_t</span> <span class="n">msgh_bits</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_size_t</span> <span class="n">msgh_size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_t</span> <span class="n">msgh_remote_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_t</span> <span class="n">msgh_local_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_name_t</span> <span class="n">msgh_voucher_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_id_t</span> <span class="n">msgh_id</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="kt">mach_msg_header_t</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，
发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">mach_msg_return_t</span> <span class="nf">mach_msg</span><span class="p">(</span>
</span><span class='line'>          <span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
</span><span class='line'>          <span class="kt">mach_msg_option_t</span> <span class="n">option</span><span class="p">,</span>
</span><span class='line'>          <span class="kt">mach_msg_size_t</span> <span class="n">send_size</span><span class="p">,</span>
</span><span class='line'>          <span class="kt">mach_msg_size_t</span> <span class="n">rcv_size</span><span class="p">,</span>
</span><span class='line'>          <span class="kt">mach_port_name_t</span> <span class="n">rcv_name</span><span class="p">,</span>
</span><span class='line'>          <span class="kt">mach_msg_timeout_t</span> <span class="n">timeout</span><span class="p">,</span>
</span><span class='line'>          <span class="kt">mach_port_name_t</span> <span class="n">notify</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_5.png?raw=true" alt="Darwin" />
这些概念可以参考维基百科:<a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing">Trap_(computing)</a>)</p>

<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>

<p>关于具体的如何利用 mach port 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/">NSHipster</a> 这一篇文章，或者<a href="http://segmentfault.com/a/1190000002400329">这里</a>的中文翻译 。</p>

<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://history.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>

<h4>特别致谢：</h4>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p><strong>参考文章：</strong></p>

<p>深入理解RunLoop(ibireme)：</p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p>Apple Document：
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html</a></p>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">Apple&ndash;RunLoopManagement文档</a></p>

<p><a href="http://opensource.apple.com/">opensource.apple.com</a></p>

<p>维基百科：</p>

<p><a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、
<a href="http://en.wikipedia.org/wiki/Trap_(computing">Trap_(computing)</a>)</p>

<p>NSHipster：</p>

<p><a href="http://nshipster.com/inter-process-communication/">inter-process-
communication</a> <a href="http://segmentfault.com/a/1190000002400329">inter-process-communication中文</a></p>

<p><a href="http://history.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（一）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/06/runloopshen-du-tan-jiu/"/>
    <updated>2016-01-06T18:15:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/06/runloopshen-du-tan-jiu</id>
    <content type="html"><![CDATA[<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">function</span> <span class="nf">loop</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">initialize</span><span class="p">();</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="n">message</span> <span class="o">=</span> <span class="n">get_next_message</span><span class="p">();</span>
</span><span class='line'>        <span class="n">process_message</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">message</span> <span class="o">!=</span> <span class="n">quit</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种模型通常被称作 <a href="https://en.wikipedia.org/wiki/Event_loop">Event Loop</a>。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>

<!--more-->


<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 &ldquo;接受消息->等待->处理&rdquo; 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>

<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。
CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>

<p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c">开源</a>的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz">http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz</a> 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span>
</span><span class='line'><span class="k">static</span> <span class="n">CFMutableDictionaryRef</span> <span class="n">loopsDic</span><span class="p">;</span>
</span><span class='line'><span class="c1">/// 访问 loopsDic 时的锁</span>
</span><span class='line'><span class="k">static</span> <span class="n">CFSpinLock_t</span> <span class="n">loopsLock</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// 获取一个 pthread 对应的 RunLoop。</span>
</span><span class='line'><span class="n">CFRunLoopRef</span> <span class="nf">_CFRunLoopGet</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">OSSpinLockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loopsDic</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span>
</span><span class='line'>        <span class="n">loopsDic</span> <span class="o">=</span> <span class="n">CFDictionaryCreateMutable</span><span class="p">();</span>
</span><span class='line'>        <span class="n">CFRunLoopRef</span> <span class="n">mainLoop</span> <span class="o">=</span> <span class="n">_CFRunLoopCreate</span><span class="p">();</span>
</span><span class='line'>        <span class="n">CFDictionarySetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="n">pthread_main_thread_np</span><span class="p">(),</span> <span class="n">mainLoop</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 直接从 Dictionary 里获取。</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">CFDictionaryGetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="kr">thread</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">/// 取不到时，创建一个</span>
</span><span class='line'>        <span class="n">loop</span> <span class="o">=</span> <span class="n">_CFRunLoopCreate</span><span class="p">();</span>
</span><span class='line'>        <span class="n">CFDictionarySetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">loop</span><span class="p">);</span>
</span><span class='line'>        <span class="c1">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span>
</span><span class='line'>        <span class="n">_CFSetTSD</span><span class="p">(...,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="n">__CFFinalizeRunLoop</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">OSSpinLockUnLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">loop</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFRunLoopRef</span> <span class="nf">CFRunLoopGetMain</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_CFRunLoopGet</span><span class="p">(</span><span class="n">pthread_main_thread_np</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFRunLoopRef</span> <span class="nf">CFRunLoopGetCurrent</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_CFRunLoopGet</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>综上：线程和RunLoop之间是一一对应的，并且关系是保存在一个全局的字典中的，并且线程刚创建时是没有RunLoop的，如果你不获取它，他一直都不会有，RunLoop的创建发生在第一次获取的时候，RunLoop的销毁发生在线程结束时。并且只能在线程内部获取runloop（主线程除外）。</p>

<h1>RunLoop 对外的接口</h1>

<p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopRef</span>
</span><span class='line'><span class="n">CFRunLoopModeRef</span>
</span><span class='line'><span class="n">CFRunLoopSourceRef</span>
</span><span class='line'><span class="n">CFRunLoopTimerRef</span>
</span><span class='line'><span class="n">CFRunLoopObserverRef</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_0.png?raw=true" alt="image" />
一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>

<p><strong>CFRunLoopSourceRef</strong>是事件产生的地方。Source有两个版本：Source0 和 Source1。
• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。
• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopSourceRef.png?raw=true" alt="image" /></p>

<p><strong>CFRunLoopTimerRef</strong>是基于时间的触发器，他和NSTimer是toll-free bridged的，可以混用。其包含一个时间长度和一个回调（函数指针）。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopTimeRef.png?raw=true" alt="image" /></p>

<p><strong>CFRunLoopObserverRef</strong>是观察者，每个Observer都包含了一个回调（函数指针），当RunLoop的状态发生变法时，观察者就能通过回调接受这个变化。可以观测的时间点有以下几个：
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopObserverRef.png?raw=true" alt="image" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">CF_OPTIONS</span><span class="p">(</span><span class="n">CFOptionFlags</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">kCFRunLoopEntry</span>         <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="c1">// 即将进入Loop</span>
</span><span class='line'>    <span class="n">kCFRunLoopBeforeTimers</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="c1">// 即将处理 Timer</span>
</span><span class='line'>    <span class="n">kCFRunLoopBeforeSources</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span> <span class="c1">// 即将处理 Source</span>
</span><span class='line'>    <span class="n">kCFRunLoopBeforeWaiting</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">),</span> <span class="c1">// 即将进入休眠</span>
</span><span class='line'>    <span class="n">kCFRunLoopAfterWaiting</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">),</span> <span class="c1">// 刚从休眠中唤醒</span>
</span><span class='line'>    <span class="n">kCFRunLoopExit</span>          <span class="o">=</span> <span class="p">(</span><span class="mi">1UL</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span> <span class="c1">// 即将退出Loop</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<h2>RunLoop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__CFRunLoopMode</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CFStringRef</span> <span class="n">_name</span><span class="p">;</span>            <span class="c1">// Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span>
</span><span class='line'>    <span class="n">CFMutableSetRef</span> <span class="n">_sources0</span><span class="p">;</span>    <span class="c1">// Set</span>
</span><span class='line'>    <span class="n">CFMutableSetRef</span> <span class="n">_sources1</span><span class="p">;</span>    <span class="c1">// Set</span>
</span><span class='line'>    <span class="n">CFMutableArrayRef</span> <span class="n">_observers</span><span class="p">;</span> <span class="c1">// Array</span>
</span><span class='line'>    <span class="n">CFMutableArrayRef</span> <span class="n">_timers</span><span class="p">;</span>    <span class="c1">// Array</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">struct</span> <span class="bp">__CFRunLoop</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CFMutableSetRef</span> <span class="n">_commonModes</span><span class="p">;</span>     <span class="c1">// Set</span>
</span><span class='line'>    <span class="n">CFMutableSetRef</span> <span class="n">_commonModeItems</span><span class="p">;</span> <span class="c1">// Set&lt;Source/Observer/Timer&gt;</span>
</span><span class='line'>    <span class="n">CFRunLoopModeRef</span> <span class="n">_currentMode</span><span class="p">;</span>    <span class="c1">// Current Runloop Mode</span>
</span><span class='line'>    <span class="n">CFMutableSetRef</span> <span class="n">_modes</span><span class="p">;</span>           <span class="c1">// Set</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里有个概念叫：“CommonModes”一个Mode可以将自己标记为“Common”属性（通过将其ModeName添加到RunLoop得“commonModes”中）。每当RnuLoop的内容发生变化时，RunLoop的都会自动将_commonModeItems里的Source/Timer/Observer同步到具有“Common”标记的所有的Mode。
应用举例：主线程 RunLoop 默认会预制两个 Mode ：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个Mode都已经被标记为“Common”属性。DefaultMode是App平时所处的状态，TrackingRunLoop是为了追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调。此时滑动TableView时，RunLoop会将mode切换为TrackingRunLoopMode，这时Timer就不会被回调，也不会影响滑动的操作了。具体用例类似于在tableView中加入滚动广告栏，当你在操作tableView时会回调自动滚动栏的Timer，造成滚动栏的滑动出现卡顿。</p>

<p>有时你需要一个Timer，在两个Mode中都能得到回调，一种办法就是讲这个Timer加入两个Mode。还有一种就是讲Timer加入到顶层的RunLoop的“commonModeItems”中。“commonModeItems”被RunLoop自动更新到所有具有“Common”属性的Mode里去。</p>

<p>CFRunLoop对外暴漏的管理Mode的接口只有下面两个：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopAddCommonMode</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">runloop</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span> <span class="c1">// 给RunLoop添加到CommonMode中</span>
</span><span class='line'><span class="n">CFRunLoopRunInMode</span><span class="p">(</span><span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">,</span> <span class="p">...);</span> <span class="c1">// 返回当前线程中指定mode的CFRunLoop对象</span>
</span></code></pre></td></tr></table></div></figure>


<p>Mode暴露的管理mode item的接口有下面几个</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopSourceRef</span> <span class="n">source</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span><span class="c1">// 添加一个CFRunLoopSource对象到一个run loop mode中（如果添加的Source是source0的话，这个方法将会调用 schedule 回调在source的上下文结构（context structure）的指定方法）。一个runloop source 可以同时被注册到多个 runloop 和 runloop modes 中。当source被发出信号，无论哪一个被注册的 runloop 都会开始检测第一个发出信号的 source 。 如过rl的mode中已经包含source时，这个方法将不会做任何事。</span>
</span><span class='line'><span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span> <span class="c1">// 添加CFRunLoopObserver对象到一个run loop mode中去。 讨论：一个 runloop 观察者只能被同时注册在一个 runloop 中，尽管它可以被通过他的tunloop添加到多个runloop modes中。 如果rl已经在 mode中 包含 obsever 中，这个方法将不会做任何事。</span>
</span><span class='line'><span class="n">CFRunLoopAddTimer</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span><span class='line'><span class="n">CFRunLoopRemoveSource</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopSourceRef</span> <span class="n">source</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span> <span class="c1">// 添加CFRunLoopTimer 对象到一个runloop mode中 讨论：一个runloop timer 在同一时刻只能注册在一个run loop，尽管它可以被通过他的tunloop添加到多个runloop modes中。 如果rl已经在 mode中 包含 obsever 中，这个方法将不会做任何事</span>
</span><span class='line'><span class="n">CFRunLoopRemoveObserver</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">modeName</span><span class="p">);</span> <span class="c1">// 从run loop mode 移除 Observer 对象，如果 rl 没有包含参数中的Observer，则该函数不做任何处理</span>
</span><span class='line'><span class="n">CFRunLoopRemoveTimer</span><span class="p">(</span><span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span> <span class="c1">// 从run loop mode 移除 timer 对象，如果 rl 没有包含参数中的timer，则该函数不做任何处理</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上接口可以看出，只能通过mode name操作内部mode，当你传入一个新的mode name但runloop内部没有对应的mode时，runloop会自动帮你创建对应的CFRunloopModeRef。并且官方文档明确指出，对于runloop来说，其内部的mode只能增加不能删除。</p>

<p>苹果官方公开的内部mode有两个：CFRunLoopDefaultMode（NSDefaultRunLoopMode）和UITrackingRunLoopMode，你可以用这两个 Mode Name来操作对应的 Mode。
同时苹果还提出了一个操作Common标记的字符串：kCFRunLoopCommonModes（NSRunLoopCommonModes），你可以用这个字符串来操作Common Items，或标记一个Mode为“Common”。使用时注意区分该字符串与其他mode name。</p>

<h4>特别致谢：</h4>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p><strong>参考文章：</strong></p>

<p>深入理解RunLoop:</p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/2015/05/18/runloop/#more-41710</a></p>

<p>Apple Document:</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[宏定义的高级用法]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/definede-gao-ji-yong-fa/"/>
    <updated>2016-01-04T11:44:51+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/definede-gao-ji-yong-fa</id>
    <content type="html"><![CDATA[<p>1、# （stringizing）字符串化操作符。其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。
如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define example(instr) printf(&quot;the input string is:\t%s\n&quot;,#instr)</span>
</span><span class='line'><span class="cp">#define example1(instr) #instr</span>
</span></code></pre></td></tr></table></div></figure>


<p>当使用该宏定义时：</p>

<!--more-->


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">example</span><span class="p">(</span><span class="n">abc</span><span class="p">)</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>


<p> 在编译时将会展开成：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot;the input string is:</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="s">&quot;abc&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">string</span> <span class="n">str</span><span class="o">=</span><span class="n">example1</span><span class="p">(</span><span class="n">abc</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>将会展成：</p>

<p><code>string str="abc";</code></p>

<p>注意：
对空格的处理
a。忽略传入参数名前面和后面的空格。</p>

<p>   如：<code>str=example1(   abc )</code>； 将会被扩展成<code>str="abc"</code>；</p>

<p>b.当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串中只以一个空格连接，忽略其中多余一个的空格。</p>

<p>   如：<code>str=exapme( abc    def)</code>; 将会被扩展成 <code>str="abc def"</code>；</p>

<p>2、## （token-pasting）符号连接操作符(让参数值转换为参数名)
宏定义中：参数名，即为形参，如#define sum(a,b) (a+b)；中a和b均为某一参数的代表符号，即形式参数。
而##的作用则是将宏定义的多个形参成一个实际参数名。</p>

<p>如：</p>

<p><code>#define exampleNum(n) num##n
</code></p>

<p><code>int num9=9</code>;</p>

<p>使用：</p>

<p><code>int num=exampleNum(9)</code>;</p>

<p>将会扩展成 <code>int num=num9</code>;</p>

<p>注意：</p>

<p>1.当用##连接形参时，##前后的空格可有可无。</p>

<p>如：<code>#define exampleNum(n) num ## n</code>相当于 <code>#define exampleNum(n) num##n</code></p>

<p>2.连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义</p>

<p>// preprocessor_token_pasting.cpp</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include </span>
</span><span class='line'><span class="cp">#define paster( n ) printf_s( &quot;token&quot; #n &quot; = %d&quot;, token##n )</span>
</span><span class='line'><span class="kt">int</span> <span class="n">token9</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">paster</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果：</p>

<p><code>token9 = 9</code></p>

<p>3、@# （charizing）字符化操作符。
只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。作用是将传的单字符参数名转换成字符，以一对单引用括起来。</p>

<p><code>#define makechar(x)  #@x
a = makechar(b);</code></p>

<p>展开后变成了：</p>

<p><code>a= 'b';</code></p>

<p>4、\ 行继续操作符
当定义的宏不能用一行表达完整时，可以用"\&ldquo;表示下一行继续此宏的定义。</p>

<p><a href="http://blog.csdn.net/hjmhz/article/details/8667185">更多高级用法&hellip;</a></p>

<p><a href="http://blog.chinaunix.net/uid-23254875-id-341055.html">转自http://blog.chinaunix.net/uid-23254875-id-341055.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于block使用的5点注意事项]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/guan-yu-blockshi-yong-de-5dian-zhu-yi-shi-xiang-d/"/>
    <updated>2016-01-04T11:24:25+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/guan-yu-blockshi-yong-de-5dian-zhu-yi-shi-xiang-d</id>
    <content type="html"><![CDATA[<p><div class="post">
        <div class="clear"></div>
        <div class="postBody">
            <div id="cnblogs_post_body"><div id="main-content" class="wiki-content">
<p>1、在使用block前需要对block指针做判空处理。</p>
<p>不判空直接使用，一旦指针为空直接产生崩溃。</p>
</div>
<div class="wiki-content">
<pre><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">self.isOnlyNet) {
    </span><span style="color: #0000ff;">if</span> (succBlock == NULL) { <span style="color: #008000;">//</span><span style="color: #008000;">后面使用block之前要先做判空处理</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">id</span> data =<span style="color: #000000;"> [NSKeyedUnarchiver unarchiveObjectWithFile:[self favoriteFile]];
    </span><span style="color: #0000ff;">if</span> ([data isKindOfClass:[NSMutableArray <span style="color: #0000ff;">class</span><span style="color: #000000;">]]) {
        succBlock(data,YES);
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        succBlock(nil,YES);
    }
}</span></pre>
<p>&nbsp;</p>
</div>
<!--more-->
<div class="wiki-content">2、在MRC的编译环境下，block如果作为成员参数要copy一下将栈上的block拷贝到堆上（示例见下，<a class="external-link" href="http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html" rel="nofollow">原因参考</a>）
<p>3、在block使用之后要对，block指针做赋空值处理，如果是MRC的编译环境下，要先release掉block对象。</p>
<p>block作为类对象的成员变量，使用block的人有可能用类对象参与block中的运算而产生循环引用。</p>
<p>将block赋值为空，是解掉循环引用的重要方法。（不能只在dealloc里面做赋空值操作，这样已经产生的循环引用不会被破坏掉）</p>
<pre>typedef <span style="color: #0000ff;">void</span>(^SuccBlock)(<span style="color: #0000ff;">id</span><span style="color: #000000;"> data);
</span><span style="color: #0000ff;">@interface</span><span style="color: #000000;"> NetworkClass {
    SuccessBlock _sucBlock;
}
@property (nonatomic,assign)BOOL propertyUseInCallBack;
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) requestWithSucBlock: (SuccessBlock) callbackBlock;
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> NetworkClass
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) requestWithSucBlock: (SuccessBlock) callbackBlock {
    <em>sucBlock </span>= callbackBlock;<span style="color: #008000;">//</span><span style="color: #008000;">MRC下：</em>sucBlock = [callbackBlock copy]; 不copy block会在栈上被回收。</span>
<span style="color: #000000;">}</p>

<p></span>- (<span style="color: #0000ff;">void</span>) netwrokDataBack: (<span style="color: #0000ff;">id</span><span style="color: #000000;">) data {
    </span><span style="color: #0000ff;">if</span> (data != nil &amp;&amp; <em>sucBlock !=<span style="color: #000000;"> NULL) {
        </em>sucBlock(data);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">MRC下：要先将[<em>sucBlock release];（之前copy过）</span>
    </em>sucBlock = nil; <span style="color: #008000;">//</span><span style="color: #008000;">Importent: 在使用之后将Block赋空值，解引用 !!!</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #008000;">//</span><span style="color: #008000;">=======================以下是使用方===========================</span>
<span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> UserCode
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) temporaryNetworkCall
{
    NetworkClass </span><em>netObj =<span style="color: #000000;"> [[NetworkClass alloc] init];
    netObj.propertyUseInCallBack </span>=<span style="color: #000000;"> NO;
    [netObj requestWithSucBlock: </span>^(<span style="color: #0000ff;">id</span><span style="color: #000000;"> data) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">由于block里面引用netObj的指针所以这里产生了循环引用，且由于这个block是作为参数传入对象的，编译器不会报错。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">因此，NetworkClass使用完block之后一定要将作为成员变量的block赋空值。</span>
        <span style="color: #0000ff;">if</span> (netObj.propertyUseInCallBack ==<span style="color: #000000;"> YES) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">Do Something&hellip;</span>
<span style="color: #000000;">        }
    }];
}
</span><span style="color: #0000ff;">@end</span></pre>
<p>&nbsp;</p>
<p>还有一种改法，在block接口设计时，将可能需要的变量作为形参传到block中，从设计上解决循环引用的问题。</p>
<p>如果上面Network类设计成这个样子：</p>
<div class="code panel pdl" style="border-width: 1px;">
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">
<pre><span style="color: #0000ff;">@class</span><span style="color: #000000;"> NetowrkClass;
typedef </span><span style="color: #0000ff;">void</span>(^SuccBlock)(NetworkClass </em>aNetworkObj, <span style="color: #0000ff;">id</span><span style="color: #000000;"> data);
</span><span style="color: #0000ff;">@interface</span><span style="color: #000000;"> NetworkClass
</span><span style="color: #008000;">//</span><span style="color: #008000;">&hellip;</span>
<span style="color: #0000ff;">@end</span>
<span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> NetworkClass
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> UserCode
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) temporaryNetworkCall
{
    NetworkClass </span><em>netObj =<span style="color: #000000;"> [[NetworkClass alloc] init];
    netObj.propertyUseInCallBack </span>=<span style="color: #000000;"> NO;
    [netObj requestWithSucBlock: </span>^(NetworkClass </em>aNetworkObj, <span style="color: #0000ff;">id</span><span style="color: #000000;"> data) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">这里参数中已经有netObj的对象了，使用者不用再从block外引用指针了。</span>
        <span style="color: #0000ff;">if</span> (aNetworkObj.propertyUseInCallBack ==<span style="color: #000000;"> YES) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">Do Something&hellip;</span>
<span style="color: #000000;">        }
    }];
}
</span><span style="color: #0000ff;">@end</span></pre>
<p>&nbsp;</p>
</div>
</div>
<p>4、使用方将self或成员变量加入block之前要先将self变为<strong>weak</p>
<p>5、在多线程环境下（block中的weakSelf有可能被析构的情况下），需要先将self转为strong指针，避免在运行到某个关键步骤时self对象被析构。</p>
<p>第四、第五条合起来有个名词叫weak–strong dance，来自于<a class="external-link" style="text-decoration: none;" href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDkQFjAA&amp;url=%68%74%74%70%3a%2f%2f%64%65%76%65%6c%6f%70%65%72%2e%61%70%70%6c%65%2e%63%6f%6d%2f%76%69%64%65%6f%73%2f%77%77%64%63%2f%32%30%31%31%2f&amp;ei=mDl_UcKaEtDZkgXG14GoDg&amp;usg=AFQjCNENM0Mbw7vrvpPYNzjg2R9u6IUiEA&amp;sig2=wwwajZBQ62fO7EsU4RvSOg&amp;bvm=bv.45645796,d.dGI&amp;cad=rjt" rel="nofollow">2011 WWDC Session #322 (Objective-C Advancements in Depth）</a></p>
<p>以下代码来自AFNetworking，堪称使用weak–strong dance的经典。</p>
<div class="code panel pdl" style="border-width: 1px;">
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">
<pre></strong>weak <strong>typeof(self)weakSelf =<span style="color: #000000;"> self;
AFNetworkReachabilityStatusBlock callback </span>= ^<span style="color: #000000;">(AFNetworkReachabilityStatus status) {
    </strong>strong <strong>typeof(weakSelf)strongSelf </span>=<span style="color: #000000;"> weakSelf;
    strongSelf.networkReachabilityStatus </span>=<span style="color: #000000;"> status;
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (strongSelf.networkReachabilityStatusBlock) {
        strongSelf.networkReachabilityStatusBlock(status);
    }
};</span></pre>
</div>
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">Review一下上面这段代码，里面玄机不少。</div>
</div>
<p>第一行：</strong>weak <strong>typeof(self)weakSelf = self;</p>
<p>如之前第四条所说，为防止callback内部对self强引用，weak一下。</p>
<p>其中用到了</strong>typeof(self)，这里涉及几个知识点：</p>
<p>a. <strong>typeof、</strong>typeof<strong>、typeof的区别</p>
<p>恩~~他们没有区别，但是这牵扯一段往事，在早期C语言中没有typeof这个关键字，</strong>typeof、<strong>typeof</strong>是在C语言的扩展关键字的时候出现的。</p>
<p>typeof是现代GNU C++的关键字，从Objective-C的根源说，他其实来自于C语言，所以AFNetworking使用了继承自C的关键字。</p>
<p>b.对于老的LLVM编译器上面这句话会编译报错，所以在很早的ARC使用者中流行<strong>typeof(&amp;*self)这种写法，<a class="external-link" href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references/" rel="nofollow">原因如下</a></p>
<p>大致说法是老LLVM编译器会将</strong>typeof转义为 XXX类名 <em>const <strong>strong的</strong>strong和前面的__weak关键字对指针的修饰又冲突了，所以加上&amp;</em>对指针的修饰。</p>
<p>第三行：<strong>strong </strong>typeof(weakSelf)strongSelf = weakSelf;</p>
<p>按照之前第五条的说法给转回strong了，这里__typeof()里面写的是weakSelf，里面写self也没有问题，因为typeof是编译时确定变量类型，所以这里写self 不会被循环引用。</p>
<p>第四、五、六行，如果不转成strongSelf而使用weakSelf，后面几句话中，有可能在第四句执行之后self的对象可能被析构掉，然后后面的StausBlock没有执行，导致逻辑错误。</p>
<p>最后第五行，使用前对block判空。</p>
<p>&nbsp;</p>
<p>写在最后，阅读好的开源库源码是提高个人水平的一个很好途径，看见不懂的地方去查去摸索会得到更多。</p>
<p>&nbsp;</p>
<p>参考：</p>
<p><a class="external-link" href="http://blog.csdn.net/fhbystudy/article/details/17350951" rel="nofollow"><a href="http://blog.csdn.net/fhbystudy/article/details/17350951">http://blog.csdn.net/fhbystudy/article/details/17350951</a></a></p>
<p><a class="external-link" href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references" rel="nofollow"><a href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references">http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references</a></a></p>
<p><a class="external-link" href="http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c" rel="nofollow"><a href="http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c">http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c</a></a></p>
<p><a class="external-link" href="http://rocry.com/2012/12/18/objective-c-type-of/" rel="nofollow"><a href="http://rocry.com/2012/12/18/objective-c-type-of/">http://rocry.com/2012/12/18/objective-c-type-of/</a></a></p>
<p><a class="external-link" href="http://fuckingblocksyntax.com/" rel="nofollow"><a href="http://fuckingblocksyntax.com/">http://fuckingblocksyntax.com/</a></a> 这是个工具网站，我每次写block的时候都会用到。</p>
        <h4 class="title2">
            <a id="cb_post_title_url" class="postTitle3" href="http://www.cnblogs.com/biosli/p/block_usage.html">原文链接(<a href="http://www.cnblogs.com/biosli/p/block_usage.html">http://www.cnblogs.com/biosli/p/block_usage.html</a>)</a>
        </h4>
</div>
<div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd">&nbsp;</div></div><div id="MySignature"></div>
<div class="clear"></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C错误模型]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/objective-ccuo-wu-mo-xing/"/>
    <updated>2016-01-04T11:04:51+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/objective-ccuo-wu-mo-xing</id>
    <content type="html"><![CDATA[<h2>为什么不使用异常处理机制？</h2>

<p>事实上，OC是具备异常处理机制的，但是具体情况下不会启用该机制。原因是ARC下默认不是“异常安全”的。
    理由是,如果抛出异常，那么本应该在作用域末尾释放的对象在现在不能自动释放了。 如果想生成“异常安全”的代码，需要设置编译标志“-fobjc-arc-exceptions”，并且需要引入额外的代码，在不抛出异常时，也照样执行这段代码。
及时不适用ARC，也很难在抛出异常后不会导致内存泄露。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">resource</span> <span class="o">=</span> <span class="p">[</span><span class="n">YCResource</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="k">retain</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="cm">/*有异常发生*/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="k">@throw</span> <span class="p">[</span><span class="bp">NSException</span> <span class="nl">exceptionWithName</span><span class="p">:</span><span class="s">@&quot;/*异常名称*/&quot;</span> <span class="n">reason</span><span class="s">@&quot;/*异常原因*/&quot;</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">[</span><span class="n">resource</span> <span class="n">callSomeMethod</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">resource</span> <span class="k">release</span><span class="p">];</span>   
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>以上代码：如果一旦有异常抛出，那么之后的代码都不会被执行，资源resource对象也就无法被释放。
虽然可以在异常发生前释放资源对象，但是如果需要释放的资源对象非常多，之后又有新的资源加入，往往会忘了在异常前释放新加入的资源。
OC现在所采取的方法是只有在极其罕见的异常下，才抛出异常，异常抛出后不必考虑恢复问题，此时程序应该直接退出，这样就不用在编写复杂的“异常安全”代码了。
现在异常只用于及其严重的错误（致命错误）。
其中一个用途：OC中没有抽象类，所以无法定义抽象方法，此时，如果你想定义一套抽象 的API，那么可以在方法的实现中抛出异常，告诉使用者需要覆写该方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">absructMethd</span> <span class="p">{</span>
</span><span class='line'>  <span class="bp">NSString</span> <span class="n">exceptionReason</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;%@ must be overridden&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">)];</span>
</span><span class='line'>  <span class="k">@throw</span> <span class="p">[</span><span class="bp">NSException</span> <span class="nl">exceptionWithName</span><span class="p">:</span><span class="n">NSInternalInnconsistencyException</span> <span class="nl">reson</span><span class="p">:</span><span class="n">exceptionReason</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>如何处理“不那么严重（非致命）”的错误？</h2>

<p>OC的范式是：另方法返回0/nil，或者使用NSError。</p>

<h2>如何使用<code>NSError</code>？</h2>

<p>NSErrow使用起来非常灵活，我们使用它告诉调用者发生了什么错误。
NSError构成：
* Error domain(错误范围)
描述错误发生的范围。例如处理URL的子系统，当url解析出现错误，就可以使用<code>NSURLErrorDomain</code>来表示错误范围。
* Error code（错误码）
独有的错误代码，用以表明具体发生了何种错误，一般用枚举定义，HTTP请求中可以存储状态码。
* User info（用户信息）
有关错误的额外附加信息，可以是一段本地化描述，也可能是用来存储该错误是由其他错误引起的，最终生成一条完整的错误链。</p>

<p>其应用场景类型：
* 在代理协议中返回NSError错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">connection:</span><span class="p">(</span><span class="bp">NSURLConnection</span> <span class="o">*</span><span class="p">)</span><span class="nv">connection</span> <span class="nf">didFailWithError:</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">-</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，接口定义者和使用者都可以选择是否输入并处理该错误。
* 在方法中用对象指针来监测错误。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doSomething:</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">**</span><span class="p">)</span><span class="nv">error</span><span class="p">;</span>
</span><span class='line'><span class="cm">/*使用方法*/</span>
</span><span class='line'><span class="bp">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">slef</span> <span class="nl">doSomething</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 处理错误</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种方法一般都会返回BOOL值，用来判断是否操作成功，如果只是判断成功状态，则只要判断返回值并且error参数传为nil就行，而error指针可以用来输出错误信息。
<code>
笔记：实际上ARC时，编译器会把NSError**转换为NSError*__autorelease*</code>,当doSomething方法执行完毕后，会将调用者创建的对象自动释放掉。这是为了防止调用者不一定能确保会释放掉NSError对象，必须要求他自己可以自动释放掉，所以加入autorelease。这样就与打部分返回值具备的语义相同了。</p>

<p>doSomething方法的实现原理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doSomething:</span><span class="p">(</span><span class="bp">NSError</span> <span class="o">*</span><span class="p">)</span><span class="nv">error</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="cm">/*发生error*/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="k">if</span><span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>              <span class="cm">/*给外部传入参数初始化*/</span>
</span><span class='line'>              <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSError</span> <span class="nl">errorWithDomain</span><span class="p">:</span><span class="n">domain</span> <span class="nl">code</span><span class="p">:</span><span class="n">code</span> <span class="nl">userinfo</span><span class="p">:</span><span class="n">userInfo</span><span class="p">];</span>
</span><span class='line'>              <span class="p">}</span>
</span><span class='line'>              <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>              <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在给error解引用&ndash;<code>*error</code>之前，必须保证error不为空。</p>

<p>一般情况下，给error对象填入恰当的错误范围，错误码，错误信息后，调用者就可以更精准的定位错误。
我们一般对错误范围使用NSString全局变量进行定义。错误码常采用枚举，例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">extern</span> <span class="n">NSSring</span> <span class="o">*</span><span class="k">const</span> <span class="n">YCErrorDomain</span><span class="p">;</span>
</span><span class='line'><span class="k">typedef</span> <span class="n">NS_ENUM</span><span class="err">（</span><span class="bp">NSInteger</span><span class="p">,</span> <span class="n">YCError</span><span class="err">）</span><span class="p">{</span>
</span><span class='line'>  <span class="n">YCErrorUnknow</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="n">YCErrorInternalIncosistency</span>  <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
</span><span class='line'>  <span class="n">YCErrorGeneralFault</span>  <span class="o">=</span> <span class="mi">105</span><span class="p">,</span>
</span><span class='line'>  <span class="n">YCErrorBadInput</span>  <span class="o">=</span> <span class="mi">500</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="k">const</span> <span class="n">YCErrorDomain</span> <span class="o">=</span> <span class="s">@&quot;YCErrorDomain&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy New Year]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/02/happy-new-year/"/>
    <updated>2016-01-02T01:15:36+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/02/happy-new-year</id>
    <content type="html"><![CDATA[<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/source/images/ios/2016/1/IMG_1433.jpg?raw=true" title="小雪人" alt="小雪人" /></p>

<!--more-->


<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/source/images/ios/2016/1/IMG_1049.jpg?raw=true" title="zulan" alt="zulan" />
<img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/source/images/ios/2016/1/IMG_1358.jpg?raw=true" title="xiaojun" alt="xiojun" />
　　又迎来的新的一年，回想过去的一年，充实而精彩，感谢<strong>小君</strong>，感谢陪在我身边的每一个朋友，我的勇气和动力的源泉。致正在前往2016的追梦者们！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Harpy（版本更新工具)制做兼容版本]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/01/wei-harpy(ban-ben-geng-xin-gong-ju-zhi-zuo-jian-rong-ban-ben-)/"/>
    <updated>2016-01-01T03:58:09+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/01/wei-harpy(ban-ben-geng-xin-gong-ju-zhi-zuo-jian-rong-ban-ben-)</id>
    <content type="html"><![CDATA[<p><strong>中文版：</strong></p>

<h1>Harpy (兼容版本)</h1>

<p>github:<a href="https://github.com/yangchao0033/Harpy">https://github.com/yangchao0033/Harpy</a></p>

<h3>(iOS5-9适配版本,基于<a href="https://github.com/ArtSabintsev/Harpy">ArtSabintsev/Harpy v3.4.5</a>)</h3>

<h3>提醒用户你的应用有新的可用版本，并且及时的跳转到App Store进行更新。</h3>

<h2>关于</h2>

<p><strong>Harpy</strong> 将用户手机上已安装的iOS app版本与当前App Store最新可用版本进行检查对比。如果有新的可用版本时，使用弹窗及时提醒用户最新版本信息，并然用户选择是否需要进一步操作。</p>

<!--more-->


<p>Harry是基于<a href="Semantic%20Versioning">http://www.semver.org</a>版本号系统标准执行。
- <code>Semantic Versioning</code>是一个三位数的版本号系统（例如:1.0.0）
- Harry同样支持2位数的版本号(例如:1.0)
- Harpy同时支持4位数的版本号（例如:1.0.0.0）</p>

<h2>Swift 支持</h2>

<p>当前兼容版本（iOS5-9）暂时不支持swift</p>

<h2>特点</h2>

<!--- [x] CocoaPods Support-->


<ul>
<li>[x] 支持三种类型的弹框样式 (详见 <strong>截图 &amp; Alert Types</strong>)</li>
<li>[x] 提供可选的代理方法 (详见 <strong>Optional Delegate</strong> section)</li>
<li>[x] 本地化支持超过20+语言</li>
</ul>


<h2>屏幕截图</h2>

<ul>
<li><strong>左图：</strong>强制用户更新app</li>
<li><strong>中图：</strong>提供可选项是否前往更新</li>
<li><strong>右图：</strong>提供跳过当前版本更新的选项</li>
<li>这些样式全部可以通过<code>HarpyAletType</code>枚举进行控制，详见<code>Harpy.h</code></li>
</ul>


<p><img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/4.pic.jpg?raw=true" title="Forced Update" alt="Forced Update" />
<img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/5.pic.jpg?raw=true" title="Optional Update" alt="Optional Update" />
<img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/3.pic.jpg?raw=true" title="Optional Update" alt="Skipped Update" /></p>

<h2>安装</h2>

<h3>手动安装（正在准备CocoaPods）</h3>

<p>将‘Harpy’文件夹拖入到你的项目中，并选择'copy if needed',包括 <code>Harpy.h</code> 和 <code>Harpy.m</code> 文件</p>

<h2>配置</h2>

<ol>
<li>import <strong>Harpy.h</strong> 导入到 AppDelefate 类中 或者 Pre-Complier Header(.pch)文件中</li>
<li>在你的<code>Appdelegate</code>中设置<strong>appID</strong>（必要），设置你的<strong>alertType</strong>（可选）</li>
<li>在你的<code>Appdelegate</code>中调用<code>checkVersion</code>方法，三个检测方法调用位置分别位于Appdelegate的启动的代理方法中，可以自行选择使用

<ul>
<li>在 <code>application:didFinishLaunchingWithOptions:</code> 中调用 <code>checkVersion</code></li>
<li>在 <code>applicationDidBecomeActive:</code> 中调用 <code>checkVersionDaily</code></li>
<li>在 <code>applicationDidBecomeActive:</code> 中调用 <code>checkVersionWeekly</code> .</li>
</ul>
</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 启用Harpy之前确保你的window可用</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">window</span> <span class="n">makeKeyAndVisible</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 为你的应用设置app id</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setAppID</span><span class="p">:</span><span class="s">@&quot;&lt;#app_id#&gt;&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 设置 UIAlertController 将要基于哪个控制器显示 （适配iOS8+）</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setPresentingViewController</span><span class="p">:</span><span class="n">_window</span><span class="p">.</span><span class="n">rootViewController</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// (可选)设置代理来追踪用户点击事件，活着的使用自定义的界面来展示你的信息</span>
</span><span class='line'>      <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">// (可选) 设置alertController的tincolor（iOS8+可用）</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setAlertControllerTintColor</span><span class="p">:</span><span class="s">@&quot;&lt;#alert_controller_tint_color#&gt;&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// (可选) 设置你的应用名</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setAppName</span><span class="p">:</span><span class="s">@&quot;&lt;#app_name#&gt;&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="cm">/* （可选）设置弹框类型 默认为HarpyAlertTypeOption */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="cm">/* (可选)如果你的应用只在某些国家或地区可用，你必须使用两个字符的country code来设置应用的可用区域 */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setCountryCode</span><span class="p">:</span><span class="s">@&quot;&lt;#country_code#&gt;&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* (可选) 强制指定应用显示语言, 请使用 Harpy.h 中定义的 HarpyLanguage 进行设置。*/</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setForceLanguageLocalization</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">HarpyLanguageConstant</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 执行版本检测</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">checkVersion</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">applicationDidBecomeActive:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">     执行每天检测你的app是否需要更新版本，需要在`applicationDidBecomeActive:`执行最合适</span>
</span><span class='line'><span class="cm">     因为这对于的你的应用进如后台很长时间后非常有用。</span>
</span><span class='line'><span class="cm">     </span>
</span><span class='line'><span class="cm">     同时，也会在应用第一次启动时执行版本检测</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">checkVersionDaily</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">     执行每周检测你的app新版本。同理需要将此代码放置在`applicationDidBecomeActive:`中执行。</span>
</span><span class='line'>
</span><span class='line'><span class="cm">     同时，也会在应用第一次启动时执行版本检测</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">checkVersionWeekly</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">applicationWillEnterForeground:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">  执行app新版本检测，放在此是为了让用户从App Sore跳转回来并重新从后台进入你的</span>
</span><span class='line'><span class="cm">  app，并且没有在从App Store中跳转回来之前更新他们app的时候调用</span>
</span><span class='line'><span class="cm">  </span>
</span><span class='line'><span class="cm">  注意：只有当你使用*HarpyAlertTypeForce*样式弹框类型是才使用这种方法</span>
</span><span class='line'>
</span><span class='line'><span class="cm"> 并且会在你第一次启动应用时检测。</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">checkVersion</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
至此设置全部完成！</p>

<h2>为不同的升级类型设置弹窗样式</h2>

<p>如果你喜欢为不同的升级类型比如修改(revision)，补丁(patch)，轻微改动(minor)，重大修改(major)等升级类型仅仅添加下面的几行可选代码即可，添加位置必须在调用版本检查的方法（checkVersion）之前</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="cm">/* 默认情况下Harpy会设置所有的版本升级样式为HarpyAlertTypeOption */</span>
</span><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setPatchUpdateAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setMinorUpdateAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setMajorUpdateAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setRevisionUpdateAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>可选的代理和代理方法</h2>

<p>如果你想要个处理或者追踪终端用户的的行为，Harpy会为你提供四个代理方法进行监控</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="c1">// 用户界面展示升级提示对话框</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyDidShowUpdateDialog</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用户已经点击升级按钮并且进入到App Sotore</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyUserDidLaunchAppStore</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用户已经点击跳过此次版本更新</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyUserDidSkipVersion</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用户已经点击取消更行对话框</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyUserDidCancel</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you would like to use your own UI, please use the following delegate method to obtain the localized update message if a new version is available:
如果你想使用自己的UI，如果有可用的新版本，使用下面的代理来获得本地化的升级信息（需要设置AlertTpye为HarpyAlertTypeNone）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyDidDetectNewVersionWithoutAlert:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">message</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>强制本地化</h2>

<p>Harpy 已经本地化了的语言包括 Arabic, Basque, 简体中文, 繁体中文, Danish, Dutch, English, Estonian, French, German, Hebrew, Hungarian, Italian, Japanese, Korean, Latvian, Lithuanian, Malay, Polish, Portuguese (Brazil), Portuguese (Portugal), Russian, Slovenian, Swedish, Spanish, Thai, and Turkish.</p>

<p>你可能想要你的升级对话框<em>永远</em>显示正确的语言，而忽略iOS的语言设置（比如在指定国家发行的app）</p>

<p>你可以使用以下代码实现强制本地化</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">setForceLanguageLocalization</span><span class="o">&lt;</span><span class="err">#</span><span class="n">HarpyLanguageConstant</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>在App Store上提交的重要注意事项</h2>

<p>App Store 审核人员将不会看到升级弹框</p>

<p><strong>English</strong>：</p>

<h1>Harpy（Compatible version Base On <a href="https://github.com/ArtSabintsev/Harpy">ArtSabintsev/Harpy v3.4.5</a>）</h1>

<h3>Notify users when a new version of your app is available, and prompt them with the App Store link.</h3>

<hr />

<h2>About</h2>

<p><strong>Harpy</strong> checks a user&rsquo;s currently installed version of your iOS app against the version that is currently available in the App Store. If a new version is available, an alert can be presented to the user informing them of the newer version, and giving them the option to update the application.</p>

<p>Harpy is built to work with the <a href="Semantic%20Versioning">http://www.semver.org</a> system.
- Semantic Versioning is a three number versioning system (e.g., 1.0.0)
- Harpy also supports two-number versioning (e.g., 1.0)
- Harpy also supports four-number versioning (e.g., 1.0.0.0)</p>

<h2>Swift Support</h2>

<ul>
<li>not support yet</li>
</ul>


<h2>Features</h2>

<!--- [x] CocoaPods Support-->


<ul>
<li>[x] Three types of alerts (see <strong>Screenshots &amp; Alert Types</strong>)</li>
<li>[x] Optional delegate methods (see <strong>Optional Delegate</strong> section)</li>
<li>[x] Localized for 20+ languages</li>
</ul>


<h2>Screenshots</h2>

<ul>
<li>The <strong>left picture</strong> forces the user to update the app.</li>
<li>The <strong>center picture</strong> gives the user the option to update the app.</li>
<li>The <strong>right picture</strong> gives the user the option to skip the current update.</li>
<li>These options are controlled by the <code>HarpyAlertType</code> typede that is found in <code>Harpy.h</code>.</li>
</ul>


<p><img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picForcedUpdate.png?raw=true" title="Forced Update" alt="Forced Update" />
<img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picOptionalUpdate.png?raw=true" title="Optional Update" alt="Optional Update" />
<img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picSkippedUpdate.png?raw=true" title="Optional Update" alt="Skipped Update" /></p>

<h2>Installation Instructions</h2>

<!--### CocoaPods Installation
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="n">pod</span> <span class="err">&#39;</span><span class="n">Harpy</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>-->


<h3>Manual Installation</h3>

<p>Copy the &lsquo;Harpy&rsquo; folder into your Xcode project. It contains the Harpy.h and Harpy.m files.</p>

<h2>Setup</h2>

<ol>
<li>Import <strong>Harpy.h</strong> into your AppDelegate or Pre-Compiler Header (.pch)</li>
<li>In your <code>AppDelegate</code>, set the <strong>appID</strong>, and optionally, you can set the <strong>alertType</strong>.</li>
<li>In your <code>AppDelegate</code>, call <strong>only one</strong> of the <code>checkVersion</code> methods, as all three perform a check on your application&rsquo;s first launch. Use either:

<ul>
<li><code>checkVersion</code> in <code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>checkVersionDaily</code> in <code>applicationDidBecomeActive:</code>.</li>
<li><code>checkVersionWeekly</code> in <code>applicationDidBecomeActive:</code>.</li>
</ul>
</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Present Window before calling Harpy</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">window</span> <span class="n">makeKeyAndVisible</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Set the App ID for your app</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setAppID</span><span class="p">:</span><span class="s">@&quot;&lt;#app_id#&gt;&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Set the UIViewController that will present an instance of UIAlertController</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setPresentingViewController</span><span class="p">:</span><span class="n">_window</span><span class="p">.</span><span class="n">rootViewController</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// (Optional) Set the Delegate to track what a user clicked on, or to use a custom UI to present your message.</span>
</span><span class='line'>      <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// (Optional) The tintColor for the alertController</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setAlertControllerTintColor</span><span class="p">:</span><span class="s">@&quot;&lt;#alert_controller_tint_color#&gt;&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// (Optional) Set the App Name for your app</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setAppName</span><span class="p">:</span><span class="s">@&quot;&lt;#app_name#&gt;&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* (Optional) Set the Alert Type for your app</span>
</span><span class='line'><span class="cm">  By default, Harpy is configured to use HarpyAlertTypeOption */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* (Optional) If your application is not available in the U.S. App Store, you must specify the two-letter</span>
</span><span class='line'><span class="cm">  country code for the region in which your applicaiton is available. */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setCountryCode</span><span class="p">:</span><span class="s">@&quot;&lt;#country_code#&gt;&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/* (Optional) Overrides system language to predefined language.</span>
</span><span class='line'><span class="cm">  Please use the HarpyLanguage constants defined in Harpy.h. */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setForceLanguageLocalization</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">HarpyLanguageConstant</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Perform check for new version of your app</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">checkVersion</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">applicationDidBecomeActive:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">  Perform daily check for new version of your app</span>
</span><span class='line'><span class="cm">  Useful if user returns to you app from background after extended period of time</span>
</span><span class='line'><span class="cm">      Place in applicationDidBecomeActive:</span>
</span><span class='line'>
</span><span class='line'><span class="cm">      Also, performs version check on first launch.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">checkVersionDaily</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">  Perform weekly check for new version of your app</span>
</span><span class='line'><span class="cm">  Useful if you user returns to your app from background after extended period of time</span>
</span><span class='line'><span class="cm">  Place in applicationDidBecomeActive:</span>
</span><span class='line'>
</span><span class='line'><span class="cm">  Also, performs version check on first launch.</span>
</span><span class='line'><span class="cm">  */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">checkVersionWeekly</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">applicationWillEnterForeground:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="cm">/*</span>
</span><span class='line'><span class="cm">  Perform check for new version of your app</span>
</span><span class='line'><span class="cm">  Useful if user returns to you app from background after being sent tot he App Store,</span>
</span><span class='line'><span class="cm">  but doesn&#39;t update their app before coming back to your app.</span>
</span><span class='line'>
</span><span class='line'><span class="cm">      ONLY USE THIS IF YOU ARE USING *HarpyAlertTypeForce*</span>
</span><span class='line'>
</span><span class='line'><span class="cm">      Also, performs version check on first launch.</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">checkVersion</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>And you&rsquo;re all set!</p>

<h2>Differentiated Alerts for Patch, Minor, and Major Updates</h2>

<p>If you would like to set a different type of alert for revision, patch, minor, and/or major updates, simply add one or all of the following <em>optional</em> lines to your setup <em>before</em> calling any of the <code>checkVersion</code> methods:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="cm">/* By default, Harpy is configured to use HarpyAlertTypeOption for all version updates */</span>
</span><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setPatchUpdateAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setMinorUpdateAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setMajorUpdateAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">setRevisionUpdateAlertType</span><span class="p">:</span><span class="o">&lt;</span><span class="err">#</span><span class="n">alert_type</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Optional Delegate and Delegate Methods</h2>

<p>If you&rsquo;d like to handle or track the end-user&rsquo;s behavior, four delegate methods have been made available to you:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="c1">// User presented with update dialog</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyDidShowUpdateDialog</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// User did click on button that launched App Store.app</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyUserDidLaunchAppStore</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// User did click on button that skips version update</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyUserDidSkipVersion</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// User did click on button that cancels update dialog</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyUserDidCancel</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you would like to use your own UI, please use the following delegate method to obtain the localized update message if a new version is available:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">harpyDidDetectNewVersionWithoutAlert:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">message</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Force Localization</h2>

<p>Harpy has localizations for Arabic, Basque, Chinese (Simplified), Chinese (Traditional), Danish, Dutch, English, Estonian, French, German, Hebrew, Hungarian, Italian, Japanese, Korean, Latvian, Lithuanian, Malay, Polish, Portuguese (Brazil), Portuguese (Portugal), Russian, Slovenian, Swedish, Spanish, Thai, and Turkish.</p>

<p>You may want the update dialog to <em>always</em> appear in a certain language, ignoring iOS&rsquo;s language setting (e.g. apps released in a specific country).</p>

<p>You can enable it like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='obj-c'><span class='line'><span class="p">[[</span><span class="n">Harpy</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="n">setForceLanguageLocalization</span><span class="o">&lt;</span><span class="err">#</span><span class="n">HarpyLanguageConstant</span><span class="err">#</span><span class="o">&gt;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Important Note on App Store Submissions</h2>

<p>The App Store reviewer will <strong>not</strong> see the alert.</p>

<h2>Created and maintained by</h2>

<p><a href="http://www.sabintsev.com/">Arthur Ariel Sabintsev</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MPMovieplayerviewcontroller播放结束后自动消失的解决方案]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/01/mpmovieplayerviewcontrollerbo-fang-jie-shu-hou-zi-dong-xiao-shi-de-jie-jue-fang-an/"/>
    <updated>2016-01-01T03:30:11+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/01/mpmovieplayerviewcontrollerbo-fang-jie-shu-hou-zi-dong-xiao-shi-de-jie-jue-fang-an</id>
    <content type="html"><![CDATA[<hr />

<p>你可以使用这段代码来阻止控制器播放在播放结束后自动dismissing（消失），并且捕捉到用户点击完成的按钮事件去自己定义并处理让你的MPMoviePlayerViewController播放器的消失（dismiss）的时机</p>

<!--more-->


<hr />

<p>步骤 1. - 创建并初始化一个MPMoviePlayerViewController（videoPlayer）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">MPMoviePlayerViewController</span> <span class="o">*</span><span class="n">videoPlayer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">MPMoviePlayerViewController</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithContentURL</span><span class="p">:[[</span><span class="bp">NSURL</span> <span class="n">alloc</span> <span class="p">]</span><span class="nl">initWithString</span><span class="p">:[</span><span class="n">aURL</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤 2. - 移除videoPlayer默认的通知事件并且加入自己的通知事件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="bp">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">removeObserver</span><span class="p">:</span><span class="n">videoPlayer</span>
</span><span class='line'><span class="nl">name</span><span class="p">:</span><span class="n">MPMoviePlayerPlaybackDidFinishNotification</span> <span class="nl">object</span><span class="p">:</span><span class="n">videoPlayer</span><span class="p">.</span><span class="n">moviePlayer</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="bp">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserver</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'><span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">videoFinished</span><span class="p">:)</span> <span class="nl">name</span><span class="p">:</span><span class="n">MPMoviePlayerPlaybackDidFinishNotification</span> <span class="nl">object</span><span class="p">:</span><span class="n">videoPlayer</span><span class="p">.</span><span class="n">moviePlayer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤 3. - 手动显示你的videoPlayer控制器</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="nb">self</span> <span class="nl">presentMoviePlayerViewControllerAnimated</span><span class="p">:</span><span class="n">videoPlayer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤 4. - 添加 videoFinish: 方法处理通知事件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">videoFinished:</span><span class="p">(</span><span class="bp">NSNotification</span><span class="o">*</span><span class="p">)</span><span class="nv">aNotification</span><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="p">[[</span><span class="n">aNotification</span><span class="p">.</span><span class="n">userInfo</span> <span class="nl">valueForKey</span><span class="p">:</span><span class="n">MPMoviePlayerPlaybackDidFinishReasonUserInfoKey</span><span class="p">]</span> <span class="n">intValue</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="n">MPMovieFinishReasonUserExited</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="n">dismissMoviePlayerViewControllerAnimated</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<hr />

<p>参考:<a href="http://stackoverflow.com/a/19596598">http://stackoverflow.com/a/19596598</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于@autoreleasepool的性能测试及手动释放自动释放池]]></title>
    <link href="http://yangchao0033.github.io/blog/2015/12/31/guan-yu-at-autoreleasepoolde-ce-shi-ji-shi-yong/"/>
    <updated>2015-12-31T11:47:01+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2015/12/31/guan-yu-at-autoreleasepoolde-ce-shi-ji-shi-yong</id>
    <content type="html"><![CDATA[<p>首先，我们先对使用autoreleasepool的场景进行性能对比。</p>

<ul>
<li>不用autoreleasepool</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomething</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">collection</span> <span class="o">=</span> <span class="l">@[]</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mf">10e6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;hi + %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">collection</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">str</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;finished!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<!--more-->


<p>不使用性能如下如所示：
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/11/image/Snip20151108_9.png?raw=true" alt="不使用" /></p>

<ul>
<li>使用autoreleasepool</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomething</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">collection</span> <span class="o">=</span> <span class="l">@[]</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mf">10e6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>          <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;hi + %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">collection</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">str</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;finished!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
使用效果如下图所示：
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/11/image/Snip20151108_8.png?raw=true" alt="使用autoreleasepool" /></p>

<p>综上，当需要在程序中创建大量的临时变量时（大量也可指数量多，不确定，比如从数据库中读取数据时）,很容易使内存产生峰值又回到内存低谷，这样对程序的性能会产生很大影响，而使用自动释放池后，峰值明显有所下降。<br/>
<code>原因：</code>由于在mian函数中已经为我们添加了自动释放池，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>
</span><span class='line'><span class="cp">#import &quot;AppDelegate.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="k">class</span><span class="p">]));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而当autoreleasepool的右括号结束后，会对整个autoreleasepool做一次倾倒。但是这会使其中局部产生的大量零时变量无法及时释放，直到for循环结束后抵达main中autoreleasepool的右括号位置才能释放。这样会在局部位置发生内存峰值。
官方提出的解决方案是，在大量产生局部变量的位置用autoreleasepool代码块进行包装。比如for循环中要执行的语句，这样每次for循环结束后就会及时收回临时变量占用的内存空间。</p>

<h1>思考：如何在指定的次数时，及时释放自动释放池中的临时变量</h1>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="err">使用</span><span class="n">mrc</span><span class="err">下的特性</span>
</span><span class='line'><span class="err">在编译选项中，为</span><span class="n">MRC</span><span class="err">的程序添加</span><span class="o">-</span><span class="n">fno</span><span class="o">-</span><span class="n">objc</span><span class="o">-</span><span class="n">arc</span><span class="err">标记，表明在编译时，该文件使用</span><span class="n">MRC</span><span class="err">编译</span>
</span><span class='line'><span class="err">如果要在</span><span class="n">MRC</span><span class="err">项目中添加</span><span class="n">ARC</span><span class="err">的文件，可以使用</span> <span class="o">-</span><span class="n">fobjc</span><span class="o">-</span><span class="n">arc</span> <span class="err">标记即可</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的需求我们可以使用MRC时代的一个重量级的自动释放池，通常用来创建偶尔需要释放清空的池。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomething</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">collection</span> <span class="o">=</span> <span class="l">@[]</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSAutoreleasePool</span> <span class="o">*</span><span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mf">10e6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="bp">NSString</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;hi + %d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">collection</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">str</span><span class="p">];</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">count</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="cm">/** 每一百次倾倒一次池子 */</span>
</span><span class='line'>            <span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>
</span><span class='line'>            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="cm">/** 用来倾倒当i的个数不是100的倍数时，比如读取数据库数据时,数据总数为不确定值 */</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pool</span> <span class="n">drain</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;finished!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于在storyboard中使用静态cell的注意事项]]></title>
    <link href="http://yangchao0033.github.io/blog/2015/12/30/guan-yu-zai-storyboardzhong-shi-yong-jing-tai-cellde-zhu-yi-shi-xiang/"/>
    <updated>2015-12-30T15:26:05+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2015/12/30/guan-yu-zai-storyboardzhong-shi-yong-jing-tai-cellde-zhu-yi-shi-xiang</id>
    <content type="html"><![CDATA[<p> &ndash;关于在<em>storyboard</em>中使用静态TableViewCell的可变高度的使用技巧</p>

<p>起因:在storyboard使用之前，创建tableView视图，通常是采用代码控制数据源，通过数据源数据的长度来决定tableView中cell的个数，而这样做的好处还有就是可以通过将已经在界面中展示的cell放入缓存池中，以供后续数据展示再从缓存池中取出进行复用。这样做的好处是为了防止数据过大时创建大量的cell浪费不必要的空间。显而易见，tableView就是为了进行批量数据的展示。</p>

<!--more-->


<p> <br/>
然而，在现实开发中，会出现一种需求：展示的数据长度是确定的，而且需要向tableView一样实现视图上下滚动，单个cell视图可点击响应。这种情况下，继续使用原来的代码数据源控制一样可以实现，这时的数据源个数是确定的。即便如此，你也需要考虑处理cell滚动时发生的重用所带来的影响。而且当数据源确定时，你的产品经理绝对不甘于像平常一样每条数据都展示为同一个尺寸内容。而是会尽可能地在每个cell中加入丰富的控件，时间相应来是有限的tableView实现最为复杂的用户交互事件。此时，你会在自己的数据源拼命地书写if语句来保证视图的正确显示，又要避免发生未知的cell重用问题。<br/>
这样做是可行的，但是在主要时间将大量花费在处理有限个数cell上的逻辑处理，而并非我们所要实现的主要业务。<br/>
所以，在这种情况下，我们会考虑把这些重复而且无用的逻辑处理交给苹果自己搞定（当然，主要目的是为了偷懒^_^）<br/>
static cell，这是苹果为我们提供的解决方案。目前仅限于在storyboard中使用。</p>

<p> <code>static cell</code>的用法非常简单，这里不作为重点赘述，请大家自行学习。<br/>
  现在给大家这样一个场景，在你用<code>static cell</code>搭建好界面，然后轻松加愉快的拖拖控件，完成相关业务功能。<br/>
  上面老板开始验收项目，对产品  说你的界面不够详细，再改改。<br/>
  产品开始提需求，说我们的cell内容太少，需要在点击时展开详情。<br/>
  而恰好你用静态单元cell偷了个懒，现在要为了一个cell重新用动态cell写一遍？<br/>
  别闹了，明天还要和UI妹子去爬香山呢，绝壁不当加班狗。<br/>
  所以，我们开始探索静态cell的高度改变之旅。</p>

<hr />

<p>  方案一：
  既然我们可以将静态cell当做一个控件拖入控制器做属性。何不在代码中修改作为属性的静态cell的高度呢？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="nb">self</span><span class="p">.</span><span class="n">fuJianCell</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>     
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">fuJianCell</span> <span class="n">layoutIfNeeded</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">tableView</span> <span class="n">reloadData</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>然并卵，这些方法对非cell的控件来说刷新高度足矣，然而<code>tableView</code>的高度始终是由代理来控制的，所以这样修改是没用的。<br/>
既然这样，我们就从高度代理入手。</p>

<hr />

<p>方案二：
通过代理入手，将每个cell的在storyBoard的设置高度用代码写到一个数组中，并通过代理返回。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="bp">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">heightForRowAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 变高行数</span>
</span><span class='line'>  <span class="bp">NSInteger</span> <span class="n">mutableHeightRow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 如果不展开</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">isOpen</span><span class="p">){</span>
</span><span class='line'>      <span class="nb">self</span><span class="p">.</span><span class="n">heights</span><span class="p">[</span><span class="n">mutableHeightRow</span><span class="p">]</span> <span class="o">=</span> <span class="l">@(</span><span class="err">原始高度</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">heights</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span> <span class="n">integerValue</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="nb">self</span><span class="p">.</span><span class="n">heights</span><span class="p">[</span><span class="n">mutableHeightRow</span><span class="p">]</span> <span class="o">=</span> <span class="l">@(</span><span class="err">展开高度</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">heights</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span> <span class="n">integerValue</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>问题解决，但是违背了我们的初衷，说好的交给苹果自己算呢，为毛要手动将高度存在数组中？</p>

<hr />

<p>方案三：
交给tableView的父类方法返回我们在storyboard中预设的高度，然后单独处理变高的cell高度</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="bp">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">heightForRowAtIndexPath:</span><span class="p">(</span><span class="bp">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 变高行数</span>
</span><span class='line'>  <span class="bp">NSInteger</span> <span class="n">mutableHeightRow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span> <span class="o">==</span> <span class="n">mutableHeightRow</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isOpen</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 假设改行原来高度为200</span>
</span><span class='line'>          <span class="k">return</span> <span class="mi">80</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">tableView</span><span class="p">:</span><span class="n">tableView</span> <span class="nl">heightForRowAtIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/** 返回静态单元格故事板中的高度 */</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">tableView</span><span class="p">:</span><span class="n">tableView</span> <span class="nl">heightForRowAtIndexPath</span><span class="p">:</span><span class="n">indexPath</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>完美~</p>

<hr />

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 注意别忘了,在修改展开状态的时候刷新表格</span>
</span><span class='line'>  <span class="n">isOpen</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">tableView</span> <span class="n">reloadData</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实，这样处理静态cell的方式不光可以处理可变高度，还可以用在数据源的section个数或者每个section的row的个数上，再或者指定让某个位置的cell使用动态cell其他使用静态cell，让我们的静态cell比动态cell更好用。其方法都是通过<code>super</code>关键字调用父类方法返回storyboard中存储的的相关数据。</p>

<p>至于原理，暂时还不清楚，推测使用了运行时动态创建一个支持静态cell的tableView的子类，我们实际使用的是这个新的tableView类的实例，或者使用<code>类簇</code>，利用私有子类进行了相关的静态cell的逻辑处理。</p>

<p>总之，这让我们省去了很多处理逻辑的代码。</p>

<p>参考文章：<a href="http://codego.net/513617/">UITableView的：在处理混合cell表视图的静态和动态的cell小区选择</a></p>
]]></content>
  </entry>
  
</feed>
