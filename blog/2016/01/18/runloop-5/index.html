
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>RunLoop深度探究（五） - SuperYang`s Blog</title>
  <meta name="author" content="Super Yang">

  
  <meta name="description" content="接RunLoop深度探究(四) 使用 Run Loop 对象 一个 run loop 对象提供了一些主要接口用于向你的 run loop 中添加 input source ，timers， 和run loop observer，并且运行它。每一条线程有且只有一个run loop 与他相关联。在 &hellip;">
  <meta name="keywords" content="RunLoop, 官方译文, RunLoop深度探究">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yangchao0033.github.io/blog/2016/01/18/runloop-5/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="SuperYang`s Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!--<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>-->
  <script src="/javascripts/libs/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<!--百度追踪-->
<meta name="baidu-site-verification" content="RnO2PmZzv2" />
<meta name="baidu-site-verification" content="T7BiPPFzd4" />
<!--360追踪-->
<meta name="360-site-verification" content="c48c953af335a6c42f6e8f513d6b8a1e" />
<!--百度统计-->
<!--gitcafe-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?3f90170c73d1d919d9eb146c23ba78c7";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!--github-->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?6ce46f4b58d4b7c27a0b77a627fdbdd5";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71812998-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71812998-1', 'auto');
  ga('send', 'pageview');

</script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">SuperYang`s Blog</a></h1>
  
    <h2>Coding Everything.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="yangchao0033.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">文章列表</a></li>
  <li><a href="http://weibo.com/u/3266043817">我的微博</a></li>
  <li><a href="https://github.com/yangchao0033">Github</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">RunLoop深度探究（五）</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-18T12:34:58+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:34 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p> 接<a href="http://superyang.gitcafe.io/blog/2016/01/08/runloopshen-du-tan-jiu-(4)/">RunLoop深度探究(四)</a></p>

<h2>使用 Run Loop 对象</h2>

<p>一个 run loop 对象提供了一些主要接口用于向你的 run loop 中添加 input source ，timers， 和run loop observer，并且运行它。每一条线程有且只有一个run loop 与他相关联。在 Cocoa 中，这个对象是 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 类的一个实例。在底层的应用中，它是指向 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/tdef/CFRunLoopRef">CFRunLoopRef</a> 这种不透明类型的一个指针。</p>

<h2>获取 Run Loop 对象</h2>

<p>你需要使用以下其中之一来获取当前线程的 Run Loop ：</p>

<!--more-->


<ul>
<li>在 Cocoa 中，使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 的类方法 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/clm/NSRunLoop/currentRunLoop">currentRunLoop</a> 去拿到一个 <code>NSRunLoop</code> 对象。</li>
<li>使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopGetCurrent">CFRunLoopGetCurrent</a> 函数。</li>
</ul>


<p>尽管这两种方法不是 <a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">toll-free bridged type</a>(在Foundation 和 Core Foundation 中拥有等价替换接口的能力的类型)的类型,但是如果你需要可以从 <code>NSRunLoop</code> 对象里拿到 CFRunLoopRef 这种<code>不透明类型</code>(苹果封装在内部的C语言类型)。<code>NSRunLoop</code> 类定义了 <code>getCFRunLoop</code> 方法用来返回一个可以传入到 Core Foundation 代码中的 <code>CFRunLoopRef</code> 类型的C语言指针对象（结构体指针）。这两种对象都可以来自于同一个 run loop，你可以根据你的需要来选择具体使用 <code>NSRunLoop</code> 和 <code>CFRunLoopRef</code> 这两种对象的哪一种。</p>

<h2>配置 Run Loop</h2>

<p>在你运行一个子线程的 run loop 之前，你必须向其添加至少一个 input source 或者 timer。如果 run loop 没有任何需要监视的 source， 它将会在你尝试运行它的时候立即退出。请参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7">配置RunLoop Sounce</a>（本文接下来的章节将有介绍）。</p>

<p>除了安装 source，你还可以 run loop observer 并且使用他们检测 runloop的处于不同执行阶段。为了安装 run loop observer ，你需要创建一个 CFRunLoopObserverRef 不透明类型的指针并使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddObserver">CFRunLoopAddObserver</a> 函数将 Observer 添加到你的 run loop 中去，Run Loop Observer 必须使用 Core Foundation 框架接口创建，在 Cocoa 应用中也一样。</p>

<p>表 3-1 展示了在线程 runloop 中，添加 run loop Observer 的主要代码流程。本例的目的旨在告诉你如何创建一个 run loop Observer， 所以代码只是简单设置了一个run loop Observer 用来监视 run loop 的所有活动 。基本的处理代码（没有展示）仅仅是日志输出 run loop 的各项活动行为 作为 timer 的事件回调。</p>

<p>表3-1 创建 runloop Observer</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">threadMain</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 应用使用垃圾回收，所以不需要 自动释放池 autorelease pool</span>
</span><span class='line'>    <span class="bp">NSRunLoop</span> <span class="o">*</span><span class="n">myRunLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 创建一个 run loop observer 并且将他添加到当前 run loop 中去</span>
</span><span class='line'>    <span class="cm">/*!</span>
</span><span class='line'><span class="cm">     *  @author 杨超, 16-01-13 15:01:45</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     *  @brief CFRunLoopObserverContext 用来配置 CFRunLoopObserver 对象行为的结构体</span>
</span><span class='line'><span class="cm">     typedef struct {</span>
</span><span class='line'><span class="cm">        CFIndex  version;</span>
</span><span class='line'><span class="cm">        void *   info;</span>
</span><span class='line'><span class="cm">        const void *(*retain)(const void *info);</span>
</span><span class='line'><span class="cm">        void (*release)(const void *info);</span>
</span><span class='line'><span class="cm">        CFStringRef  (*copyDescription)(const void *info);</span>
</span><span class='line'><span class="cm">     } CFRunLoopObserverContext;</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     *  @param version 结构体版本号，必须为0</span>
</span><span class='line'><span class="cm">     *  @param info 一个程序预定义的任意指针，可以再 run loop Observer 创建时为其关联。这个指针将被传到所有 context 多定义的所有回调中。</span>
</span><span class='line'><span class="cm">     *  @param retain 程序定义 info 指针的内存保留（retain）回调,可以为 NULL</span>
</span><span class='line'><span class="cm">     *  @param release 程序定义 info 指针的内存释放（release）回调，可以为 NULL</span>
</span><span class='line'><span class="cm">     *  @param copyDescription 程序定于 info 指针的 copy 描述回调，可以为 NULL</span>
</span><span class='line'><span class="cm">     *</span>
</span><span class='line'><span class="cm">     *  @since</span>
</span><span class='line'><span class="cm">     */</span>
</span><span class='line'>    <span class="n">CFRunLoopObserverContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span> <span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="nb">self</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'>    <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">CFRunLoopObserverCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="n">kCFRunLoopAllActivities</span><span class="p">,</span> <span class="nb">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">myRunLoopObserverCallBack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">observer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CFRunLoopRef</span> <span class="n">cfLoop</span> <span class="o">=</span> <span class="p">[</span><span class="n">myRunLoop</span> <span class="n">getCFRunLoop</span><span class="p">];</span>
</span><span class='line'>        <span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">cfLoop</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建并安排好 timer</span>
</span><span class='line'>    <span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">0.1</span> <span class="nl">target</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doFireTimer</span><span class="p">)</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'>    <span class="bp">NSInteger</span> <span class="n">loopCount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 3秒后运行 run loop 实际效果是每三秒进入一次当前 while 循环</span>
</span><span class='line'>        <span class="p">[</span><span class="n">myRunLoop</span> <span class="nl">runUntilDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="nl">dateWithTimeIntervalSinceNow</span><span class="p">:</span><span class="mi">3</span><span class="p">]];</span>
</span><span class='line'>        <span class="n">loopCount</span> <span class="o">--</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">loopCount</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">myRunLoopObserverCallBack</span><span class="p">(</span><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span> <span class="n">activity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;observer正在回调</span><span class="se">\n</span><span class="s">%@----%tu----%@&quot;</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">activity</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doFireTimer</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;计时器回调&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当为一个长期存活的现场配置 runloop 时，至少添加一个 input source 去接收消息。尽管你可以仅仅使用一个 关联的timer 就可以进入 run loop，一旦 timer 启动，通常都会被作废掉，这将会硬气 run loop 的退出。关联一个重复执行的 timer 定时器可以保持让 runloop 在很长的一段时期内得以运行，但是需要周期性的去启动定时器 timer 来唤醒你的线程，这是投票有效的另一种形式（这句莫名其妙，不懂是干吗的）。相比之下， input source 会等待事件的发生，并保持线程处于睡眠状态直到事件确实发生了。</p>

<h2>开动 run loop</h2>

<p>在应用中，只有在子线程中才是有必要开启 run loop 的，一个 run loop 必须至少有一个用来监视的 input source 。如果一个关联的都没有，run loop 将会立即退出。</p>

<p>下面有一些方法开启 run loop：
* 无条件的
* 通过一套时间限制
* 在一个特别的 mode 下</p>

<p>无条件的进入你的 run loop 是最简单的选项，但这种也是最不可取的。无条件地运行你的 run loop 将会使你的线程进入进入永久的循环中，这使你很难控制运行循环本身。你可以添加和移除 input source 和 timer，但是只有一种方式去停止 run loop，那就是将它杀死。同时也不存在在自定义 mode 中运行 run loop 的方法。</p>

<p>为了替代无条件的运行 run loop ，更好的办法是使用超时值来运行 runloop。当你使用超时值时，run loop 会一直运行直到在事件来临时 或者 分配的时间结束时。当你的事件到达时，系统会分配一个 handler 去处理它，并且之后 run loop 会退出。你可以用代码重启你的 run loop 以便处理下一个事件。如果不想继续使用刚才分配时间结束的原则，也可以简单的重启 runloop 或者使用这些时间去做任何你需要做的事。</p>

<p>除了使用超时值，你也可以使用指定的 mode 运行 run loop。mode 和超时值不会互相排斥，并且都可以用来启动一个线程。</p>

<p>表 3-2 展示了一个线程入口的常用的例行程序。示例代码的关键部分展示了一个 run loop 的基础架构。本质上，你将 input sources 和 timers 添加到你的 runloop 中，然后重复的调用其中一个例行程序来启动 run loop 。每一次例行程序返回时，你需要检查一下是否满足可能会退出线程的条件。示例使用了 Core Foundation 的框架的例行程序以便检查返回结果并且可以决定如何退出 runloop。如果你是用的是 Cocoa ，你也可以使用类似的方式通过 NSRunLoop 的方法去运行 runloop ，    并且不需要检查返回值。（使用 NSRunLoop 的方法的例子可以参考 表3-14.）</p>

<p>表 3-2 运行 runloop</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">skeletionThreadMain</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 如果你的应用没有使用垃圾回收 请在这里添加 自动释放池（ps：这示例代码也太老了，谁还用垃圾回收啊）</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 给 runloop 添加 source 或timer，然后做一些其他的配置</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 开启 runloop 并且被一个 source 被处理后要返回</span>
</span><span class='line'>        <span class="cm">/** SInt32 32位有符号整数 */</span>
</span><span class='line'>        <span class="kt">SInt32</span> <span class="n">result</span> <span class="o">=</span> <span class="n">CFRunLoopRunInMode</span><span class="p">(</span><span class="n">kCFRunLoopDefaultMode</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">YES</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果 source 已经显式的停止了 runloop ，或者根本不存在任何 source 或 timer，将会退出。</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">==</span> <span class="n">kCFRunLoopRunStopped</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">kCFRunLoopRunFinished</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">done</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>            <span class="c1">// 在这里检查任何其他符合退出的条件并且按需设置 done 变量的值。</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 在这里清除代码。确保释放任何之前创建的自动释放池。</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以递归开启 runloop，换句话说，你可以使用 input source 或者 timer 的例行程序来调用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopRun">CFRunLoopRun</a>,<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopRunInMode">CFRunLoopRunInMode</a>或者任何 NSRunLoop 的 runloop 启动方法。这样做你可以使用任何你想用的 mode 来运行一个 嵌套的 run loop ，包括 通过外层 run loop 使用的 mode 。</p>

<h3>退出 RunLoop</h3>

<p>有两种途径可以让 runloop 在处理事件之前退出：</p>

<ul>
<li>使用超时值配置 runloop 运行。</li>
<li>直接告诉 runloop 停止（ps：。。。这条太搞了）。</li>
</ul>


<p>使用超时值无疑是更偏爱的方法，如果你能管理它，指定一个超时值使 runloop 结束所有他的正常处理的任务， 包括在退出前向 runloop observer 发送通知。</p>

<p>使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopStop">CFRunLoopStop</a> 函数显示地停止 runloop，产生的结果和超时相似。runloop 会发送任何 runloop 提醒通知然后才退出。不同的是你可以将这项技术应用在你用无条件方式开启的 runloop 上。</p>

<p>尽管移除一个 runloop 的 input source 和 timer 可以造成 runloop 的退出，但这并不是一个可靠的方式来停止 runloop 。一些系统例行程序给 runloop 添加一些 input source 来处理必要的事件。你的代码可能无法看出这些 input source，你可能不能移除这些用来防止 runloop  退出的 source。</p>

<h3>线程安全 和 Run Loop 对象</h3>

<p>线程安全大多取决于你用来操作 runloop 的API。Core Foundation 函数 一般来说都是线程安全的，所以可以被任何线程调用。假如你正在执行一个修改 runloop 配置的操作，那么继续吧，对拥有 runloop 的线程来说这样做仍然是很好的作法。</p>

<p>Cocoa 的 <code>NSRunLoop</code> 类内部不像 Core Foundation 中的接口那样是线程安全的。如果你要使用 NSRunLoop 类去修改你的 runloop，你只能在 runloop 所在的线程中这样做。先其他线程中的 runloop 中添加 input source 或 timer 会引起你的程序崩溃或出现不可预知的异常。</p>

<h3>配置 run loop source</h3>

<p>接下来的章节将展示如何在 Cocoa 和 Core Foundation 中设置不同类型的 input source。</p>

<h4>定义一个自定义自定义 input source</h4>

<p>创建一个自定义的 input source 你需要实现以下这些条件：</p>

<ul>
<li>你想要你的 source 处理的信息</li>
<li>一段调度模块的例行程序让感兴趣的客户机了解如何连接你的 input source。</li>
<li>一段处理模块例行程序用来处理任何客户机发送的请求</li>
<li>一段取消模块的例行程序用来销毁你的 source</li>
</ul>


<p>因为你创建了一个自定义的 input source 来处理自定义的信息，所以实际上的配置会设计的非常灵活。调度模块，处理模块和取消模块的例行程序几乎都是你的自定义 input source 的关键例行程序。剩下的大多数 input source 行为都发生在这些例行处理程序之外。比如，由你来定义一个工具用来将数据传到你的 input source并且传递你的 input source 的数据到其他线程中去。</p>

<p>插图 3-2 展示了一个简单的自定义 input source 的配置。在本例中，应用程序主线程维持引用了input source ， input source 的缓冲模块，还有安装 input source 的 runloop。当主线程有一个任务向切换到工作子线程中去，他会发送一个命令，命令缓冲区以及启动任务所需的任何线程的信息（因为主线程和工作子线程的 input source 都有权限去访问命令缓冲区，访问必须同步）一旦命令发送了，主线程会发送信号给 input source 来唤醒工作子线程的 runloop。一旦受到唤醒的命令， runloop 会调用 input source 的处理程序 去处理命令缓存器中缓存的命令。</p>

<p>图 3-2 操作一个自定义 input source</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt="图 3-2" /></p>

<p>接下来的章节将会解释如何通过上图实现一个自定义 input source 并展示你需要实现的关键代码。</p>

<h3>定义 input source</h3>

<p>定义一个自定义 input source 需要使用 Core Foundation 的例行程序配置你的 runloop input source 并且 将它与你的 runloop 关联。尽管基础处理程序是基于 C-语言 函数的，但这不会阻止你使用 Objective-C 或者 C++ 去封装它为面向对象的代码。</p>

<p>插图3-2中介绍的 input source 使用一个 objective-C 对象去管理一个命令缓存器，并与 runloop 进行协调。列表3-3 展示了这个对象的定义。<code>RunLoopSource</code> 对象管理一个命令缓冲器，并且使用命令缓存器接受来自其他线程的消息。该表也展示了 <code>RunLoopContext</code> 对象的定义，该对象仅仅是一个容器，用来传递一个 <code>RunLoopSource</code> 对象和应用主线程的 runloop 引用。</p>

<p>表 3-3 自定义 input source 对象的定义</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">YCRunLoopSource</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopSourceRef</span> <span class="n">runLoopSource</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">commands</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 添加</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addToCurrentRunLoop</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 销毁</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">invalidate</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 处理方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sourceFired</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用来注册需要处理的命令的客户机接口</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addCommand:</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="nv">command</span> <span class="nf">withData:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">data</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fireAllCommandsOnRunLoop:</span><span class="p">(</span><span class="n">CFRunLoopSourceRef</span><span class="p">)</span><span class="nv">runloop</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 这些是CFRunLoopRef 的回调函数</span>
</span><span class='line'><span class="cm">/** 调度函数 */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourceScheduleRoutine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">r1</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span><span class='line'><span class="cm">/** 处理函数 */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourcePerformRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">);</span>
</span><span class='line'><span class="cm">/** 取消函数 */</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourceCancelRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// RunLoopContext 是一个 在注册 input source 时使用的容器对象</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">YCRunLoopContext</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span><span class="p">;</span>
</span><span class='line'>    <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cm">/** 持有 runloop 和 source */</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithSource:</span><span class="p">(</span><span class="n">YCRunLoopSource</span><span class="o">*</span><span class="p">)</span><span class="nv">src</span> <span class="nf">andLoop:</span><span class="p">(</span><span class="n">CFRunLoopRef</span><span class="p">)</span><span class="nv">loop</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>尽管 Objective-C 代码管理着 input source 的自定义数据。关联一个 input source 到一个具备 基于 C-语言 的回调函数的 runloop 。其中第一个函数是当你实际将 input source 添加到 runloop 中的时刻调用。流程将展示在 表 3-4 中。因为这个 input source 仅只有一个 客户机（主线程）。它使用调度者函数通过目标线程 application 的代理发送消息在目标线程注册自己。当 application 的代理和 input source 进行通信时 ,会使用 RunLoopContext 对象中的 <code>info</code> 信息来完成这个事。</p>

<p>表 3-4 调度 run loop source</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourceScheduleRoutine</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">r1</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">){</span>
</span><span class='line'>    <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 这里的 Appdelegate 是主线程的代理   </span>
</span><span class='line'>    <span class="n">AppDelegate</span> <span class="o">*</span><span class="n">del</span> <span class="o">=</span> <span class="p">[</span><span class="n">AppDelegate</span> <span class="n">sharedAppDelegate</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 上下文对象中持有source自己</span>
</span><span class='line'>    <span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="n">theContext</span> <span class="o">=</span> <span class="p">[[</span><span class="n">YCRunLoopContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSource</span><span class="p">:</span><span class="n">obj</span> <span class="nl">andLoop</span><span class="p">:</span><span class="n">r1</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 通过代理去注册 Source 自己 </span>
</span><span class='line'>    <span class="p">[</span><span class="n">del</span> <span class="nl">performSelectorOnMainThread</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">registerSource</span><span class="p">:)</span> <span class="nl">withObject</span><span class="p">:</span><span class="n">theContext</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中最重要的回调例行程序是当你的 input source 被信号激活时处理自定义数据的部分。表3-5中展示了与 <code>RunLoopSource</code> 对象关联的执行者回调例行程$序,这个函数仅仅转发用来 <code>sourceFired</code> 方法工作的请求，该请求用来处理任何 <code>command buffer</code> （命令缓冲区）中存在的命令。</p>

<p>表3-5 input source 中的执行者</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourcePerformRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">RunLoopSource</span><span class="o">*</span>  <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">RunLoopSource</span><span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">obj</span> <span class="n">sourceFired</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你使用 <code>CFRunLoopSourceInvalidate</code> 函数将 input source 从 runloop 重移除。系统会调用你的 input source 中的取消者例行程序。你可以利用这个例行程序去通知客户机你的 input source 不再可用并且他们应该移除任何自己的相关的引用。表3-6 展示了取消者例行回调程序通过 RunLoopSource 对象进行注册。这个函数发送另一个 RunLoopContext 对象给 application 代理。但是这让代理去移除 runloop surce 的相关引用。</p>

<p>表3-6 销毁一个 input source</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">RunLoopSourceCancelRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">RunLoopSource</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">RunLoopSource</span><span class="o">*</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
</span><span class='line'>    <span class="n">AppDelegate</span><span class="o">*</span> <span class="n">del</span> <span class="o">=</span> <span class="p">[</span><span class="n">AppDelegate</span> <span class="n">sharedAppDelegate</span><span class="p">];</span>
</span><span class='line'>    <span class="n">RunLoopContext</span><span class="o">*</span> <span class="n">theContext</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RunLoopContext</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSource</span><span class="p">:</span><span class="n">obj</span> <span class="nl">andLoop</span><span class="p">:</span><span class="n">rl</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">del</span> <span class="nl">performSelectorOnMainThread</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">removeSource</span><span class="p">:)</span>
</span><span class='line'>                                <span class="nl">withObject</span><span class="p">:</span><span class="n">theContext</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>
笔记：应用代理方法  registerSource: 和 removeSource 方法在下面的章节 《协调 input source 的客户机》展示
</code></p>

<h3>为 runloop 安装 input source</h3>

<p>表3-7 展示了 <code>RunLoopSource</code> 类的 <code>init</code> 方法 和 <code>addToCurrentRunLoop</code> 方法。<code>init</code> 方法创建了 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/c/tdef/CFRunLoopSourceRef">CFRunLoopSource</a> 不透明类型的必须关联到 runloop 的对象。它会传递 <code>RunLoopSource</code> 对象自己作为 山下文信息 以便于例行回调程序有一个指向对象的指针。input source 直到线程唤起 <code>addToCurrentRunLoop</code> 方法时才会执行安装，准确将在 RunLoopSourceScheduleRoutine 回调函数调用时。 一旦 input source 安装到 runloop 中，线程将会运行自己的 runloop 去等待 input source 发出事件。</p>

<p>表3-7 安装 run loop source</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 创建上下文容器，其中会连接自己的 info，retain info release info，还会关联三个例行程序。</span>
</span><span class='line'>    <span class="n">CFRunLoopSourceContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="nb">self</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">,</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RunLoopSourceScheduleRoutine</span><span class="p">,</span> <span class="n">RunLoopSourceCancelRoutine</span><span class="p">,</span> <span class="n">RunLoopSourcePerformRoutine</span><span class="p">};</span>
</span><span class='line'>    <span class="cm">/** 通过索引，上下文，和CFAllocator创建source */</span>
</span><span class='line'>    <span class="n">runLoopSource</span> <span class="o">=</span> <span class="n">CFRunLoopSourceCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>    <span class="n">commands</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span>  <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">addToCurrentRunLoop</span><span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">runLoop</span><span class="p">,</span> <span class="n">runLoopSource</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>协调 input source 的客户机</h3>

<p>对于你的 input source 会非常有用，你需要操作它并且从其他线程向它提供消息。input source 的要点是将其添加到线程并睡眠直到有事情要做时才唤醒。事实上很有必要让其他线程了解 input surce 并且有方法可以和它交流（沟通数据）。</p>

<p>通知你的 input source 客户机的方法之一是发出注册请求 当你的 input source 第一次安装到你的 runloop 中时。你可以向你的 input source 注册尽可能多的客户机。或者你仅仅只是简单的用一些中央机构，然后将你的 input source 声明为感兴趣的客户端进行注册。表3-8 展示了  通过代理 和 调用唤起定义的 注册方法 当 RunLoopSource 对象的调度者函数被调用时。这个方法将会收到 RunLoopSource 提供的 RunLoopContext 对象并且将它添加到他的 source 列表中。这个表也会展示 当 input source 从 他的 runloop 中被移除时 用来注销的例行程序。
表 3-8 使用 application 的 代理 注销并且移除 input source</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="cp">#import &quot;YCRunLoopSource.h&quot;</span>
</span><span class='line'> <span class="cp">#import &quot;YCRunLoopContext.h&quot;</span>
</span><span class='line'><span class="k">@interface</span> <span class="nc">AppDelegate</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">sourcesToPing</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** 应该是一个单例 */</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">sharedAppDelegate</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerSource:</span><span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeSource:</span><span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="n">AppDelegate</span> <span class="o">*</span><span class="n">_instance</span><span class="p">;</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">AppDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">sharedAppDelegate</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>    <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">_instance</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_instance</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">registerSource:</span><span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">sourcesToPing</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">context</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">removeSource:</span><span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">objToRemove</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">YCRunLoopContext</span> <span class="o">*</span><span class="n">contextObj</span> <span class="k">in</span> <span class="nb">self</span><span class="p">.</span><span class="n">sourcesToPing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">([</span><span class="n">contextObj</span> <span class="nl">isEqual</span><span class="p">:</span><span class="n">context</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">objToRemove</span> <span class="o">=</span> <span class="n">contextObj</span><span class="p">;</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">objToRemove</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">sourcesToPing</span> <span class="nl">removeObject</span><span class="p">:</span><span class="n">objToRemove</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sourcesToPing</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">_sourcesToPing</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_sourcesToPing</span> <span class="o">=</span> <span class="l">@[]</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_sourcesToPing</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Note：回调函数会在之前的表3-4和3-6中调用这些函数</code></p>

<h5>信号激活 input source</h5>

<p>释放 input source 的数据之后，客户机必须发信号给 source 并且唤醒它的 runloop。发信号给 source 是让 runloop 知道 source 已经准备好被处理。因为线程可能会在发信号的时处于睡眠状态，所以那你必须显式的让 run loop 保持唤醒。除非如此，不然在处理 input source 时会出现延迟。</p>

<p>表 3-9 展示了 <code>RunLoopSource</code> 对象的 <code>fireCommandsOnRunLoop</code> 方法，客户机会在它准备好为 source 处理添加到 buffer 缓冲区中的 command 命令时调用这个方法。</p>

<p>表 3-9 唤醒 run loop</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fireCommandsOnRunLoop:</span><span class="p">(</span><span class="n">CFRunLoopRef</span><span class="p">)</span><span class="nv">runloop</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">CFRunLoopSourceSignal</span><span class="p">(</span><span class="n">runLoopSource</span><span class="p">);</span>
</span><span class='line'>  <span class="n">CFRunLoopWakeUp</span><span class="p">(</span><span class="n">runloop</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Note:你不能通过向一个自定义 input source 发信息来处理一个 SIGHUP 或者其他处理类型的信号</code>，Core Foundation 框架中用于唤醒 runloop 的函数不是信号安全的。并且不能作为你的应用程序中内置信号处理的例行程序使用。关于更多的关于信号处理程序，详见 <a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man2/sigaction.2.html#//apple_ref/doc/man/2/sigaction">sigaction</a> man 页面。</p>

<h3>配置 Timer Source</h3>

<p>为了创建 timer source，所有你需要做的就是创建一个 timer 对象，并且在你的 run loop 中调度它。在 Cocoa 中，你使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/cl/NSTimer">NSTimer</a> 类来创建一个新的 timer 对象。在 Core Foundation 框架中，你可以使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/c/tdef/CFRunLoopTimerRef]">CFRunLoopTimerRef</a> 不透明类型来创建。<code>NSTimer</code> 类只是 Core Foundation 框架中的一个扩展，是用来方便的提供一些功能，比如使用相同的方法创建和调度 timer 。
在 Cocoa 中，你能通过以下两种类方法创建和调度 timer。<br/>
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</a>
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:">scheduledTimerWithTimeInterval:invocation:repeats:</a></p>

<p>这些方法创建 timer 并且将它们添加到当前线程的 run loop 中的 default mode(<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode">NSDefaultRunLoopMode</a>) 中去。如果你使用的是 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/cl/NSTimer">NSTimer</a> 对象，那就可以手动调度 timer 并且可以使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/instm/NSRunLoop/addTimer:forMode:">addTimer:forMode:</a> 手动将它添加到 runloop 中去。这两种技术都是基于同一种，但是通过timer 的配置给你不同级别的控制。比如你手动创建 timer 并将它添加到 run loop 中，并添加到除 default mode 之外的其他 mode 中去。表3-10 展示了如何使用两种技术创建 timer。第一个 timer 初始化为 延迟一秒但是会在延迟后有规律的每个0.1秒触发一次。第二个 timer 会在 0.2 秒延迟后开始触发，并且在延迟结束后 每 0.2 秒触发一次。</p>

<p>表3-10 使用 NSTimer 创建和调度 timer</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSRunLoop</span><span class="o">*</span> <span class="n">myRunLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建并调度第一个 timer</span>
</span><span class='line'><span class="bp">NSDate</span><span class="o">*</span> <span class="n">futureDate</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="nl">dateWithTimeIntervalSinceNow</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSTimer</span><span class="o">*</span> <span class="n">myTimer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSTimer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFireDate</span><span class="p">:</span><span class="n">futureDate</span>
</span><span class='line'>                        <span class="nl">interval</span><span class="p">:</span><span class="mf">0.1</span>
</span><span class='line'>                        <span class="nl">target</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'>                        <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myDoFireTimer1</span><span class="p">:)</span>
</span><span class='line'>                        <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                        <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">myRunLoop</span> <span class="nl">addTimer</span><span class="p">:</span><span class="n">myTimer</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建并调动第二个 timer</span>
</span><span class='line'><span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">0.2</span>
</span><span class='line'>                        <span class="nl">target</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'>                        <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myDoFireTimer2</span><span class="p">:)</span>
</span><span class='line'>                        <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                        <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>表3-11 展示了使用 Core Foundation 框架时需要配置的代码。尽管实例代码中没有传递任何用户自定义的信息的上下文结构，但是你可以使>用这个结构去传递任何你的 timer 所需要自定义数据。关于更多该结构的内容可以浏览 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/doc/uid/20001444">CFRunLoopTimer 参考</a>。</p>

<p>表 3-11 使用 Core Foundation 框架创建和调度一个 timer</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopRef</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
</span><span class='line'><span class="n">CFRunLoopTimerContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'><span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">CFRunLoopTimerCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                                        <span class="o">&amp;</span><span class="n">myCFTimerCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFRunLoopAddTimer</span><span class="p">(</span><span class="n">runLoop</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">kCFRunLoopCommonModes</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>配置一个基于 port 的 input source</h3>

<p>Cocoa 和 Core Foundation 都支持用于和线程间或者进程间通信的基于 端口的对象。接下来的章节将会向你展示如何使用一些不同类型的 port 构建 port 通信。</p>

<h3>配置一个NSMachPort Object</h3>

<p>使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMachPort_Class/index.html#//apple_ref/occ/cl/NSMachPort">NSMachPort</a> 对象创建一个本地连接。你创建一个 port 对象并把它添加到你的主线程 run loop 中去。当启动你的子线程时，你要传一些相同的对象到你的线程入口点函数中去。子线程可以使用相同的对象发送信息回到你的主线程中去。</p>

<h3>实现主线程代码</h3>

<p><a href="#list3-12">表 3-12</a> 中展示了用于启动子工作线程的主线程代码。因为 Cocoa 框架执行很多介入步骤用于配置 port 和 run loop ，Cocoa 的 <code>launchThread</code> 方法相比于 Core Foundation 的等价功能<a href="#list3-17">表 3-17</a>更加简洁明了。尽管如此，这两个框架在这一模块的功能表现基本都是相同的。其中一个存在的差异是与发送本地 port 到工作线程的方式不同，这个方法是直接发送 NSPort 对象的。</p>

<p><strong>表 3-12</strong> list3-12 Main Thread lauch method</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">launchThread</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">NSPort</span> <span class="o">*</span><span class="n">myPort</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMachPort</span> <span class="n">port</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">myPort</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 这个类处理即将过来的 port 信息</span>
</span><span class='line'>        <span class="p">[</span><span class="n">myPort</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 将此端口作为 input source 安装到当前 run loop 中去</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addPort</span><span class="p">:</span><span class="n">myPort</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 开启工作子线程，让工作子线程去释放 port</span>
</span><span class='line'>        <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">detachNewThreadSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">LaunchThreadWithPort</span><span class="p">:)</span> <span class="nl">toTarget</span><span class="p">:[</span><span class="n">MyWorkerClass</span> <span class="k">class</span><span class="p">]</span> <span class="nl">withObject</span><span class="p">:</span><span class="n">myPort</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了设置为线程间双向通信信
道，在
登记信息中，你需要让工作线程发送自己的本地 port 到主线程。接收登记信息是为了让你的主线程知道开动子线程的过程进行的非常顺利，同时也为我们为提供了一种方法去向该线程发送更多信息。</p>

<p>表 3-13 展示了用于主线程的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSPortDelegate_Protocol/index.html#//apple_ref/occ/intfm/NSPortDelegate/handlePortMessage:">handlePortMessage:</a>方法，这个方法会在线程到达自己的本地 port 时进行调用。当登记信息(check-in message)到达时，该方法将直接从 port 信息中检索子线程的 port 并保存以备后用。</p>

<p><strong>表 3-13</strong>    <span id = "listing 3-13">处理 Mach port 信息</span></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp"># define kCheckinMessage 100</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 处理工作线程的响应的代理方法</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePortMessage:</span><span class="p">(</span><span class="n">NSPortMessage</span> <span class="o">*</span><span class="p">)</span><span class="nv">portMessage</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">message</span> <span class="o">=</span> <span class="p">[</span><span class="n">portMessage</span> <span class="n">msgid</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 定义远程端口</span>
</span><span class='line'>    <span class="bp">NSPort</span> <span class="o">*</span><span class="n">distantPort</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">message</span> <span class="o">==</span> <span class="n">kCheckinMessage</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 获取工作线程的通信 port</span>
</span><span class='line'>        <span class="n">distantPort</span> <span class="o">=</span> <span class="p">[</span><span class="n">portMessage</span> <span class="n">sendPort</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 引用计数+1 并 保存工作端口以备后用</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">storeDistantPort</span><span class="p">:</span><span class="n">distantPort</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 处理其他信息</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">storeDistantPort:</span><span class="p">(</span><span class="bp">NSPort</span> <span class="o">*</span><span class="p">)</span><span class="nv">port</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 保存远程端口</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>实现子线程代码</h4>

<p>对于工作子线程，你必须配置它并且是使用指定的端口进行信息沟通并返回到主线程。</p>

<p>表 3-14 展示了用于设置工作线程的代码。在创建一个 qutorealease  pool 之后，该方法会创建一个工作对象去驱动线程执行。该工作对象 的 <code>sendCheckinMessage:</code> 方法（表3-15 所示）为工作线程创建一个本地端口然后回复一个 check-in 信息给主线程。
表 3-14 <span id = "liting3-14"> 使用 Mach port 启动子线程 </span></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+(</span><span class="kt">void</span><span class="p">)</span><span class="nf">LaunchThreadWithPort:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">inData</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="bp">NSAutoreleasePool</span><span class="o">*</span>  <span class="n">pool</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSAutoreleasePool</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置本线程与主线程的连接 </span>
</span><span class='line'>    <span class="bp">NSPort</span><span class="o">*</span> <span class="n">distantPort</span> <span class="o">=</span> <span class="p">(</span><span class="bp">NSPort</span><span class="o">*</span><span class="p">)</span><span class="n">inData</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">MyWorkerClass</span><span class="o">*</span>  <span class="n">workerObj</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">workerObj</span> <span class="nl">sendCheckinMessage</span><span class="p">:</span><span class="n">distantPort</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">distantPort</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 让 run loop 处理这些逻辑 </span>
</span><span class='line'>    <span class="k">do</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">runMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span>
</span><span class='line'>                            <span class="nl">beforeDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">distantFuture</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">workerObj</span> <span class="n">shouldExit</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">workerObj</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">pool</span> <span class="k">release</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当使用 <code>NSMachPort</code> 时,本地和远端线程都可以使用相同的 port 对象 完成线程之间的单工通信（单向通信）。换句话说，通过一个线程创建的本地对象会成为另一个线程的远端 port 对象。（ps：现在总算明白本地就是当前线程环境，远端就是其他线程环境）。</p>

<p>表 3-15展示了子线程的 check-in 例行程序 （登记信息例行程序）。这个方法设置了他自己的用于和以后进行通讯的本地端口。并且回复一个 check-in 登记信息给主线程。该方法使用 port 对象去接收 <code>LaunchThreadWithport:</code> 方法作为信息目标。</p>

<p>表 3-15 使用 Mach port 发送 check-in 登记信息</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Worker thread check-in method</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">sendCheckinMessage:</span><span class="p">(</span><span class="bp">NSPort</span><span class="o">*</span><span class="p">)</span><span class="nv">outPort</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 保留（retain）并保存远端的 port 以备后用</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">setRemotePort</span><span class="p">:</span><span class="n">outPort</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建和配置工作线程的端口（ps：当前线程端口） </span>
</span><span class='line'>    <span class="bp">NSPort</span><span class="o">*</span> <span class="n">myPort</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMachPort</span> <span class="n">port</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">myPort</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addPort</span><span class="p">:</span><span class="n">myPort</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建 check-in 登记信息</span>
</span><span class='line'>    <span class="n">NSPortMessage</span><span class="o">*</span> <span class="n">messageObj</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSPortMessage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSendPort</span><span class="p">:</span><span class="n">outPort</span>
</span><span class='line'>                                         <span class="nl">receivePort</span><span class="p">:</span><span class="n">myPort</span> <span class="nl">components</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">messageObj</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 完成配置信息 并 立即发送出去</span>
</span><span class='line'>        <span class="p">[</span><span class="n">messageObj</span> <span class="nl">setMsgId</span><span class="p">:</span><span class="nl">setMsgid</span><span class="p">:</span><span class="n">kCheckinMessage</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">messageObj</span> <span class="nl">sendBeforeDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>配置一个 NSMessagePort 对象</h4>

<p>如果想要使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSM%20%20%20%20essagePort_Class/index.html#//apple_ref/occ/cl/NSMessagePort">NSMessagePort</a> 对象创建一个本地连接，你不能在线程间仅仅值传递一个 port 对>    象。远端信息端口必须通过名字获取。
在Cocoa中，如果你想实现这个功能，需要使用一个指定的名字去注册你的本地端口，然后向远端线程传递注册的名字以便于他可以包含一
    个合适的端口对象用于交流。表 3-16 展示了 port 创建方法和注册方法 用于你想要使用 消息端口（message port）的地方。</p>

<p>表 3-16 注册一个 message port</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSPort</span><span class="o">*</span> <span class="n">localPort</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMessagePort</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 配置对象并将它添加到当前 run loop 中去</span>
</span><span class='line'><span class="p">[</span><span class="n">localPort</span> <span class="nl">setDelegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">]</span> <span class="nl">addPort</span><span class="p">:</span><span class="n">localPort</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用指定的名字注册端口。名字必须唯一。</span>
</span><span class='line'><span class="bp">NSString</span><span class="o">*</span> <span class="n">localPortName</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;MyPortName&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">[[</span><span class="n">NSMessagePortNameServer</span> <span class="n">sharedInstance</span><span class="p">]</span> <span class="nl">registerPort</span><span class="p">:</span><span class="n">localPort</span>
</span><span class='line'><span class="nl">name</span><span class="p">:</span><span class="n">localPortName</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>在 Core Foundation 框架中配置一个基于端口的（Port-Based） input source</h4>

<p>这个小结描述了如歌使用 Core Foundation 框架在你的应用的主线程和辅助线程（worker thread）中创建一个双向通信信道。</p>

<p>如表3-17 所示为应用主线程启动辅助线程所使用的代码。首先要做的是创建 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessagePortRef/index.html#//apple_ref/c/tdef/CFMessagePortRef">CFMessagePortRef</a> 不透明对象去监听从辅助线程发来的消息。辅助线程需要用来创建连接的端口名，以便于字符串值可以被发送到辅助线程的入口点函数。端口名在当前用户的上线文中通常必须是唯一的。否则，可能会出现运行冲突。</p>

<p>表 3-17 给新线程关联一个 Core Foundation message port</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define kThreadStackSize        (8 *4096)</span>
</span><span class='line'>
</span><span class='line'><span class="n">OSStatus</span> <span class="nf">MySpawnThread</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 创建一个本地端口用于接受响应</span>
</span><span class='line'>    <span class="n">CFStringRef</span> <span class="n">myPortName</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFMessagePortRef</span> <span class="n">myPort</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFRunLoopSourceRef</span> <span class="n">rlSource</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFMessagePortContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'>    <span class="kt">Boolean</span> <span class="n">shouldFreeInfo</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 用端口名 创建一个符合规范的字符串</span>
</span><span class='line'>    <span class="n">myPortName</span> <span class="o">=</span> <span class="n">CFStringCreateWithFormat</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;com.myapp.MainThread&quot;</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建端口</span>
</span><span class='line'>    <span class="n">myPort</span> <span class="o">=</span> <span class="n">CFMessagePortCreateLocal</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                <span class="n">myPortName</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">MainThreadResponseHandler</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">shouldFreeInfo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">myPort</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 端口已经被成功创建</span>
</span><span class='line'>        <span class="c1">// 现在为他创建 run loop source</span>
</span><span class='line'>        <span class="n">rlSource</span> <span class="o">=</span> <span class="n">CFMessagePortCreateRunLoopSource</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">myPort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">rlSource</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 为当前 run loop 添加 source</span>
</span><span class='line'>            <span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">rlSource</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 一旦安装结束，这些资源需要被释放</span>
</span><span class='line'>            <span class="n">CFRelease</span><span class="p">(</span><span class="n">myPort</span><span class="p">);</span>
</span><span class='line'>            <span class="n">CFRelease</span><span class="p">(</span><span class="n">rlSource</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建线程并且继续处理任务</span>
</span><span class='line'>    <span class="n">MPTaskID</span>        <span class="n">taskID</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span><span class="p">(</span><span class="n">MPCreateTask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ServerThreadEntryPoint</span><span class="p">,</span>
</span><span class='line'>                    <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">myPortName</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">kThreadStackSize</span><span class="p">,</span>
</span><span class='line'>                    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                    <span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                    <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                    <span class="o">&amp;</span><span class="n">taskID</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果 port 端口已经被安装并且线程已经启动，主线程就可以继续定期的执行去等待辅助线程的 check-in 登记信息。一旦 check-in 登记信息到达，它将会被指派到主线程的 <code>MainThreadResponseHandler</code> 函数中，如表 3-18 所示，这个函数提取辅助线程的端口名并且创建通信管道。</p>

<p>表 3-18 接收 check-in 登记信息</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define kCheckinMessage 100</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 主线程端口信息处理函数</span>
</span><span class='line'><span class="n">CFDataRef</span> <span class="nf">MainThreadResponseHandler</span><span class="p">(</span><span class="n">CFMessagePortRef</span> <span class="n">local</span><span class="p">,</span>
</span><span class='line'>                    <span class="kt">SInt32</span> <span class="n">msgid</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">CFDataRef</span> <span class="n">data</span><span class="p">,</span>
</span><span class='line'>                    <span class="kt">void</span><span class="o">*</span> <span class="n">info</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">msgid</span> <span class="o">==</span> <span class="n">kCheckinMessage</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">CFMessagePortRef</span> <span class="n">messagePort</span><span class="p">;</span>
</span><span class='line'>        <span class="n">CFStringRef</span> <span class="n">threadPortName</span><span class="p">;</span>
</span><span class='line'>        <span class="n">CFIndex</span> <span class="n">bufferLength</span> <span class="o">=</span> <span class="n">CFDataGetLength</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">UInt8</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">CFAllocatorAllocate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">bufferLength</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CFDataGetBytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bufferLength</span><span class="p">),</span> <span class="n">buffer</span><span class="p">);</span>
</span><span class='line'>        <span class="n">threadPortName</span> <span class="o">=</span> <span class="n">CFStringCreateWithBytes</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">bufferLength</span><span class="p">,</span> <span class="n">kCFStringEncodingASCII</span><span class="p">,</span> <span class="nb">FALSE</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 你必须通过一个 port 名获取远端信息</span>
</span><span class='line'>        <span class="n">messagePort</span> <span class="o">=</span> <span class="n">CFMessagePortCreateRemote</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">threadPortName</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">messagePort</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 保留并保存线程的 comm 端口 以备后用</span>
</span><span class='line'>            <span class="n">AddPortToListOfActiveThreads</span><span class="p">(</span><span class="n">messagePort</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 如果端口在先前的 函数 中保留了（retain），在这里释放资源</span>
</span><span class='line'>            <span class="n">CFRelease</span><span class="p">(</span><span class="n">messagePort</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 释放资源</span>
</span><span class='line'>        <span class="n">CFRelease</span><span class="p">(</span><span class="n">threadPortName</span><span class="p">);</span>
</span><span class='line'>        <span class="n">CFAllocatorDeallocate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 处理其他信息</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>主线程配置完成后，唯一要做的就是为新创建的辅助线程创建它自己的 端口和 登记自己的 message。表 3-19 所示为辅助线程的入口点函数。函数提取了主线程的 port 名并且用它创建了一个远端的连接回复主线程。之后函数为自己创建一个本地端口，将端口 port 安装到线程的 runloop 中去，然后给主线程发送一个包含本地端口名的 check-in 登记信息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">OSStatus</span> <span class="nf">ServerThreadEntryPoint</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 创建连接到主线程的远端端口</span>
</span><span class='line'>    <span class="n">CFMessagePortRef</span> <span class="n">mainThreadPort</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFStringRef</span> <span class="n">portName</span> <span class="o">=</span> <span class="p">(</span><span class="n">CFStringRef</span><span class="p">)</span><span class="n">param</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mainThreadPort</span> <span class="o">=</span> <span class="n">CFMessagePortCreateRemote</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">portName</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 释放被用于参数传递的字符串</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">portName</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 为辅助才女创建一个本地端口</span>
</span><span class='line'>    <span class="n">CFStringRef</span> <span class="n">myPortName</span> <span class="o">=</span> <span class="n">CFStringCreateWithFormat</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;com.MyApp.Thread-%d&quot;</span><span class="p">),</span> <span class="n">MPCurrentTaskID</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 保存线程上下文信息中的端口，以便之后使用。</span>
</span><span class='line'>    <span class="n">CFMessagePortContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="n">mainThreadPort</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'>    <span class="kt">Boolean</span> <span class="n">shouldFreeInfo</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">Boolean</span> <span class="n">shouldAbort</span> <span class="o">=</span> <span class="nb">TRUE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CFMessagePortRef</span> <span class="n">myPort</span> <span class="o">=</span> <span class="n">CFMessagePortCreateLocal</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
</span><span class='line'>                <span class="n">myPortName</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">ProcessClientRequest</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span>
</span><span class='line'>                <span class="o">&amp;</span><span class="n">shouldFreeInfo</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">shouldFreeInfo</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 如果不能创建本地端口，则杀死线程</span>
</span><span class='line'>        <span class="n">MPExit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CFRunLoopSourceRef</span> <span class="n">rlSource</span> <span class="o">=</span> <span class="n">CFMessagePortCreateRunLoopSource</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">myPort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rlSource</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 如果不能创建本地端口，则杀死线程</span>
</span><span class='line'>        <span class="n">MPExit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 给 runloop 添加source</span>
</span><span class='line'>    <span class="n">CFRunLoopAddSource</span><span class="p">(</span><span class="n">CFRunLoopGetCurrent</span><span class="p">(),</span> <span class="n">rlSource</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 一旦线程安装完毕，这些资源需要释放</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">myPort</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">rlSource</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 打包端口名，并发送 check-in 信息。</span>
</span><span class='line'>    <span class="n">CFDataRef</span> <span class="n">returnData</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFDataRef</span> <span class="n">outData</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CFIndex</span> <span class="n">stringLength</span> <span class="o">=</span> <span class="n">CFStringGetLength</span><span class="p">(</span><span class="n">myPortName</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">UInt8</span><span class="o">*</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">CFAllocatorAllocate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">stringLength</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CFStringGetBytes</span><span class="p">(</span><span class="n">myPortName</span><span class="p">,</span>
</span><span class='line'>                <span class="n">CFRangeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">stringLength</span><span class="p">),</span>
</span><span class='line'>                <span class="n">kCFStringEncodingASCII</span><span class="p">,</span>
</span><span class='line'>                <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                <span class="nb">FALSE</span><span class="p">,</span>
</span><span class='line'>                <span class="n">buffer</span><span class="p">,</span>
</span><span class='line'>                <span class="n">stringLength</span><span class="p">,</span>
</span><span class='line'>                <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">outData</span> <span class="o">=</span> <span class="n">CFDataCreate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">stringLength</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CFMessagePortSendRequest</span><span class="p">(</span><span class="n">mainThreadPort</span><span class="p">,</span> <span class="n">kCheckinMessage</span><span class="p">,</span> <span class="n">outData</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 清除线程数据结构</span>
</span><span class='line'>    <span class="n">CFRelease</span><span class="p">(</span><span class="n">outData</span><span class="p">);</span>
</span><span class='line'>    <span class="n">CFAllocatorDeallocate</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 进入 runloop</span>
</span><span class='line'>    <span class="n">CFRunLoopRun</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一旦进入 runloop，所有发送给线程端口的事件会被 <code>ProcessClientRequest</code> 函数处理。该函数的实现依赖于工作线程的类型，这里暂不做介绍。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Super Yang</span></span>

      




<time class='entry-date' datetime='2016-01-18T12:34:58+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:34 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/ios/'>ios</a>
  
</span>


      

<DIV style="font-size:12px;BORDER-BOTTOM: #bbbbbb 1px solid; BORDER-LEFT: #bbbbbb 1px solid; BACKGROUND: #f6f6f6; HEIGHT: 120px; BORDER-TOP: #bbbbbb 1px solid; BORDER-RIGHT: #bbbbbb 1px solid" class=oec2003right> 
<DIV style="MARGIN-TOP: 10px; FLOAT: left; MARGIN-LEFT: 5px; MARGIN-RIGHT: 10px"> 
<IMG alt="" src="http://ww2.sinaimg.cn/thumb150/c2abdfa9jw8ez7appr3p2j20g40a2t91.jpg" width=90 height=100></DIV> 
<DIV style="LINE-HEIGHT: 200%; MARGIN-TOP: 10px; COLOR: #000000"> 
作者： <A href="http://yangchao0033.github.io/">杨超</A> <BR> 
出处： <A href="http://yangchao0033.github.io/">http://yangchao0033.github.io/</A> 
<BR>本文基于<a target="_blank" title="Creative Commons Attribution 2.5 China Mainland License" href="http://creativecommons.org/licenses/by/2.5/cn/"> 
署名 2.5 中国大陆</a>许可协议发布，欢迎转载，演绎或用于商业目的，如非注明转载，原创必须保留本文的署名 
<a href="http://yangchao0033.github.io/">杨超</a>（包含链接）。 </DIV></DIV> 



    </p>
    
      <div class="sharing">
  
  
  
</div>
<div class="bshare-custom"><a title="分享到QQ空间" class="bshare-qzone"></a><a title="分享到新浪微博" class="bshare-sinaminiblog"></a><a title="分享到人人网" class="bshare-renren"></a><a title="分享到腾讯微博" class="bshare-qqmb"></a><a title="分享到网易微博" class="bshare-neteasemb"></a><a title="更多平台" class="bshare-more bshare-more-icon more-style-addthis"></a><span class="BSHARE_COUNT bshare-share-count">0</span></div><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/buttonLite.js#style=-1&amp;uuid=&amp;pophcol=2&amp;lang=zh"></script><script type="text/javascript" charset="utf-8" src="http://static.bshare.cn/b/bshareC0.js"></script>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/01/08/runloopshen-du-tan-jiu-(4)/" title="Previous Post: RunLoop深度探究（四）">&laquo; RunLoop深度探究（四）</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/01/18/cocoapod-version-update/" title="Next Post: CocoaPod version update">CocoaPod version update &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><!-- Duoshuo Comment BEGIN -->

<div class="ds-thread"></div>

<script type="text/javascript">

var duoshuoQuery = {short_name:"yangchao0033"};

(function() {

var ds = document.createElement('script');

ds.type = 'text/javascript';ds.async = true;

ds.src = 'http://static.duoshuo.com/embed.js';

ds.charset = 'UTF-8';

(document.getElementsByTagName('head')[0] 

|| document.getElementsByTagName('body')[0]).appendChild(ds);

})();

</script>

<!-- Duoshuo Comment END -->
</div>
  </section>

</div>

<aside class="sidebar">
  
     <section>
       <h1>背景音乐</h1>
       <ul id="music">
       <li>
   <!--添加网易音乐-->
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100%" height=86 src="http://music.163.com/outchain/player?type=2&id=28577165&auto=0&height=66"></iframe>
         </li>
       </ul>
   </section>
<section>
    <h1>新浪微博</h1>
    <ul id="weibo">
    <li>
<!--添加微博秀-->
<iframe width="100%" height="100" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=2&ptype=1&speed=0&skin=1&isTitle=1&noborder=0&isWeibo=0&isFans=0&uid=3266043817&verifier=3639b7ec&colors=efefef,efefef,666666,0082cb,ecfbfd&dpc=1"></iframe>
      </li>
    </ul>
</section>
<section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/ios/'>ios (15)</a></li>
<li class='category'><a href='/blog/categories/时光留声机/'>时光留声机 (1)</a></li>

  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/02/14/hls-2/">HLS-iOS视频播放服务架构深入探究（二）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/29/hls-1/">HLS-iOS视频播放服务架构深入探究（一）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/26/coretextji-chu/">CoreText基础概念（扫盲篇）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/18/cocoapod-version-update/">CocoaPod Version Update</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/18/runloop-5/">RunLoop深度探究（五）</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/yangchao0033">@yangchao0033</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'yangchao0033',
            count: 48,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <h1>访客地图</h1>
  <!--获得代码添加到这-->
<script type="text/javascript" src="//ra.revolvermaps.com/0/0/1.js?i=0sycmreaxpu&amp;s=190&amp;m=0&amp;v=true&amp;r=false&amp;b=000000&amp;n=false&amp;c=007eff" async="async"></script>
</section>
<section>
<h1>酷站博客</h1>
<ul>
        <li>
        <a href="http://iphonedevwiki.net/index.php/Main_Page">iphoneDevWiki</a>
        </li>
        <li>
        <a href="https://en.wikipedia.org/wiki/List_of_iOS_devices">IphoneWikipedia</a>
        </li>
        <li>
        <a href="http://nshipster.com/">nshipster(Mattt Thompson)</a>
        </li>
        <li>
        <a href="http://nshipster.cn/">nshipster中文(Mattt Thompson)</a>
        </li>
        <li>
        <a href="http://www.tuicool.com/articles/V7RVb2Q/">Octopress专栏</a>
        </li>
        <li>
        <a href="http://blog.ibireme.com/">郭曜源的技术博客</a>
        </li>
        <li>
        <a href="http://www.cnblogs.com/kenshincui/p/3985090.html">kenshin Cui 的技术博客</a>
        </li>
        <li>
        <a href="https://github.com/ming1016/study/wiki">戴明的技术笔记</a>
        </li>
</ul>
</section>

  
</aside>



    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Super Yang -
<!--添加站长工具--> 
 <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
<!--添加51统计-->
<script language="javascript" type="text/javascript" src="http://js.users.51.la/18738010.js"></script>
<noscript><a href="http://www.51.la/?18738010" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/18738010.asp" style="border:none" /></a></noscript>

</p>


<!--添加百度推送--> 
<script>

(function(){

    var bp = document.createElement('script');

    bp.src = '//push.zhanzhang.baidu.com/push.js';

    var s = document.getElementsByTagName("script")[0];

    s.parentNode.insertBefore(bp, s);

})();

</script>

</footer>
  











</body>
</html>
