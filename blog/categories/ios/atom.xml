<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | SuperYang`s Blog]]></title>
  <link href="http://yangchao0033.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yangchao0033.github.io/"/>
  <updated>2016-03-07T12:19:48+08:00</updated>
  <id>http://yangchao0033.github.io/</id>
  <author>
    <name><![CDATA[Super Yang]]></name>
    <email><![CDATA[757097678@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[让 iOS/Android 网络API开发更加自由-charles模拟服务器返回本地数据]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/03/05/develop-moblie-api-with-charles-and-server-data-with-charles/"/>
    <updated>2016-03-05T14:52:25+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/03/05/develop-moblie-api-with-charles-and-server-data-with-charles</id>
    <content type="html"><![CDATA[<blockquote><p><strong>原因：</strong>在与服务器联调接口之后，所有的API都能正常跑通，但是涉及到具体的业务逻辑时，比如界面遇到不同的数据做出特定的布局操作或弹框提示，再或者只有当数据字段符合特定的值时才能做出更多复杂的逻辑操作。如果依赖于服务器或者数据库，那么需要他们去帮你制造假数据来检测你的代码的正确性，这样是一次两次没问题，但是量大的时候，会影响双方的开发进度。能不能采取解耦的思想让移动端和服务端分隔开，在移动端测试开发阶段，自己根据接口文档制造自己需要的特定的返回数据呢？</p></blockquote>

<p><strong>解决方案：</strong>这时候我们需要自己的代理服务器来实现&ndash;使用 Charles 制作代理服务器。</p>

<p><strong>具体需求：</strong>当API有所改动时，服务器正在开发相应功能，但是还没有部署到服务器上去，只是在原接口的返回数据中多加了一个字段“id”。现在移动端的业务逻辑写好了，就等数据测试了。</p>

<p><strong>具体操作步骤：</strong></p>

<!--more-->


<p><strong>一、</strong>首先你需要下载一个 Charles，并且安装起来，具体的使用方法这里不做赘述。可以移步<a href="http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles">这里</a>学习。
<strong>二、</strong>抓取你需要修改的接口
<img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%8A%93%E5%8F%96%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3.png?raw=true" alt="抓取一个接口.png" />
大家可以看到，这个接口返回的是一个json串。这个请求是手机发起的，我们看到的只是软件抓到的包数据。那么如何加入新的“id”字段呢？)
大家可以看到，这个接口返回的是一个json串。这个请求是手机发起的，我们看到的只是软件抓到的包数据。那么如何加入新的“id”字段呢？</p>

<p><strong>三、</strong>使用 Charles 的 local map 功能</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%BF%9D%E5%AD%98response%E6%95%B0%E6%8D%AE.png?raw=true" alt="保存response数据.png" /></p>

<p>保存 response 数据到本地电脑上去</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E9%80%89%E6%8B%A9localmap.png?raw=true" alt="选择localmap.png" /></p>

<p>选择local map</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%B7%BB%E5%8A%A0%E9%9C%80%E8%A6%81map%E7%9A%84%E6%8E%A5%E5%8F%A3.png?raw=true" alt="添加需要map的接口.png" /></p>

<p>点击 Add 添加 map 规则</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/map%E8%A7%84%E5%88%99.png?raw=true" alt="map规则.png" />
这些地方填入你的API信息，以及刚才保存的 response 文件地址</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E7%82%B9%E5%87%BB%E4%BF%9D%E5%AD%98map.png?raw=true" alt="点击保存map.png" />
点击ok保存map规则。之后，只要是从你手机通过 Charles 代理发出的这个接口的请求，都会被重定向到你电脑上本地的 response 文件中。</p>

<p>现在，我们在通过手机调用一下之前的接口，结果呢？结果是还不如原来的，呵呵哒。。。</p>

<p>之前我们还能获取到 title、content和type三个字段以及他们的值，现在直接返回的数据为nil。</p>

<p>找了半天原因，最终通过对比发现了一个问题，两种请求的响应头不一样</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE.png?raw=true" alt="从服务器取到的数据.png" /></p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%9C%AC%E5%9C%B0map%E7%9A%84%E6%95%B0%E6%8D%AE.png?raw=true" alt="本地map的数据.png" /></p>

<p>所以怎么修改 response 的 content type 类型为 json/application 呢？</p>

<p><strong>三、</strong>使用 Rewrite 替换特定接口的响应头参数</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%89%93%E5%BC%80rewrite.png?raw=true" alt="打开rewrite.png" /></p>

<p>打开 Rewrite</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/rewrite%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2.png?raw=true" alt="rewrite配置页面.png" /></p>

<p>Rewrite 配置页面简介</p>

<p>1、首先创建一个规则集</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%B7%BB%E5%8A%A0%E6%8E%A5%E5%8F%A3%E9%9B%86%E5%90%88%E5%92%8C%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4.png?raw=true" alt="添加接口集合和适用范围.png" /></p>

<p>添加 Rewrite 替换规则</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%B9%A6%E5%86%99rewrite%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99.png?raw=true" alt="书写rewrite替换规则.png" /></p>

<p>这里相当于是在响应回来之前，通过字段的匹配，替换掉原有的响应头中的Content-Type 类型为 json/application</p>

<p>所有的对话框都点击 ok 或者 apply 确定保存</p>

<p>现在我们开始测试啦，继续调用该接口。</p>

<p>四、根据需求修改数据</p>

<p>数据修改前刚才看过了，只有 title/content/type 三个字段</p>

<pre><code class="json">{
"title":"标题",
"content":"内容正文",
"type":"类型"
}
</code></pre>

<p>而现在需要添加 “id” 字段。所以，用 vim 或者其他文本编辑器打开刚才保存的 response 文件，将他修改成这样</p>

<pre><code class="json">{
"id":"00000001",
"title":"标题",
"content":"内容正文",
"type":"类型"
}
</code></pre>

<p>修改后记得保存一下，现在重新开始请求该接口，查看log日志。</p>

<pre><code>{
"id":"00000001",
"title":"标题",
"content":"内容正文",
"type":"类型"
}
</code></pre>

<p>完美！下面开始愉快的测试我们自己的代码吧~</p>

<hr />

<h2>总结：</h2>

<h2>本文的目的主要是为了提高客户端和服务器各自独立开发的能力，像制造特定的假数据这种很简单的需求，如果不借助 Charles 代理去自己制造，恐怕你需要自己搭建一个服务器去各种恶补服务器的知识了。其实我们的原理十分简单，就是通过代理软件对网络请求进行拦截，并且返回我们想要的数据。这样做的好处就是，大大加强了客户端的自主开发能力，不需要依赖服务器对我们的特定逻辑进行开发，缩短开发周期。节约大家的时间，试想如果我们自己制造的数据如果在app中能跑通，即便服务器开发出来，如果出现跑不通的错误，那问题最有可能出现在服务器端，当然还要看具体的反馈信息。Charles 还有很多强大的功能，有待大家慢慢探索，祝大家玩得开心~</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HLS-iOS视频播放服务架构深入探究（二）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/02/14/hls-2/"/>
    <updated>2016-02-14T18:51:24+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/02/14/hls-2</id>
    <content type="html"><![CDATA[<p>HLS-Demo地址：<a href="https://github.com/yangchao0033/HLS-Demo">https://github.com/yangchao0033/HLS-Demo</a></p>

<p><strong>使用demo前请注意下面的问题，我在代码中也做了注释。</strong></p>

<pre><code class="objc">//#warning 注意，不要直接使用切换流的主索引，当前代码的协议只提供对.ts定位的子索引的下载和播放，而且其中只有点播协议那一小段是可以下载的，直播协议只能播放，无法下载，无法下载的原因是因为m3u8的那个库中只对特定的一种m3u8的格式做了解析，而m3u8的格式有很多种，所以无法加息出来，该demo只做演示，不会对所有格式进行全解析，如果大家感兴趣的话可以对m3u8的库进行扩展，在github 上 pull request 我做一个补充扩展😁，我会及时在博客中进行更新。博客地址：superyang.gitcafe.io或yangchao0033.github.io 同简书：http://www.jianshu.com/users/f37a8f0ba6f8/latest_articles

/** 点播协议 (只有这个是可以下载的，但是苦于太短，没办法播放出来，正在寻找可以下载并播放的新的点播或直播源,希望有读者可以帮忙提供哈，不甚感激~)*/
//#define TEST_HLS_URL @"http://m3u8.tdimg.com/147/806/921/3.m3u8"
/** 视频直播协议 */
/** 父索引(无法下载，只作为结构分析) */
//#define TEST_HLS_URL @"http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5.m3u8"
/** 子索引(无法下载，只作为结构分析) */
//#define TEST_HLS_URL @"http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5"
/** wwcd视频，果然苹果自己就用这个协议(无法下载，只作为结构分析) */
//#define TEST_HLS_URL @"http://devstreaming.apple.com/videos/wwdc/2015/413eflf3lrh1tyo/413/hls_vod_mvp.m3u8"
</code></pre>

<p>如果觉得文章有用的话，请读者在github上点个star😁，或者在<a href="http://www.jianshu.com/users/f37a8f0ba6f8/latest_articles">简书</a>上点个赞。</p>

<p>Demo配置原理：</p>

<p>1、 需要导入第三方库：ASIHttpRequest，CocoaHTTPServer，m3u8（其中ASI用于网络请求，CocoaHTTPServer用于在ios端搭建服务器使用，m3u8是用来对返回的索引文件进行解析的）</p>

<!--more-->


<p><img src="https://github.com/yangchao0033/HLS-Demo/blob/master/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%831.png?raw=true" alt="ASI配置注意事项" /></p>

<p><img src="https://github.com/yangchao0033/HLS-Demo/blob/master/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%832.png?raw=true" alt="MRC报错处理" /></p>

<p>2、导入系统库：libsqlite3.dylib、libz.dylib、libxml2.dylib、CoreTelephony.framework、SystemConfiguration.framework、MobileCoreServices.framework、Security.framework、CFNetwork.framework、MediaPlayer.framework</p>

<p>3、添加头文件</p>

<pre><code class="c">YCHLS-Demo.h
</code></pre>

<p>4、demo介绍
<img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/2/HLS_demo_UI.png?raw=true" alt="demo样式" /></p>

<ul>
<li><strong>播放：</strong>直接播放在线的直播链接，是由系统的MPMoviePlayer完成的，它自带解析HLS直播链的功能。</li>
<li><strong>下载：</strong>遵循HLS的协议，通过索引文件的资源路径下载相关的视频切片并保存到手机本地。</li>
<li><strong>播放本地视频：</strong>使用下载好的视频文件片段进行连续播放。</li>
<li><strong>清除缓存：</strong>删除下载好的视频片段</li>
</ul>


<p>原理：</p>

<ol>
<li>通过ASI请求链接，通过m3u8库解析返回的m3u8索引文件。</li>
<li>再通过ASI下载解析出的视频资源地址，仿照HLS中文件存储路径存储。</li>
<li>利用CocoaHTTPServer在iOS端搭建本地服务器，并开启服务，端口号为：12345（高位端口即可）。配置服务器路径与步骤二存储路径一致。</li>
<li>设置播放器直播链接为本地服务器地址，直接播放，由于播放器遵守HLS协议，所以能够解析我们之前使用HLS协议搭建的本地服务器地址。</li>
<li>点击在线播放，校验是否与本地播放效果一致。</li>
</ol>


<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/2/HLS%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%20.png?raw=true" alt="HLS协议文件存储结构" /></p>

<p>上面是HLS中服务器存储视频文件切片和索引文件的结构图</p>

<p>整个操作流程就是：</p>

<ol>
<li>先点击下载，通过解析m3u8的第三方库解析资源。（m3u8的那个库只能解析一种特定格式的m3u8文件，代码里会有标注）</li>
<li>点击播放本地视频播放下载好的资源。</li>
<li>点击播放是用来预览直播的效果，与整个流程无关。</li>
<li>其中进度条用来显示下载进度。</li>
</ol>


<blockquote><p>总结：
整个Demo并不只是让我们搭建一个Hls服务器或者一个支持Hls的播放器。目的在于了解Hls协议的具体实现，以及服务器端的一些物理架构。通过Demo的学习，可以详细的了解Hls直播具体的实现流程。</p></blockquote>

<p>部分源码贴出：</p>

<p>开启本地服务器：</p>

<pre><code class="objc">- (void)openHttpServer
{
    self.httpServer = [[HTTPServer alloc] init];
    [self.httpServer setType:@"_http._tcp."];  // 设置服务类型
    [self.httpServer setPort:12345]; // 设置服务器端口

    // 获取本地Library/Cache路径下downloads路径
    NSString *webPath = [kLibraryCache stringByAppendingPathComponent:kPathDownload];
    NSLog(@"-------------\nSetting document root: %@\n", webPath);
    // 设置服务器路径
    [self.httpServer setDocumentRoot:webPath];
    NSError *error;
    if(![self.httpServer start:&amp;error])
    {
        NSLog(@"-------------\nError starting HTTP Server: %@\n", error);
    }
</code></pre>

<p>视频下载：</p>

<pre><code class="objc">- (IBAction)downloadStreamingMedia:(id)sender {

    UIButton *downloadButton = sender;
    // 获取本地Library/Cache路径
    NSString *localDownloadsPath = [kLibraryCache stringByAppendingPathComponent:kPathDownload];

    // 获取视频本地路径
    NSString *filePath = [localDownloadsPath stringByAppendingPathComponent:@"XNjUxMTE4NDAw/movie.m3u8"];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    // 判断视频是否缓存完成，如果完成则播放本地缓存
    if ([fileManager fileExistsAtPath:filePath]) {
        [downloadButton setTitle:@"已完成" forState:UIControlStateNormal];
        downloadButton.enabled = NO;
    }else{
        M3U8Handler *handler = [[M3U8Handler alloc] init];
        handler.delegate = self;
        // 解析m3u8视频地址
        [handler praseUrl:TEST_HLS_URL];
        // 开启网络指示器
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
    }
}
</code></pre>

<p>播放本地视频：</p>

<pre><code class="objc">- (IBAction)playVideoFromLocal:(id)sender {

    NSString * playurl = [NSString stringWithFormat:@"http://127.0.0.1:12345/XNjUxMTE4NDAw/movie.m3u8"];
    NSLog(@"本地视频地址-----%@", playurl);

    // 获取本地Library/Cache路径
    NSString *localDownloadsPath = [kLibraryCache stringByAppendingPathComponent:kPathDownload];
    // 获取视频本地路径
    NSString *filePath = [localDownloadsPath stringByAppendingPathComponent:@"XNjUxMTE4NDAw/movie.m3u8"];
    NSFileManager *fileManager = [NSFileManager defaultManager];

    // 判断视频是否缓存完成，如果完成则播放本地缓存
    if ([fileManager fileExistsAtPath:filePath]) {
        MPMoviePlayerViewController *playerViewController =[[MPMoviePlayerViewController alloc]initWithContentURL:[NSURL URLWithString: playurl]];
        [self presentMoviePlayerViewControllerAnimated:playerViewController];
    }
    else{
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"Sorry" message:@"当前视频未缓存" delegate:self cancelButtonTitle:@"确定" otherButtonTitles:nil, nil];
        [alertView show];
    }
}
</code></pre>

<p>播放在线视频</p>

<pre><code class="objc">- (IBAction)playLiveStreaming {

    NSURL *url = [[NSURL alloc] initWithString:TEST_HLS_URL];
    MPMoviePlayerViewController *player = [[MPMoviePlayerViewController alloc] initWithContentURL:url];
    [self presentMoviePlayerViewControllerAnimated:player];
}
</code></pre>

<p>当然，《芈月传》的直播链接到现在也还没有找到，各位热心读者如果有链接的话可以留言给我，也让这篇文章能实至名归了，能对得文章的标题了😁。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HLS-iOS视频播放服务架构深入探究（一）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/29/hls-1/"/>
    <updated>2016-01-29T18:10:36+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/29/hls-1</id>
    <content type="html"><![CDATA[<h1>HTTP Live Streaming (HLS)</h1>

<p>苹果官方对于视频直播服务提出了 HLS 解决方案，该方案主要适用范围在于：</p>

<ul>
<li>使用 iPhone 、iPod touch、 iPad 以及 Apple TV 进行流媒体直播功能。（MAC 也能用）</li>
<li>不使用特殊的服务软件进行流媒体直播。</li>
<li>需要通过加密和鉴定（authentication）的视频点播服务。</li>
</ul>


<p>首先，需要大家先对 HLS 的概念进行预览。</p>

<!--more-->


<p>HLS 的目的在于，让用户可以在苹果设备（包括MAC OS X）上通过普通的网络服务完成流媒体的播放。 HLS 同时支持流媒体的<strong>实时广播</strong>和<strong>点播服务</strong>。同时也支持不同 bit 速率的<strong>多个备用流</strong>（平时根据当前网速去自适应视频的清晰度），这样客户端也好根据当前网络的带宽去只能调整当前使用的视频流。安全方面，HLS 提供了通过 HTTPS 加密对媒体文件进行加密 并 对用户进行验证，允许视频发布者去保护自己的网络。</p>

<p>HLS 是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p>

<p>HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p>

<p>苹果对于自家的 HLS 推广也是采取了强硬措施，当你的直播内容持续十分钟
或者每五分钟内超过 5 MB 大小时，你的 APP 直播服务必须采用 HLS 架构，否则不允许上架。（<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW5">详情</a>）</p>

<h1>相关服务支持环境 （重要组成）</h1>

<ul>
<li><code>Adobe Flash Media Server</code>：从4.5开始支持HLS、Protected HLS（PHLS）。5.0改名为Adobe Media Server</li>
<li><a href="http://www.flussonic.com/">Flussonic Media Server</a>：2009年1月21日，版本3.0开始支持VOD、HLS、时移等。</li>
<li>RealNetworks的 <code>Helix Universal Server</code> ：2010年4月，版本15.0开始支持iPhone, iPad和iPod的HTTP直播、点播H.264/AAC内容，最新更新在2012年11月。</li>
<li>微软的IIS Media Services：从4.0开始支持HLS。</li>
<li><code>Nginx RTMP Module</code>：支持直播模式的HLS。</li>
<li><a href="https://wmspanel.com/nimble">Nimber Streamer</a></li>
<li><a href="http://www.unified-streaming.com/">Unified Streaming Platform</a></li>
<li><a href="https://zh.wikipedia.org/wiki/VLC_Media_Player">VLC Media Player</a>：从2.0开始支持直播和点播HLS。</li>
<li>Wowza Media Server：2009年12月9日发布2.0，开始全面支持HLS。</li>
<li>VODOBOX Live Server：始支持HLS。</li>
<li><a href="http://github.com/i4tv/gstreamill">Gstreamill</a>是一个支持hls输出的，基于gstreamer的实时编码器。</li>
</ul>


<h1>相关客户端支持环境</h1>

<ul>
<li>iOS从3.0开始成为标准功能。</li>
<li>Adobe Flash Player从11.0开始支持HLS。</li>
<li>Google的Android自Honeycomb（3.0）开始支持HLS。</li>
<li>VODOBOX HLS Player (Android,iOS, Adobe Flash Player)</li>
<li>JW Player (Adobe Flash player)</li>
<li>Windows 10 的 EDGE 浏览器开始支持HLS。</li>
</ul>


<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/art/transport_stream_2x.png" alt="HLS架构" /></p>

<p>其中输入视频源是由摄像机预先录制好的。之后这些源会被编码 <code>MPEG-4</code>（H.264 video 和 AAC audio）格式然后用硬件打包到 <code>MPEG-2</code> 的传输流中。<code>MPEG-2</code> 传输流会被分散为小片段然后保存为一个或多个系列的 .ts 格式的媒体文件。这个过程需要借助编码工具来完成，比如 Apple stream segmenter。</p>

<p>纯音频会被编码为一些音频小片段，通常为 ADTS头的AAC、MP3、或者 AC-3格式。</p>

<p>同时上面提到的那个切片器（segmenter）也会创建一个索引文件，通常会包含这些媒体文件的一个列表，也能包含元数据。他一般都是一个.M38U 个hi的列表。列表元素会关联一个 URL 用于客户端访问。然后按序去请求这些 URL。</p>

<h3>服务器端</h3>

<p>服务端可以采用硬件编码和软件编码两种形式，其功能都是按照上文描述的规则对现有的媒体文件进行切片并使用索引文件进行管理。而软件切片通常会使用 Apple 公司提供的工具或者第三方的集成工具。</p>

<h4>媒体编码</h4>

<p>媒体编码器获取到音视频设备的实时信号，将其编码后压缩用于传输。而编码格式必须配置为客户端所支持的格式，比如 H.264 视频和HE-AAC 音频。当前，支持 用于视频的 MPEG-2 传输流和 纯音频 MPEG 基本流。编码器通过本地网络将 MPEG-2 传输流分发出去，送到流切片器那里。标准传输流和压缩传输流无法混合使用。传输流可以被打包成很多种不同的压缩格式，这里有两个表详细列举了支持的压缩格式类型。
* <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2">Audio Technologies</a>
* <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6">Vedio Technologies</a></p>

<h5>[重点]在编码中图，不要修改视频编码器的设置，比如视频大小或者编码解码器类型。如果避免不了，那修改动作必须发生在一个片段边界。并且需要早之后相连的片段上用 <code>EXT-X-DISCONTINUITY</code> 进行标记。</h5>

<h4>流切片器</h4>

<p>流切片器（通常是一个软件）会通过本地网络从上面的媒体编码器中读取数据，然后将着这些数据一组相等时间间隔的 <code>小</code> 媒体文件。虽然没一个片段都是一个单独的文件，但是他们的来源是一个连续的流，切完照样可以无缝重构回去。</p>

<p>切片器在切片同时会创建一个索引文件，索引文件会包含这些切片文件的引用。每当一个切片文件生成后，索引文件都会进行更新。索引用于追踪切片文件的有效性和定位切片文件的位置。切片器同时也可以对你的媒体片段进行加密并且创建一个密钥文件作为整个过程的一部分。</p>

<h4>文件切片器（相对于上面的流切片器）</h4>

<p>如果已近有编码后的文件（而不是编码流），你可以使用文件切片器，通过它对编码后的媒体文件进行 MPEG-2 流的封装并且将它们分割为等长度的小片段。切片器允许你使用已经存在的音视频库用于 HLS 服务。它和流切片器的功能相似，但是处理的源从流替换流为了文件。</p>

<h3>媒体片段文件</h3>

<p>媒体片段是由切片器生成的，基于编码后的媒体源，并且是由一系列的 <code>.ts</code> 格式的文件组成，其中包含了你想通过 MPEG-2 传送流携带的 H.264 视频 和 AAC
/MP3/AC-3 音频。对于纯音频的广播，切片器可以生产 MPEG 基础音频流，其中包含了 ADTS头的AAC、MP3、或者AC3等音频。</p>

<h3>索引文件（PlayLists）</h3>

<p>通常由切片器附带生成，保存为 <code>.M3U8</code> 格式，<code>.m3u</code> 一般用于 MP3 音频的索引文件。
<a href="">Note</a>如果你的扩展名是.m3u,并且系统支持.mp3文件，那客户的软件可能要与典型的 MP3 playList 保持一致来完成 流网络音频的播放。</p>

<p>下面是一个 <code>.M3U8</code> 的 playlist 文件样例，其中包含了三个没有加密的十秒钟的媒体文件：</p>

<pre><code>#EXT-X-VERSION:3
#EXTM3U
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:1

# Old-style integer duration; avoid for newer clients.
#EXTINF:10,
http://media.example.com/segment0.ts

# New-style floating-point duration; use for modern clients.
#EXTINF:10.0,
http://media.example.com/segment1.ts
#EXTINF:9.5,
http://media.example.com/segment2.ts
#EXT-X-ENDLIST
</code></pre>

<p>为了更精确，你可以在 version 3 或者之后的协议版本中使用 float 数来标记媒体片段的时长，并且要明确写明版本号，如果没有版本号，则必须与 version 1 协议保持一致。你可以使用官方提供的切片器去生产各种各样的 playlist 索引文件，详见 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7">媒体文件切片器</a></p>

<h3>分布式部分</h3>

<p>分布式系统是一个网络服务或者一个网络缓存系统，用于通过 HTTP 向客户端发送媒体文件和索引文件。不用自定义模块发送内容。通常仅仅需要很简单的网络配置即可使用。而且这种配置一般就是限制指定 .M38U 文件和 .ts 文件的 MIME 类型。详见 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3">部署 HTTP Live Streaming</a></p>

<h3>客户端部分</h3>

<p>客户端开始时回去抓取 索引文件(.m3u8/.m3u)，其中用URL来标记不同的流。索引文件可以指定可用媒体文件的位置，解密的密钥，以及任何可以切换的流。对于选中的流，客户端会有序的下载每一个可获得的文件。每一个文件都包含流中的连环碎片。一旦下载到足够量的数据，客户端会开始向用户展示重新装配好的媒体资源。</p>

<p>客户端负责抓取任何解密密钥，认证或者展示一个用于认证的界面，之后再解密需要的文件。</p>

<p>这个过程会一直持续知道出现 结束标记 <code>#EXT-X-ENDLIST</code>。如果结束标记不出现，该索引就是用于持续广播的。客户端会定期的加载一些新的索引文件。客户端会从新更新的索引文件中去查找加密密钥并且将关联的URL加入到请求队列中去。</p>

<h3>HLS 的使用</h3>

<p>使用 HLS 需要使用一些工具，当然大部分工具都是服务器端使用的，这里简单了解一下就行，包括 media stream segmenter, a media file segmenter, a stream validator, an id3 tag generator, a variant playlist generator.这些工具用英文注明是为了当你在<a href="https://developer.apple.com/">苹果开发中心</a>中寻找时方便一些。</p>

<h3>会话模式</h3>

<p>通常包含 Live 和 VOD （点播）两种</p>

<p><strong>点播VOD</strong>的特点就是可以获取到一个静态的索引文件，其中那个包含一套完整的资源文件地址。这种模式允许客户端访问全部节目。VOD点播拥有先进的下载技术，包括加密认证技术和动态切换文件传输速率的功能（通常用于不同分辨率视频之间的切换）。</p>

<p><strong>Live</strong> 会话就是实时事件的录制展示。它的索引文件一直处于动态变化的，你需要不断的更新索引文件 playlist 然后移除旧的索引文件。这种类型通过向索引文件添加媒体地址可以很容易的转化为VOD类型。在转化时不要移除原来旧的源，而是通过添加一个 <code>#ET-X-ENDLIST</code> 标记来终止实时事件。转化时如果你的索引文件中包含 <code>EXT-X-PLAYLIST-TYPE</code> 标签，你需要将值从 <code>EVENT</code> 改为 <code>VOD</code>。</p>

<p>ps:自己抓了一个直播的源，从索引中看到的结果是第一次回抓到代表不同带宽的playList(抓取地址：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5.m3u8</code>)</p>

<pre><code>#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056509,BANDWIDTH=700000,RESOLUTION=1280x720
34338_PVMT5_700/index.m3u8?Dnion_vsnae=34338_PVMT5
#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056535,BANDWIDTH=400000
34338_PVMT5_400/index.m3u8?Dnion_vsnae=34338_PVMT5
#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056535,BANDWIDTH=1024000
34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5
</code></pre>

<p>这里面的链接不是视频源URL，而是一个用于流切换的主索（下面会有介绍）引我猜想是需要对上一次的抓包地址做一个拼接</p>

<p>组合的结果就是：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5</code>(纯属小学智力题😂。。。)将它作为抓取地址再一次的结果</p>

<pre><code>#EXTM3U
#EXT-X-VERSION:3
#EXT-X-MEDIA-SEQUENCE:134611
#EXT-X-TARGETDURATION:10
#EXTINF:9.960,
35/1454056634183_128883.ts?Dnion_vsnae=34338_PVMT5
#EXTINF:9.960,
35/1454056644149_128892.ts?Dnion_vsnae=34338_PVMT5
#EXTINF:9.960,
35/1454056654075_128901.ts?Dnion_vsnae=34338_PVMT5
</code></pre>

<p>同理，继续向下抓：（拼接地址：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5/35/1454056634183_128883.ts?Dnion_vsnae=34338_PVMT5/36/1454059958599_131904.ts?Dnion_vsnae=34338_PVMT5</code>）
抓取结果：</p>

<pre><code>#EXTM3U
#EXT-X-VERSION:3
#EXT-X-MEDIA-SEQUENCE:134984
#EXT-X-TARGETDURATION:10
#EXTINF:9.280,
36/1454059988579_131931.ts?Dnion_vsnae=34338_PVMT5
#EXTINF:9.960,
36/1454059998012_131940.ts?Dnion_vsnae=34338_PVMT5
#EXTINF:9.960,
36/1454060007871_131949.ts?Dnion_vsnae=34338_PVMT5
</code></pre>

<p>相比于第二次又获取了一个片段的索引，而且只要是第二次之后，资源地址都会包含 <code>.ts</code>，说明里面是有视频资源URL的，不过具体的截取方法还是需要查看前面提到的IETF的那套标准的HLS的协议，利用里面的协议应该就能拼接出完整的资源路径进行下载。反正我用苹果自带的MPMoviePlayerController直接播放是没有问题的，的确是直播资源。与之前说过的苹果自带的QuickTime类似，都遵循了HLS协议用于流媒体播放。而每次通过拼接获取下一次的索引，符合协议里提到的不断的更替索引的动作。</p>

<h3>内容加密</h3>

<p>如果内容需要加密，你可以在索引文件中找到密钥的相关信息。如果索引文件中包含了一个密钥文件的信息，那接下来的媒体文件就必须使用密钥解密后才能解密打开了。当前的 HLS 支持使用16-octet 类型密钥的 AES-128 加密。这个密钥格式是一个由着在二进制格式中的16个八进制组的数组打包而成的。</p>

<p>加密的配置模式通常包含三种：
1. 模式一：允许你在磁盘上制定一个密钥文件路径，切片器会在索引文件中插入存在的密钥文件的 URL。所有的媒体文件都使用该密钥进行加密。
2. 模式二：切片器会生成一个随机密钥文件，将它保存在指定的路径，并在索引文件中引用它。所有的媒体文件都会使用这个随机密钥进行加密。
3. 模式三：每 n 个片段生成一个随机密钥文件，并保存到指定的位置，在索引中引用它。这个模式的密钥处于轮流加密状态。每一组 n 个片段文件会使用不同的密钥加密。</p>

<blockquote><p>理论上，不定期的碎片个数生成密钥会更安全，但是定期的生成密钥不会对系统的性能产生太大的影响。</p></blockquote>

<p>你可以通过 HTTP 或者 HTTPS 提供密钥。也可以选择使用你自己的基于会话的认证安排去保护发送的key。更多详情可以参考 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW2">通过 HTTPS 安全的提供预约</a></p>

<p>密钥文件需要一个 initialization vector (IV) 去解码加密的媒体文件。IV 可以随着密钥定期的改变。</p>

<h3>缓存和发送协议</h3>

<p>HTTPS通常用于发送密钥，同时，他也可以用于平时的媒体片段和索引文件的传输。但是当扩展性更重要时，这样做是不推荐的。HTTPS 请求通常都是绕开 web 服务缓存，导致所有内容请求都是通过你的服务进行转发，这有悖于分布式网络连接系统的目的。</p>

<p>处于这个原因，确保你发送的网络内容都明白非常重要。当处于实况广播模式时索引文件不会像分片媒体文件一样长时间的被缓存，他会动态不停地变化。</p>

<h3>流切换</h3>

<p>如果你的视频具备流切换功能，这对于用户来说是一个非常棒的体验，处于不同的带宽、不同的网速播放不同清晰度的视频流，这样只能的流切换可以保证用户感觉到非常流畅的观影体验，同时不同的设备也可以作为选择的条件，比如视网膜屏可以再网速良好的情况下播放清晰度更高的视频流。</p>

<p>这种功能的实现在于，索引文件的特殊结构</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/art/indexing_2x.png" alt="流切换索引文件结构" /></p>

<p>有别于普通的索引，具备流热切换的索引通常由主索引和链接不同带宽速率的资源的子索引，由子索引再链接对引得.ts视频切片文件。其中主索引只下载一次，而子索引则会不停定期的下载，通常会先使用主索引中列出的第一个子索引，之后才会根据当时的网络情况去动态切换合适的流。客户端会在任何时间去切换不同的流。比如连入或者退出一个 wifi 热点。所有的切换都会使用相同的音频文件（换音频没多大意思相对于视频）在不同的流之间平滑的进行切换。
这一套不同速率的视频都是有工具生成的，使用<code>variantplaylistcreator</code> 工具并且为 <code>mediafilesegmenter</code> 或者 <code>mediastreamsegmenter</code> 指定 -generate-variant-playlist 选项,详情参考 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW3">下载工具</a></p>

<p>概念先写到这吧，前面的知识够对HSL的整体结构做一个初步的了解。</p>

<p>后面一篇博客会结合代码对整个流程进行说明。</p>

<h4>参考文献：</h4>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html#//apple_ref/doc/uid/TP40008332-CH101-SW4">苹果官方文档</a></p>

<p><a href="https://zh.wikipedia.org/wiki/HTTP_Live_Streaming#.E5.AE.A2.E6.88.B7.E7.AB.AF.E6.94.AF.E6.8C.81">维基百科</a></p>

<p><a href="http://my.oschina.net/CgShare/blog/302303">http://my.oschina.net/CgShare/blog/302303</a></p>

<p><a href="http://blog.csdn.net/woaifen3344/article/details/40837803">http://blog.csdn.net/woaifen3344/article/details/40837803</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreText基础概念（扫盲篇）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/26/coretextji-chu/"/>
    <updated>2016-01-26T18:00:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/26/coretextji-chu</id>
    <content type="html"><![CDATA[<h2>CoreText 基础扫盲（阅读源码必看了）</h2>

<p>这段时间阅读ibireme神的源码，看到了 CoreText 排版这一块，里面包含了很多文字排版的专有名词，这里做一下整理，顺便帮大家安利一下。</p>

<p>CoreText 框架中最常用的几个类：</p>

<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFontRef/Reference/reference.html#//apple_ref/doc/uid/TP40005110">CTFont</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFontCollectionRef/Reference/reference.html#//apple_ref/doc/uid/TP40005104">CTFontCollection</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFontDescriptorRef/Reference/reference.html#//apple_ref/doc/uid/TP40005107">CTFontDescriptor</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFrameRef/Reference/reference.html#//apple_ref/doc/uid/TP40005113">CTFrame</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTFramesetterRef/Reference/reference.html#//apple_ref/doc/uid/TP40005105">CTFramesetter</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTGlyphInfoRef/Reference/reference.html#//apple_ref/doc/uid/TP40005108">CTGlyphInfo</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTLineRef/Reference/reference.html#//apple_ref/doc/uid/TP40005111">CTLine</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTParagraphStyleRef/Reference/reference.html#//apple_ref/doc/uid/TP40005114">CTParagraphStyle</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTRunRef/Reference/reference.html#//apple_ref/doc/uid/TP40005106">CTRun</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTTextTabRef/Reference/reference.html#//apple_ref/doc/uid/TP40005109">CTTextTab</a></li>
<li><a href="https://developer.apple.com/library/mac/documentation/Carbon/Reference/CTTypesetterRef/Reference/reference.html#//apple_ref/doc/uid/TP40005112">CTTypesett</a></li>
</ul>


<p>下面是该框架的结构图</p>

<!--more-->


<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/CoreText%E6%9E%B6%E6%9E%84%E5%9B%BE.png?raw=true" alt="coretext架构图" /></p>

<p>CTFrame 作为一个整体的画布(Canvas)，其中由行(CTLine)组成，而每行可以分为一个或多个小方块（CTRun）。
注意：你不需要自己创建CTRun，Core Text将根据NSAttributedString的属性来自动创建CTRun。每个CTRun对象对应不同的属性，正因此，你可以自由的控制字体、颜色、字间距等等信息。
通常处理步聚：
1.使用core text就是先有一个要显示的string，然后定义这个string每个部分的样式－>attributedString －> 生成 CTFramesetter -> 得到CTFrame -> 绘制（CTFrameDraw）
其中可以更详细的设置换行方式，对齐方式，绘制区域的大小等。
2.绘制只是显示，点击事件就需要一个判断了。
CTFrame 包含了多个CTLine,并且可以得到各个line的其实位置与大小。判断点击处在不在某个line上。CTLine 又可以判断这个点(相对于ctline的坐标)处的文字范围。然后遍历这个string的所有NSTextCheckingResult，根据result的rang判断点击处在不在这个rang上，从而得到点击的链接与位置。</p>

<h3>字体的基本知识</h3>

<p><strong>字体(Font):</strong>是一系列字号、样式和磅值相同的字符(例如:10磅黑体Palatino)。现多被视为字样的同义词</p>

<p><strong>字面(Face):</strong>是所有字号的磅值和格式的综合</p>

<p><strong>字体集(Font family):</strong>是一组相关字体(例如:Franklin family包括Franklin Gothic、Fran-klinHeavy和Franklin Compressed)</p>

<p><strong>磅值(Weight):</strong>用于描述字体粗度。典型的磅值,从最粗到最细,有极细、细、book、中等、半粗、粗、较粗、极粗</p>

<p><strong>样式(Style):</strong>字形有三种形式:Roman type是直体;oblique type是斜体;utakuc type是斜体兼曲线(比Roman type更像书法体)。</p>

<p><strong>x高度(X height):</strong>指小写字母的平均高度(以x为基准)。磅值相同的两字母,x高度越大的字母看起来比x高度小的字母要大</p>

<p><strong>Cap高度(Cap height):</strong>与x高度相似。指大写字母的平均高度(以C为基准)</p>

<p><strong>下行字母(Descender):</strong>例如在字母q中,基线以下的字母部分叫下伸部分</p>

<p><strong>上行字母(Ascender):</strong>x高度以上的部分(比如字母b)叫做上伸部分</p>

<p><strong>基线(Baseline):</strong>通常在x、v、b、m下的那条线
描边(Stroke):组成字符的线或曲线。可以加粗或改变字符形状</p>

<p><strong>衬线(Serif):</strong>用来使字符更可视的一条水平线。如字母左上角和下部的水平线。</p>

<p><strong>无衬线(Sans Serif):</strong>可以让排字员不使用衬线装饰。</p>

<p><strong>方形字(Block):</strong>这种字体的笔画使字符看起来比无衬线字更显眼,但还不到常见的衬线字的程度。例如Lubalin Graph就是方形字,这种字看起来好像是木头块刻的一样</p>

<p><strong>手写体脚本(Calligraphic script):</strong>是一种仿效手写体的字体。例如Murray Hill或者Fraktur字体</p>

<p><strong>艺术字(Decorative):</strong>像绘画般的字体</p>

<p><strong>Pi符号(Pisymbol):</strong>非标准的字母数字字符的特殊符号。例如Wingdings和Mathematical Pi</p>

<p><strong>连写(Ligature):</strong>是一系列连写字母如fi、fl、ffi或ffl。由于字些字母形状的原因经常被连写,故排字员已习惯将它们连写。</p>

<p>读完了上面这些概念，可以参考一下下面的图片，看看具体的位置</p>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/%E6%96%87%E5%AD%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%860.gif?raw=true" alt="文字结构" />
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/%E6%96%87%E5%AD%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861.gif?raw=true" alt="文字结构" /></p>

<p>其中，在 Apple 的 SDK 中是这样定义这些属性的</p>

<pre><code class="objc">const CFStringRef kCTCharacterShapeAttributeName;              
//字体形状属性  必须是CFNumberRef对象默认为0，非0则对应相应的字符形状定义，如1表示传统字符形状

const CFStringRef kCTFontAttributeName;                        
//字体属性   必须是CTFont对象

const CFStringRef kCTKernAttributeName;                        
//字符间隔属性 必须是CFNumberRef对象

const CFStringRef kCTLigatureAttributeName;                 
//设置是否使用连字属性，设置为0，表示不使用连字属性。标准的英文连字有FI,FL.默认值为1，既是使用标准连字。也就是当搜索到f时候，会把fl当成一个文字。必须是CFNumberRef 默认为1,可取0,1,2

const CFStringRef kCTForegroundColorAttributeName;             
//字体颜色属性  必须是CGColor对象，默认为black

const CFStringRef kCTForegroundColorFromContextAttributeName; 
 //上下文的字体颜色属性 必须为CFBooleanRef 默认为False

const CFStringRef kCTParagraphStyleAttributeName;              
//段落样式属性 必须是CTParagraphStyle对象 默认为NIL

const CFStringRef kCTStrokeWidthAttributeName;              
//笔画线条宽度 必须是CFNumberRef对象，默为0.0f，标准为3.0f
const CFStringRef kCTStrokeColorAttributeName;              
//笔画的颜色属性 必须是CGColorRef 对象，默认为前景色

const CFStringRef kCTSuperscriptAttributeName;              
//设置字体的上下标属性 必须是CFNumberRef对象 默认为0,可为-1为下标,1为上标，需要字体支持才行。如排列组合的样式Cn1

const CFStringRef kCTUnderlineColorAttributeName;           
//字体下划线颜色属性 必须是CGColorRef对象，默认为前景色

const CFStringRef kCTUnderlineStyleAttributeName;           
//字体下划线样式属性 必须是CFNumberRef对象,默为kCTUnderlineStyleNone 可以通过CTUnderlineStypleModifiers 进行修改下划线风格

const CFStringRef kCTVerticalFormsAttributeName;
//文字的字形方向属性 必须是CFBooleanRef 默认为false，false表示水平方向，true表示竖直方向

const CFStringRef kCTGlyphInfoAttributeName;
//字体信息属性 必须是CTGlyphInfo对象

const CFStringRef kCTRunDelegateAttributeName
//CTRun 委托属性 必须是CTRunDelegate对象
</code></pre>

<p>例如：</p>

<pre><code class="objc">NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:@"This is a test of characterAttribute. 中文字符"];
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex0.jpg?raw=true" alt="文字结构" /></p>

<pre><code class="objc">  //设置字体属性
    CTFontRef font = CTFontCreateWithName(CFSTR("Georgia"), 40, NULL);
    [mabstring addAttribute:(id)kCTFontAttributeName value:(id)font range:NSMakeRange(0, 4)]; 
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex1.jpg?raw=true" alt="文字结构" /></p>

<pre><code class="objc">//设置斜体字
    CTFontRef font = CTFontCreateWithName((CFStringRef)[UIFont italicSystemFontOfSize:20].fontName, 14, NULL);
    [mabstring addAttribute:(id)kCTFontAttributeName value:(id)font range:NSMakeRange(0, 4)];
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex2.jpg?raw=true" alt="文字结构" /></p>

<pre><code class="objc">//下划线
    [mabstring addAttribute:(id)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; 
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex3.jpg?raw=true" alt="文字结构" /></p>

<pre><code class="objc">//下划线颜色
    [mabstring addAttribute:(id)kCTUnderlineColorAttributeName value:(id)[UIColor redColor].CGColor range:NSMakeRange(0, 4)];
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex4.jpg?raw=true" alt="文字结构" /></p>

<pre><code class="objc">//设置字体简隔 eg:test 
    long number = 10;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTKernAttributeName value:(id)num range:NSMakeRange(10, 4)];
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex5.jpg?raw=true" alt="文字结构" /></p>

<pre><code class="objc">//设置连字
long number = 1;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTLigatureAttributeName value:(id)num range:NSMakeRange(0, [str length])];
</code></pre>

<p>暂时没有效果图</p>

<pre><code class="objc">//设置字体颜色
    [mabstring addAttribute:(id)kCTForegroundColorAttributeName value:(id)[UIColor redColor].CGColor range:NSMakeRange(0, 9)];
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex6.jpg?raw=true" alt="文字结构" /></p>

<pre><code class="objc">//设置字体颜色为前影色
    CFBooleanRef flag = kCFBooleanTrue;
    [mabstring addAttribute:(id)kCTForegroundColorFromContextAttributeName value:(id)flag range:NSMakeRange(5, 10)];
</code></pre>

<p>暂无效果。。</p>

<pre><code class="objc">//设置空心字
    long number = 2;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTStrokeWidthAttributeName value:(id)num range:NSMakeRange(0, [str length])];
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex7.jpg?raw=true" alt="文字结构" /></p>

<pre><code class="objc">//设置空心字
    long number = 2;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTStrokeWidthAttributeName value:(id)num range:NSMakeRange(0, [str length])];

    //设置空心字颜色
    [mabstring addAttribute:(id)kCTStrokeColorAttributeName value:(id)[UIColor greenColor].CGColor range:NSMakeRange(0, [str length])];
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex8.jpg?raw=true" alt="文字结构" /></p>

<p><strong>在设置空心字颜色时，必须先将字体高为空心，否则设置颜色是没有效果的。</strong></p>

<pre><code class="objc">
//对同一段字体进行多属性设置    
    //红色
    NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithObject:(id)[UIColor redColor].CGColor forKey:(id)kCTForegroundColorAttributeName];
    //斜体
    CTFontRef font = CTFontCreateWithName((CFStringRef)[UIFont italicSystemFontOfSize:20].fontName, 40, NULL);
    [attributes setObject:(id)font forKey:(id)kCTFontAttributeName];
    //下划线
    [attributes setObject:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] forKey:(id)kCTUnderlineStyleAttributeName];

    [mabstring addAttributes:attributes range:NSMakeRange(0, 4)];
</code></pre>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2016/1/image/ex9.jpg?raw=true" alt="文字结构" /></p>

<p>最后 Draw 一下</p>

<pre><code class="objc">
-(void)characterAttribute
{
    NSString *str = @"This is a test of characterAttribute. 中文字符";
    NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:str];

    [mabstring beginEditing];
    /*
    long number = 1;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTCharacterShapeAttributeName value:(id)num range:NSMakeRange(0, 4)];
    */
    /*
    //设置字体属性
    CTFontRef font = CTFontCreateWithName(CFSTR("Georgia"), 40, NULL);
    [mabstring addAttribute:(id)kCTFontAttributeName value:(id)font range:NSMakeRange(0, 4)];
    */
    /*
    //设置字体简隔 eg:test 
    long number = 10;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTKernAttributeName value:(id)num range:NSMakeRange(10, 4)];
    */

    /*
    long number = 1;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTLigatureAttributeName value:(id)num range:NSMakeRange(0, [str length])];
     */
    /*
    //设置字体颜色
    [mabstring addAttribute:(id)kCTForegroundColorAttributeName value:(id)[UIColor redColor].CGColor range:NSMakeRange(0, 9)];
     */
    /*
    //设置字体颜色为前影色
    CFBooleanRef flag = kCFBooleanTrue;
    [mabstring addAttribute:(id)kCTForegroundColorFromContextAttributeName value:(id)flag range:NSMakeRange(5, 10)];
     */

    /*
    //设置空心字
    long number = 2;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTStrokeWidthAttributeName value:(id)num range:NSMakeRange(0, [str length])];

    //设置空心字颜色
    [mabstring addAttribute:(id)kCTStrokeColorAttributeName value:(id)[UIColor greenColor].CGColor range:NSMakeRange(0, [str length])];
     */

    /*
    long number = 1;
    CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number);
    [mabstring addAttribute:(id)kCTSuperscriptAttributeName value:(id)num range:NSMakeRange(3, 1)];
    */

    /*
    //设置斜体字
    CTFontRef font = CTFontCreateWithName((CFStringRef)[UIFont italicSystemFontOfSize:20].fontName, 14, NULL);
    [mabstring addAttribute:(id)kCTFontAttributeName value:(id)font range:NSMakeRange(0, 4)];
    */ 

    /*
    //下划线
    [mabstring addAttribute:(id)kCTUnderlineStyleAttributeName value:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] range:NSMakeRange(0, 4)]; 
    //下划线颜色
    [mabstring addAttribute:(id)kCTUnderlineColorAttributeName value:(id)[UIColor redColor].CGColor range:NSMakeRange(0, 4)];
     */



    //对同一段字体进行多属性设置    
    //红色
    NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithObject:(id)[UIColor redColor].CGColor forKey:(id)kCTForegroundColorAttributeName];
    //斜体
    CTFontRef font = CTFontCreateWithName((CFStringRef)[UIFont italicSystemFontOfSize:20].fontName, 40, NULL);
    [attributes setObject:(id)font forKey:(id)kCTFontAttributeName];
    //下划线
    [attributes setObject:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] forKey:(id)kCTUnderlineStyleAttributeName];

    [mabstring addAttributes:attributes range:NSMakeRange(0, 4)];



    NSRange kk = NSMakeRange(0, 4);

    NSDictionary * dc = [mabstring attributesAtIndex:0 effectiveRange:&amp;kk];

    [mabstring endEditing];

    NSLog(@"value = %@",dc);



    CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring);

    CGMutablePathRef Path = CGPathCreateMutable();

    CGPathAddRect(Path, NULL ,CGRectMake(10 , 0 ,self.bounds.size.width-10 , self.bounds.size.height-10));

    CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL);    

    //获取当前(View)上下文以便于之后的绘画，这个是一个离屏。
    CGContextRef context = UIGraphicsGetCurrentContext();

    CGContextSetTextMatrix(context , CGAffineTransformIdentity);

    //压栈，压入图形状态栈中.每个图形上下文维护一个图形状态栈，并不是所有的当前绘画环境的图形状态的元素都被保存。图形状态中不考虑当前路径，所以不保存
    //保存现在得上下文图形状态。不管后续对context上绘制什么都不会影响真正得屏幕。
    CGContextSaveGState(context);

    //x，y轴方向移动
    CGContextTranslateCTM(context , 0 ,self.bounds.size.height);

    //缩放x，y轴方向缩放，－1.0为反向1.0倍,坐标系转换,沿x轴翻转180度
    CGContextScaleCTM(context, 1.0 ,-1.0);

    CTFrameDraw(frame,context);

    CGPathRelease(Path);
    CFRelease(framesetter);
}


- (void)drawRect:(CGRect)rect
{
    [self characterAttribute];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CocoaPod Version Update]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/18/cocoapod-version-update/"/>
    <updated>2016-01-18T15:58:44+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/18/cocoapod-version-update</id>
    <content type="html"><![CDATA[<h3>问题描述：</h3>

<p>使用 pod 安装第三方库时无法使用 <code>pod search</code> 搜索最新的版本</p>

<h3>定位问题：</h3>

<p>使用的 pod 版本过低</p>

<h3>方案：</h3>

<!--more-->


<p>升级pod版本
<code>
$ sudo gem update --system
$ gem sources --remove https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
$ sudo gem install cocoapods
$ pod setup
</code>
line 1: 为 <code>gem</code> 升级到最新版<br/>
line 2: 删除 <code>gem</code> 默认的源<br/>
line 3: 添加淘宝的源，为了解除天朝对gem的隔离（ps：<code>gem</code> 到底干了啥，这么苦大仇深？）<br/>
line 4: 安装 <code>CocoaPod</code> (会去新加的源去检查是否有新的内容，有则更新，保持你本地pod拥有最新的库信息)<br/>
line 5: <code>pod</code> 安装将利用刚才的配置更新本地镜像</p>

<h3>使用：</h3>

<p>继续使用 <code>pod search 库名</code>
例如： <code>pod search ReactiveCocoa</code></p>

<p>就能搜到最新的库版本了</p>
]]></content>
  </entry>
  
</feed>
