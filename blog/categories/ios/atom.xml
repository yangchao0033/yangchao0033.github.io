<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | SuperYang`s Blog]]></title>
  <link href="http://yangchao0033.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yangchao0033.github.io/"/>
  <updated>2016-01-04T11:56:59+08:00</updated>
  <id>http://yangchao0033.github.io/</id>
  <author>
    <name><![CDATA[Super Yang]]></name>
    <email><![CDATA[757097678@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[宏定义的高级用法]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/definede-gao-ji-yong-fa/"/>
    <updated>2016-01-04T11:44:51+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/definede-gao-ji-yong-fa</id>
    <content type="html"><![CDATA[<p>1、# （stringizing）字符串化操作符。其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。
如：</p>

<pre><code class="c">#define example(instr) printf("the input string is:\t%s\n",#instr)
#define example1(instr) #instr
</code></pre>

<p>当使用该宏定义时：</p>

<!--more-->


<pre><code class="c">example(abc)；
</code></pre>

<p> 在编译时将会展开成：</p>

<pre><code>printf("the input string is:\t%s\n","abc");
string str=example1(abc);
</code></pre>

<p>将会展成：</p>

<p><code>string str="abc";</code></p>

<p>注意：
对空格的处理
a。忽略传入参数名前面和后面的空格。</p>

<p>   如：<code>str=example1(   abc )</code>； 将会被扩展成<code>str="abc"</code>；</p>

<p>b.当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串中只以一个空格连接，忽略其中多余一个的空格。</p>

<p>   如：<code>str=exapme( abc    def)</code>; 将会被扩展成 <code>str="abc def"</code>；</p>

<p>2、## （token-pasting）符号连接操作符(让参数值转换为参数名)
宏定义中：参数名，即为形参，如#define sum(a,b) (a+b)；中a和b均为某一参数的代表符号，即形式参数。
而##的作用则是将宏定义的多个形参成一个实际参数名。</p>

<p>如：</p>

<p><code>#define exampleNum(n) num##n
</code></p>

<p><code>int num9=9</code>;</p>

<p>使用：</p>

<p><code>int num=exampleNum(9)</code>;</p>

<p>将会扩展成 <code>int num=num9</code>;</p>

<p>注意：</p>

<p>1.当用##连接形参时，##前后的空格可有可无。</p>

<p>如：<code>#define exampleNum(n) num ## n</code>相当于 <code>#define exampleNum(n) num##n</code></p>

<p>2.连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义</p>

<p>// preprocessor_token_pasting.cpp</p>

<pre><code>#include 
#define paster( n ) printf_s( "token" #n " = %d", token##n )
int token9 = 9;
int main()
{
   paster(9);
}
</code></pre>

<p>运行结果：</p>

<p><code>token9 = 9</code></p>

<p>3、@# （charizing）字符化操作符。
只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。作用是将传的单字符参数名转换成字符，以一对单引用括起来。</p>

<p><code>#define makechar(x)  #@x
a = makechar(b);</code></p>

<p>展开后变成了：</p>

<p><code>a= 'b';</code></p>

<p>4、\ 行继续操作符
当定义的宏不能用一行表达完整时，可以用"\&ldquo;表示下一行继续此宏的定义。</p>

<p><a href="http://blog.csdn.net/hjmhz/article/details/8667185">更多高级用法&hellip;</a></p>

<p><a href="http://blog.chinaunix.net/uid-23254875-id-341055.html">转自http://blog.chinaunix.net/uid-23254875-id-341055.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于block使用的5点注意事项]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/guan-yu-blockshi-yong-de-5dian-zhu-yi-shi-xiang-d/"/>
    <updated>2016-01-04T11:24:25+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/guan-yu-blockshi-yong-de-5dian-zhu-yi-shi-xiang-d</id>
    <content type="html"><![CDATA[<p><div class="post">
        <div class="clear"></div>
        <div class="postBody">
            <div id="cnblogs_post_body"><div id="main-content" class="wiki-content">
<p>1、在使用block前需要对block指针做判空处理。</p>
<p>不判空直接使用，一旦指针为空直接产生崩溃。</p>
</div>
<div class="wiki-content">
<pre><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">self.isOnlyNet) {
    </span><span style="color: #0000ff;">if</span> (succBlock == NULL) { <span style="color: #008000;">//</span><span style="color: #008000;">后面使用block之前要先做判空处理</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">id</span> data =<span style="color: #000000;"> [NSKeyedUnarchiver unarchiveObjectWithFile:[self favoriteFile]];
    </span><span style="color: #0000ff;">if</span> ([data isKindOfClass:[NSMutableArray <span style="color: #0000ff;">class</span><span style="color: #000000;">]]) {
        succBlock(data,YES);
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        succBlock(nil,YES);
    }
}</span></pre>
<p>&nbsp;</p>
</div>
<!--more-->
<div class="wiki-content">2、在MRC的编译环境下，block如果作为成员参数要copy一下将栈上的block拷贝到堆上（示例见下，<a class="external-link" href="http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html" rel="nofollow">原因参考</a>）
<p>3、在block使用之后要对，block指针做赋空值处理，如果是MRC的编译环境下，要先release掉block对象。</p>
<p>block作为类对象的成员变量，使用block的人有可能用类对象参与block中的运算而产生循环引用。</p>
<p>将block赋值为空，是解掉循环引用的重要方法。（不能只在dealloc里面做赋空值操作，这样已经产生的循环引用不会被破坏掉）</p>
<pre>typedef <span style="color: #0000ff;">void</span>(^SuccBlock)(<span style="color: #0000ff;">id</span><span style="color: #000000;"> data);
</span><span style="color: #0000ff;">@interface</span><span style="color: #000000;"> NetworkClass {
    SuccessBlock _sucBlock;
}
@property (nonatomic,assign)BOOL propertyUseInCallBack;
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) requestWithSucBlock: (SuccessBlock) callbackBlock;
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> NetworkClass
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) requestWithSucBlock: (SuccessBlock) callbackBlock {
    <em>sucBlock </span>= callbackBlock;<span style="color: #008000;">//</span><span style="color: #008000;">MRC下：</em>sucBlock = [callbackBlock copy]; 不copy block会在栈上被回收。</span>
<span style="color: #000000;">}</p>

<p></span>- (<span style="color: #0000ff;">void</span>) netwrokDataBack: (<span style="color: #0000ff;">id</span><span style="color: #000000;">) data {
    </span><span style="color: #0000ff;">if</span> (data != nil &amp;&amp; <em>sucBlock !=<span style="color: #000000;"> NULL) {
        </em>sucBlock(data);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">MRC下：要先将[<em>sucBlock release];（之前copy过）</span>
    </em>sucBlock = nil; <span style="color: #008000;">//</span><span style="color: #008000;">Importent: 在使用之后将Block赋空值，解引用 !!!</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #008000;">//</span><span style="color: #008000;">=======================以下是使用方===========================</span>
<span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> UserCode
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) temporaryNetworkCall
{
    NetworkClass </span><em>netObj =<span style="color: #000000;"> [[NetworkClass alloc] init];
    netObj.propertyUseInCallBack </span>=<span style="color: #000000;"> NO;
    [netObj requestWithSucBlock: </span>^(<span style="color: #0000ff;">id</span><span style="color: #000000;"> data) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">由于block里面引用netObj的指针所以这里产生了循环引用，且由于这个block是作为参数传入对象的，编译器不会报错。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">因此，NetworkClass使用完block之后一定要将作为成员变量的block赋空值。</span>
        <span style="color: #0000ff;">if</span> (netObj.propertyUseInCallBack ==<span style="color: #000000;"> YES) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">Do Something&hellip;</span>
<span style="color: #000000;">        }
    }];
}
</span><span style="color: #0000ff;">@end</span></pre>
<p>&nbsp;</p>
<p>还有一种改法，在block接口设计时，将可能需要的变量作为形参传到block中，从设计上解决循环引用的问题。</p>
<p>如果上面Network类设计成这个样子：</p>
<div class="code panel pdl" style="border-width: 1px;">
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">
<pre><span style="color: #0000ff;">@class</span><span style="color: #000000;"> NetowrkClass;
typedef </span><span style="color: #0000ff;">void</span>(^SuccBlock)(NetworkClass </em>aNetworkObj, <span style="color: #0000ff;">id</span><span style="color: #000000;"> data);
</span><span style="color: #0000ff;">@interface</span><span style="color: #000000;"> NetworkClass
</span><span style="color: #008000;">//</span><span style="color: #008000;">&hellip;</span>
<span style="color: #0000ff;">@end</span>
<span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> NetworkClass
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> UserCode
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) temporaryNetworkCall
{
    NetworkClass </span><em>netObj =<span style="color: #000000;"> [[NetworkClass alloc] init];
    netObj.propertyUseInCallBack </span>=<span style="color: #000000;"> NO;
    [netObj requestWithSucBlock: </span>^(NetworkClass </em>aNetworkObj, <span style="color: #0000ff;">id</span><span style="color: #000000;"> data) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">这里参数中已经有netObj的对象了，使用者不用再从block外引用指针了。</span>
        <span style="color: #0000ff;">if</span> (aNetworkObj.propertyUseInCallBack ==<span style="color: #000000;"> YES) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">Do Something&hellip;</span>
<span style="color: #000000;">        }
    }];
}
</span><span style="color: #0000ff;">@end</span></pre>
<p>&nbsp;</p>
</div>
</div>
<p>4、使用方将self或成员变量加入block之前要先将self变为<strong>weak</p>
<p>5、在多线程环境下（block中的weakSelf有可能被析构的情况下），需要先将self转为strong指针，避免在运行到某个关键步骤时self对象被析构。</p>
<p>第四、第五条合起来有个名词叫weak–strong dance，来自于<a class="external-link" style="text-decoration: none;" href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDkQFjAA&amp;url=%68%74%74%70%3a%2f%2f%64%65%76%65%6c%6f%70%65%72%2e%61%70%70%6c%65%2e%63%6f%6d%2f%76%69%64%65%6f%73%2f%77%77%64%63%2f%32%30%31%31%2f&amp;ei=mDl_UcKaEtDZkgXG14GoDg&amp;usg=AFQjCNENM0Mbw7vrvpPYNzjg2R9u6IUiEA&amp;sig2=wwwajZBQ62fO7EsU4RvSOg&amp;bvm=bv.45645796,d.dGI&amp;cad=rjt" rel="nofollow">2011 WWDC Session #322 (Objective-C Advancements in Depth）</a></p>
<p>以下代码来自AFNetworking，堪称使用weak–strong dance的经典。</p>
<div class="code panel pdl" style="border-width: 1px;">
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">
<pre></strong>weak <strong>typeof(self)weakSelf =<span style="color: #000000;"> self;
AFNetworkReachabilityStatusBlock callback </span>= ^<span style="color: #000000;">(AFNetworkReachabilityStatus status) {
    </strong>strong <strong>typeof(weakSelf)strongSelf </span>=<span style="color: #000000;"> weakSelf;
    strongSelf.networkReachabilityStatus </span>=<span style="color: #000000;"> status;
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (strongSelf.networkReachabilityStatusBlock) {
        strongSelf.networkReachabilityStatusBlock(status);
    }
};</span></pre>
</div>
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">Review一下上面这段代码，里面玄机不少。</div>
</div>
<p>第一行：</strong>weak <strong>typeof(self)weakSelf = self;</p>
<p>如之前第四条所说，为防止callback内部对self强引用，weak一下。</p>
<p>其中用到了</strong>typeof(self)，这里涉及几个知识点：</p>
<p>a. <strong>typeof、</strong>typeof<strong>、typeof的区别</p>
<p>恩~~他们没有区别，但是这牵扯一段往事，在早期C语言中没有typeof这个关键字，</strong>typeof、<strong>typeof</strong>是在C语言的扩展关键字的时候出现的。</p>
<p>typeof是现代GNU C++的关键字，从Objective-C的根源说，他其实来自于C语言，所以AFNetworking使用了继承自C的关键字。</p>
<p>b.对于老的LLVM编译器上面这句话会编译报错，所以在很早的ARC使用者中流行<strong>typeof(&amp;*self)这种写法，<a class="external-link" href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references/" rel="nofollow">原因如下</a></p>
<p>大致说法是老LLVM编译器会将</strong>typeof转义为 XXX类名 <em>const <strong>strong的</strong>strong和前面的__weak关键字对指针的修饰又冲突了，所以加上&amp;</em>对指针的修饰。</p>
<p>第三行：<strong>strong </strong>typeof(weakSelf)strongSelf = weakSelf;</p>
<p>按照之前第五条的说法给转回strong了，这里__typeof()里面写的是weakSelf，里面写self也没有问题，因为typeof是编译时确定变量类型，所以这里写self 不会被循环引用。</p>
<p>第四、五、六行，如果不转成strongSelf而使用weakSelf，后面几句话中，有可能在第四句执行之后self的对象可能被析构掉，然后后面的StausBlock没有执行，导致逻辑错误。</p>
<p>最后第五行，使用前对block判空。</p>
<p>&nbsp;</p>
<p>写在最后，阅读好的开源库源码是提高个人水平的一个很好途径，看见不懂的地方去查去摸索会得到更多。</p>
<p>&nbsp;</p>
<p>参考：</p>
<p><a class="external-link" href="http://blog.csdn.net/fhbystudy/article/details/17350951" rel="nofollow"><a href="http://blog.csdn.net/fhbystudy/article/details/17350951">http://blog.csdn.net/fhbystudy/article/details/17350951</a></a></p>
<p><a class="external-link" href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references" rel="nofollow"><a href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references">http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references</a></a></p>
<p><a class="external-link" href="http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c" rel="nofollow"><a href="http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c">http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c</a></a></p>
<p><a class="external-link" href="http://rocry.com/2012/12/18/objective-c-type-of/" rel="nofollow"><a href="http://rocry.com/2012/12/18/objective-c-type-of/">http://rocry.com/2012/12/18/objective-c-type-of/</a></a></p>
<p><a class="external-link" href="http://fuckingblocksyntax.com/" rel="nofollow"><a href="http://fuckingblocksyntax.com/">http://fuckingblocksyntax.com/</a></a> 这是个工具网站，我每次写block的时候都会用到。</p>
        <h4 class="title2">
            <a id="cb_post_title_url" class="postTitle3" href="http://www.cnblogs.com/biosli/p/block_usage.html">原文链接(<a href="http://www.cnblogs.com/biosli/p/block_usage.html">http://www.cnblogs.com/biosli/p/block_usage.html</a>)</a>
        </h4>
</div>
<div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd">&nbsp;</div></div><div id="MySignature"></div>
<div class="clear"></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C错误模型]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/objective-ccuo-wu-mo-xing/"/>
    <updated>2016-01-04T11:04:51+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/objective-ccuo-wu-mo-xing</id>
    <content type="html"><![CDATA[<h2>为什么不使用异常处理机制？</h2>

<p>事实上，OC是具备异常处理机制的，但是具体情况下不会启用该机制。原因是ARC下默认不是“异常安全”的。
    理由是,如果抛出异常，那么本应该在作用域末尾释放的对象在现在不能自动释放了。 如果想生成“异常安全”的代码，需要设置编译标志“-fobjc-arc-exceptions”，并且需要引入额外的代码，在不抛出异常时，也照样执行这段代码。
及时不适用ARC，也很难在抛出异常后不会导致内存泄露。例如：
<code>objc
    id resource = [YCResource alloc] init] retain];
    if (/*有异常发生*/) {
    @throw [NSException exceptionWithName:@"/*异常名称*/" reason@"/*异常原因*/" userInfo:nil];
    }
    [resource callSomeMethod];
    [resource release];
</code></p>

<!--more-->


<p>以上代码：如果一旦有异常抛出，那么之后的代码都不会被执行，资源resource对象也就无法被释放。
虽然可以在异常发生前释放资源对象，但是如果需要释放的资源对象非常多，之后又有新的资源加入，往往会忘了在异常前释放新加入的资源。
OC现在所采取的方法是只有在极其罕见的异常下，才抛出异常，异常抛出后不必考虑恢复问题，此时程序应该直接退出，这样就不用在编写复杂的“异常安全”代码了。
现在异常只用于及其严重的错误（致命错误）。
其中一个用途：OC中没有抽象类，所以无法定义抽象方法，此时，如果你想定义一套抽象 的API，那么可以在方法的实现中抛出异常，告诉使用者需要覆写该方法：
<code>objc
- (void)absructMethd {
    NSString exceptionReason = [NSString stringWithFormat:@"%@ must be overridden", NSStringFromSelector(_cmd)];
    @throw [NSException exceptionWithName:NSInternalInnconsistencyException reson:exceptionReason userInfo:nil];
}
</code></p>

<h2>如何处理“不那么严重（非致命）”的错误？</h2>

<p>OC的范式是：另方法返回0/nil，或者使用NSError。</p>

<h2>如何使用<code>NSError</code>？</h2>

<p>NSErrow使用起来非常灵活，我们使用它告诉调用者发生了什么错误。
NSError构成：
* Error domain(错误范围)
描述错误发生的范围。例如处理URL的子系统，当url解析出现错误，就可以使用<code>NSURLErrorDomain</code>来表示错误范围。
* Error code（错误码）
独有的错误代码，用以表明具体发生了何种错误，一般用枚举定义，HTTP请求中可以存储状态码。
* User info（用户信息）
有关错误的额外附加信息，可以是一段本地化描述，也可能是用来存储该错误是由其他错误引起的，最终生成一条完整的错误链。</p>

<p>其应用场景类型：
* 在代理协议中返回NSError错误。
<code>objc
- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError - *)error;
</code>
这样，接口定义者和使用者都可以选择是否输入并处理该错误。
* 在方法中用对象指针来监测错误。
<code>objc
- (BOOL)doSomething:(NSError **)error;
/*使用方法*/
NSError *error = nil;
BOOL ret = [slef doSomething:&amp;error];
if (ret) {
        // 处理错误
}
</code>
这种方法一般都会返回BOOL值，用来判断是否操作成功，如果只是判断成功状态，则只要判断返回值并且error参数传为nil就行，而error指针可以用来输出错误信息。
<code>
笔记：实际上ARC时，编译器会把NSError**转换为NSError*__autorelease*</code>,当doSomething方法执行完毕后，会将调用者创建的对象自动释放掉。这是为了防止调用者不一定能确保会释放掉NSError对象，必须要求他自己可以自动释放掉，所以加入autorelease。这样就与打部分返回值具备的语义相同了。</p>

<p>doSomething方法的实现原理：
<code>objc
- (BOOL)doSomething:(NSError *)error {
        if(/*发生error*/) {
                if(error) {
                /*给外部传入参数初始化*/
                *error = [NSError errorWithDomain:domain code:code userinfo:userInfo];
                }
                return NO;
        } else {
                return YES;
        }
}
</code>
在给error解引用&ndash;<code>*error</code>之前，必须保证error不为空。</p>

<p>一般情况下，给error对象填入恰当的错误范围，错误码，错误信息后，调用者就可以更精准的定位错误。
我们一般对错误范围使用NSString全局变量进行定义。错误码常采用枚举，例如：
<code>objc
extern NSSring *const YCErrorDomain;
typedef NS_ENUM（NSInteger, YCError）{
    YCErrorUnknow   = -1,
    YCErrorInternalIncosistency  = 100,
    YCErrorGeneralFault  = 105,
    YCErrorBadInput  = 500,
};
NSString *const YCErrorDomain = @"YCErrorDomain";
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Harpy（版本更新工具)制做兼容版本]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/01/wei-harpy(ban-ben-geng-xin-gong-ju-zhi-zuo-jian-rong-ban-ben-)/"/>
    <updated>2016-01-01T03:58:09+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/01/wei-harpy(ban-ben-geng-xin-gong-ju-zhi-zuo-jian-rong-ban-ben-)</id>
    <content type="html"><![CDATA[<p><strong>中文版：</strong></p>

<h1>Harpy（兼容版）</h1>

<h3>(iOS5-9适配版本,基于<a href="https://github.com/ArtSabintsev/Harpy">ArtSabintsev/Harpy v3.4.5</a>)</h3>

<h3>提醒用户你的应用有新的可用版本，并且及时的跳转到App Store进行更新。</h3>

<h2>关于</h2>

<p><strong>Harpy</strong> 将用户手机上已安装的iOS app版本与当前App Store最新可用版本进行检查对比。如果有新的可用版本时，使用弹窗及时提醒用户最新版本信息，并然用户选择是否需要进一步操作。</p>

<!--more-->


<p>Harry是基于<a href="Semantic%20Versioning">http://www.semver.org</a>版本号系统标准执行。
- <code>Semantic Versioning</code>是一个三位数的版本号系统（例如:1.0.0）
- Harry同样支持2位数的版本号(例如:1.0)
- Harpy同时支持4位数的版本号（例如:1.0.0.0）</p>

<h2>Swift 支持</h2>

<p>当前兼容版本（iOS5-9）暂时不支持swift</p>

<h2>特点</h2>

<!--- [x] CocoaPods Support-->


<ul>
<li>[x] 支持三种类型的弹框样式 (详见 <strong>截图 &amp; Alert Types</strong>)</li>
<li>[x] 提供可选的代理方法 (详见 <strong>Optional Delegate</strong> section)</li>
<li>[x] 本地化支持超过20+语言</li>
</ul>


<h2>屏幕截图</h2>

<ul>
<li><strong>左图：</strong>强制用户更新app</li>
<li><strong>中图：</strong>提供可选项是否前往更新</li>
<li><strong>右图：</strong>提供跳过当前版本更新的选项</li>
<li>这些样式全部可以通过<code>HarpyAletType</code>枚举进行控制，详见<code>Harpy.h</code></li>
</ul>


<p><img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/4.pic.jpg?raw=true" title="Forced Update" alt="Forced Update" />
<img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/5.pic.jpg?raw=true" title="Optional Update" alt="Optional Update" />
<img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/3.pic.jpg?raw=true" title="Optional Update" alt="Skipped Update" /></p>

<h2>安装</h2>

<h3>手动安装（正在准备CocoaPods）</h3>

<p>将‘Harpy’文件夹拖入到你的项目中，并选择'copy if needed',包括 <code>Harpy.h</code> 和 <code>Harpy.m</code> 文件</p>

<h2>配置</h2>

<ol>
<li>import <strong>Harpy.h</strong> 导入到 AppDelefate 类中 或者 Pre-Complier Header(.pch)文件中</li>
<li>在你的<code>Appdelegate</code>中设置<strong>appID</strong>（必要），设置你的<strong>alertType</strong>（可选）</li>
<li>在你的<code>Appdelegate</code>中调用<code>checkVersion</code>方法，三个检测方法调用位置分别位于Appdelegate的启动的代理方法中，可以自行选择使用

<ul>
<li>在 <code>application:didFinishLaunchingWithOptions:</code> 中调用 <code>checkVersion</code></li>
<li>在 <code>applicationDidBecomeActive:</code> 中调用 <code>checkVersionDaily</code></li>
<li>在 <code>applicationDidBecomeActive:</code> 中调用 <code>checkVersionWeekly</code> .</li>
</ul>
</li>
</ol>


<pre><code class="obj-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{

    // 启用Harpy之前确保你的window可用
    [self.window makeKeyAndVisible];

    // 为你的应用设置app id
    [[Harpy sharedInstance] setAppID:@"&lt;#app_id#&gt;"];

    // 设置 UIAlertController 将要基于哪个控制器显示 （适配iOS8+）
    [[Harpy sharedInstance] setPresentingViewController:_window.rootViewController];

  // (可选)设置代理来追踪用户点击事件，活着的使用自定义的界面来展示你的信息
      [[Harpy sharedInstance] setDelegate:self];

    // (可选) 设置alertController的tincolor（iOS8+可用）
    [[Harpy sharedInstance] setAlertControllerTintColor:@"&lt;#alert_controller_tint_color#&gt;"];

    // (可选) 设置你的应用名
    [[Harpy sharedInstance] setAppName:@"&lt;#app_name#&gt;"];

     /* （可选）设置弹框类型 默认为HarpyAlertTypeOption */
    [[Harpy sharedInstance] setAlertType:&lt;#alert_type#&gt;];

     /* (可选)如果你的应用只在某些国家或地区可用，你必须使用两个字符的country code来设置应用的可用区域 */
    [[Harpy sharedInstance] setCountryCode:@"&lt;#country_code#&gt;"];

    /* (可选) 强制指定应用显示语言, 请使用 Harpy.h 中定义的 HarpyLanguage 进行设置。*/
    [[Harpy sharedInstance] setForceLanguageLocalization:&lt;#HarpyLanguageConstant#&gt;];

    // 执行版本检测
    [[Harpy sharedInstance] checkVersion];
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{

    /*
        执行每天检测你的app是否需要更新版本，需要在`applicationDidBecomeActive:`执行最合适
        因为这对于的你的应用进如后台很长时间后非常有用。

        同时，也会在应用第一次启动时执行版本检测
    */
    [[Harpy sharedInstance] checkVersionDaily];

    /*
        执行每周检测你的app新版本。同理需要将此代码放置在`applicationDidBecomeActive:`中执行。

        同时，也会在应用第一次启动时执行版本检测
     */
    [[Harpy sharedInstance] checkVersionWeekly];

}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    /*
     执行app新版本检测，放在此是为了让用户从App Sore跳转回来并重新从后台进入你的
     app，并且没有在从App Store中跳转回来之前更新他们app的时候调用

     注意：只有当你使用*HarpyAlertTypeForce*样式弹框类型是才使用这种方法

    并且会在你第一次启动应用时检测。
    */
    [[Harpy sharedInstance] checkVersion];
}
</code></pre>

<p>至此设置全部完成！</p>

<h2>为不同的升级类型设置弹窗样式</h2>

<p>如果你喜欢为不同的升级类型比如修改(revision)，补丁(patch)，轻微改动(minor)，重大修改(major)等升级类型仅仅添加下面的几行可选代码即可，添加位置必须在调用版本检查的方法（checkVersion）之前</p>

<pre><code class="obj-c">    /* 默认情况下Harpy会设置所有的版本升级样式为HarpyAlertTypeOption */
    [[Harpy sharedInstance] setPatchUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMinorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMajorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setRevisionUpdateAlertType:&lt;#alert_type#&gt;];
</code></pre>

<h2>可选的代理和代理方法</h2>

<p>如果你想要个处理或者追踪终端用户的的行为，Harpy会为你提供四个代理方法进行监控</p>

<pre><code class="obj-c">    // 用户界面展示升级提示对话框
    - (void)harpyDidShowUpdateDialog;

    // 用户已经点击升级按钮并且进入到App Sotore
    - (void)harpyUserDidLaunchAppStore;

    // 用户已经点击跳过此次版本更新
    - (void)harpyUserDidSkipVersion;

    // 用户已经点击取消更行对话框
    - (void)harpyUserDidCancel;
</code></pre>

<p>If you would like to use your own UI, please use the following delegate method to obtain the localized update message if a new version is available:
如果你想使用自己的UI，如果有可用的新版本，使用下面的代理来获得本地化的升级信息（需要设置AlertTpye为HarpyAlertTypeNone）</p>

<pre><code class="obj-c">- (void)harpyDidDetectNewVersionWithoutAlert:(NSString *)message;
</code></pre>

<h2>强制本地化</h2>

<p>Harpy 已经本地化了的语言包括 Arabic, Basque, 简体中文, 繁体中文, Danish, Dutch, English, Estonian, French, German, Hebrew, Hungarian, Italian, Japanese, Korean, Latvian, Lithuanian, Malay, Polish, Portuguese (Brazil), Portuguese (Portugal), Russian, Slovenian, Swedish, Spanish, Thai, and Turkish.</p>

<p>你可能想要你的升级对话框<em>永远</em>显示正确的语言，而忽略iOS的语言设置（比如在指定国家发行的app）</p>

<p>你可以使用以下代码实现强制本地化</p>

<pre><code class="obj-c">[[Harpy sharedInstance] setForceLanguageLocalization&lt;#HarpyLanguageConstant#&gt;];
</code></pre>

<h2>在App Store上提交的重要注意事项</h2>

<p>App Store 审核人员将不会看到升级弹框</p>

<p><strong>English</strong>：</p>

<h1>Harpy（Compatible version Base On <a href="https://github.com/ArtSabintsev/Harpy">ArtSabintsev/Harpy v3.4.5</a>）</h1>

<h3>Notify users when a new version of your app is available, and prompt them with the App Store link.</h3>

<hr />

<h2>About</h2>

<p><strong>Harpy</strong> checks a user&rsquo;s currently installed version of your iOS app against the version that is currently available in the App Store. If a new version is available, an alert can be presented to the user informing them of the newer version, and giving them the option to update the application.</p>

<p>Harpy is built to work with the <a href="Semantic%20Versioning">http://www.semver.org</a> system.
- Semantic Versioning is a three number versioning system (e.g., 1.0.0)
- Harpy also supports two-number versioning (e.g., 1.0)
- Harpy also supports four-number versioning (e.g., 1.0.0.0)</p>

<h2>Swift Support</h2>

<ul>
<li>not support yet</li>
</ul>


<h2>Features</h2>

<!--- [x] CocoaPods Support-->


<ul>
<li>[x] Three types of alerts (see <strong>Screenshots &amp; Alert Types</strong>)</li>
<li>[x] Optional delegate methods (see <strong>Optional Delegate</strong> section)</li>
<li>[x] Localized for 20+ languages</li>
</ul>


<h2>Screenshots</h2>

<ul>
<li>The <strong>left picture</strong> forces the user to update the app.</li>
<li>The <strong>center picture</strong> gives the user the option to update the app.</li>
<li>The <strong>right picture</strong> gives the user the option to skip the current update.</li>
<li>These options are controlled by the <code>HarpyAlertType</code> typede that is found in <code>Harpy.h</code>.</li>
</ul>


<p><img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picForcedUpdate.png?raw=true" title="Forced Update" alt="Forced Update" />
<img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picOptionalUpdate.png?raw=true" title="Optional Update" alt="Optional Update" />
<img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picSkippedUpdate.png?raw=true" title="Optional Update" alt="Skipped Update" /></p>

<h2>Installation Instructions</h2>

<!--### CocoaPods Installation
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'Harpy'</span></code></pre></td></tr></table></div></figure>-->


<h3>Manual Installation</h3>

<p>Copy the &lsquo;Harpy&rsquo; folder into your Xcode project. It contains the Harpy.h and Harpy.m files.</p>

<h2>Setup</h2>

<ol>
<li>Import <strong>Harpy.h</strong> into your AppDelegate or Pre-Compiler Header (.pch)</li>
<li>In your <code>AppDelegate</code>, set the <strong>appID</strong>, and optionally, you can set the <strong>alertType</strong>.</li>
<li>In your <code>AppDelegate</code>, call <strong>only one</strong> of the <code>checkVersion</code> methods, as all three perform a check on your application&rsquo;s first launch. Use either:

<ul>
<li><code>checkVersion</code> in <code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>checkVersionDaily</code> in <code>applicationDidBecomeActive:</code>.</li>
<li><code>checkVersionWeekly</code> in <code>applicationDidBecomeActive:</code>.</li>
</ul>
</li>
</ol>


<pre><code class="obj-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{

    // Present Window before calling Harpy
    [self.window makeKeyAndVisible];

    // Set the App ID for your app
    [[Harpy sharedInstance] setAppID:@"&lt;#app_id#&gt;"];

    // Set the UIViewController that will present an instance of UIAlertController
    [[Harpy sharedInstance] setPresentingViewController:_window.rootViewController];

  // (Optional) Set the Delegate to track what a user clicked on, or to use a custom UI to present your message.
      [[Harpy sharedInstance] setDelegate:self];

    // (Optional) The tintColor for the alertController
    [[Harpy sharedInstance] setAlertControllerTintColor:@"&lt;#alert_controller_tint_color#&gt;"];

    // (Optional) Set the App Name for your app
    [[Harpy sharedInstance] setAppName:@"&lt;#app_name#&gt;"];

    /* (Optional) Set the Alert Type for your app
     By default, Harpy is configured to use HarpyAlertTypeOption */
    [[Harpy sharedInstance] setAlertType:&lt;#alert_type#&gt;];

    /* (Optional) If your application is not available in the U.S. App Store, you must specify the two-letter
     country code for the region in which your applicaiton is available. */
    [[Harpy sharedInstance] setCountryCode:@"&lt;#country_code#&gt;"];

    /* (Optional) Overrides system language to predefined language.
     Please use the HarpyLanguage constants defined in Harpy.h. */
    [[Harpy sharedInstance] setForceLanguageLocalization:&lt;#HarpyLanguageConstant#&gt;];

    // Perform check for new version of your app
    [[Harpy sharedInstance] checkVersion];
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{

    /*
     Perform daily check for new version of your app
     Useful if user returns to you app from background after extended period of time
     Place in applicationDidBecomeActive:

     Also, performs version check on first launch.
    */
    [[Harpy sharedInstance] checkVersionDaily];

    /*
     Perform weekly check for new version of your app
     Useful if you user returns to your app from background after extended period of time
     Place in applicationDidBecomeActive:

     Also, performs version check on first launch.
     */
    [[Harpy sharedInstance] checkVersionWeekly];

}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    /*
     Perform check for new version of your app
     Useful if user returns to you app from background after being sent tot he App Store,
     but doesn't update their app before coming back to your app.

     ONLY USE THIS IF YOU ARE USING *HarpyAlertTypeForce*

     Also, performs version check on first launch.
    */
    [[Harpy sharedInstance] checkVersion];
}
</code></pre>

<p>And you&rsquo;re all set!</p>

<h2>Differentiated Alerts for Patch, Minor, and Major Updates</h2>

<p>If you would like to set a different type of alert for revision, patch, minor, and/or major updates, simply add one or all of the following <em>optional</em> lines to your setup <em>before</em> calling any of the <code>checkVersion</code> methods:</p>

<pre><code class="obj-c">    /* By default, Harpy is configured to use HarpyAlertTypeOption for all version updates */
    [[Harpy sharedInstance] setPatchUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMinorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMajorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setRevisionUpdateAlertType:&lt;#alert_type#&gt;];
</code></pre>

<h2>Optional Delegate and Delegate Methods</h2>

<p>If you&rsquo;d like to handle or track the end-user&rsquo;s behavior, four delegate methods have been made available to you:</p>

<pre><code class="obj-c">    // User presented with update dialog
    - (void)harpyDidShowUpdateDialog;

    // User did click on button that launched App Store.app
    - (void)harpyUserDidLaunchAppStore;

    // User did click on button that skips version update
    - (void)harpyUserDidSkipVersion;

    // User did click on button that cancels update dialog
    - (void)harpyUserDidCancel;
</code></pre>

<p>If you would like to use your own UI, please use the following delegate method to obtain the localized update message if a new version is available:</p>

<pre><code class="obj-c">- (void)harpyDidDetectNewVersionWithoutAlert:(NSString *)message;
</code></pre>

<h2>Force Localization</h2>

<p>Harpy has localizations for Arabic, Basque, Chinese (Simplified), Chinese (Traditional), Danish, Dutch, English, Estonian, French, German, Hebrew, Hungarian, Italian, Japanese, Korean, Latvian, Lithuanian, Malay, Polish, Portuguese (Brazil), Portuguese (Portugal), Russian, Slovenian, Swedish, Spanish, Thai, and Turkish.</p>

<p>You may want the update dialog to <em>always</em> appear in a certain language, ignoring iOS&rsquo;s language setting (e.g. apps released in a specific country).</p>

<p>You can enable it like this:</p>

<pre><code class="obj-c">[[Harpy sharedInstance] setForceLanguageLocalization&lt;#HarpyLanguageConstant#&gt;];
</code></pre>

<h2>Important Note on App Store Submissions</h2>

<p>The App Store reviewer will <strong>not</strong> see the alert.</p>

<h2>Created and maintained by</h2>

<p><a href="http://www.sabintsev.com/">Arthur Ariel Sabintsev</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MPMovieplayerviewcontroller播放结束后自动消失的解决方案]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/01/mpmovieplayerviewcontrollerbo-fang-jie-shu-hou-zi-dong-xiao-shi-de-jie-jue-fang-an/"/>
    <updated>2016-01-01T03:30:11+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/01/mpmovieplayerviewcontrollerbo-fang-jie-shu-hou-zi-dong-xiao-shi-de-jie-jue-fang-an</id>
    <content type="html"><![CDATA[<hr />

<p>你可以使用这段代码来阻止控制器播放在播放结束后自动dismissing（消失），并且捕捉到用户点击完成的按钮事件去自己定义并处理让你的MPMoviePlayerViewController播放器的消失（dismiss）的时机</p>

<!--more-->


<hr />

<p>步骤 1. - 创建并初始化一个MPMoviePlayerViewController（videoPlayer）</p>

<pre><code class="objc">MPMoviePlayerViewController *videoPlayer = [[MPMoviePlayerViewController alloc] initWithContentURL:[[NSURL alloc ]initWithString:[aURL];
</code></pre>

<p>步骤 2. - 移除videoPlayer默认的通知事件并且加入自己的通知事件。
<code>objc
[[NSNotificationCenter defaultCenter] removeObserver:videoPlayer
name:MPMoviePlayerPlaybackDidFinishNotification object:videoPlayer.moviePlayer];
[[NSNotificationCenter defaultCenter] addObserver:self
selector:@selector(videoFinished:) name:MPMoviePlayerPlaybackDidFinishNotification object:videoPlayer.moviePlayer];
</code>
步骤 3. - 手动显示你的videoPlayer控制器
<code>objc
[self presentMoviePlayerViewControllerAnimated:videoPlayer];
</code>
步骤 4. - 添加 videoFinish: 方法处理通知事件</p>

<pre><code class="objc">-(void)videoFinished:(NSNotification*)aNotification{
    int value = [[aNotification.userInfo valueForKey:MPMoviePlayerPlaybackDidFinishReasonUserInfoKey] intValue];
    if (value == MPMovieFinishReasonUserExited) {
        [self dismissMoviePlayerViewControllerAnimated];
    }
}
</code></pre>

<hr />

<p>参考:<a href="http://stackoverflow.com/a/19596598">http://stackoverflow.com/a/19596598</a></p>
]]></content>
  </entry>
  
</feed>
