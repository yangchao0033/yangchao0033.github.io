<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | SuperYang`s Blog]]></title>
  <link href="http://yangchao0033.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yangchao0033.github.io/"/>
  <updated>2016-01-01T04:14:58+08:00</updated>
  <id>http://yangchao0033.github.io/</id>
  <author>
    <name><![CDATA[Super Yang]]></name>
    <email><![CDATA[757097678@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为Harpy（版本更新工具)制做兼容版本]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/01/wei-harpy(ban-ben-geng-xin-gong-ju-zhi-zuo-jian-rong-ban-ben-)/"/>
    <updated>2016-01-01T03:58:09+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/01/wei-harpy(ban-ben-geng-xin-gong-ju-zhi-zuo-jian-rong-ban-ben-)</id>
    <content type="html"><![CDATA[<p><strong>中文版：</strong></p>

<h1>Harpy（兼容版）</h1>

<h3>(iOS5-9适配版本,基于<a href="https://github.com/ArtSabintsev/Harpy">ArtSabintsev/Harpy v3.4.5</a>)</h3>

<h3>提醒用户你的应用有新的可用版本，并且及时的跳转到App Store进行更新。</h3>

<h2>关于</h2>

<p><strong>Harpy</strong> 将用户手机上已安装的iOS app版本与当前App Store最新可用版本进行检查对比。如果有新的可用版本时，使用弹窗及时提醒用户最新版本信息，并然用户选择是否需要进一步操作。</p>

<!--more-->


<p>Harry是基于<a href="Semantic%20Versioning">http://www.semver.org</a>版本号系统标准执行。
- <code>Semantic Versioning</code>是一个三位数的版本号系统（例如:1.0.0）
- Harry同样支持2位数的版本号(例如:1.0)
- Harpy同时支持4位数的版本号（例如:1.0.0.0）</p>

<h2>Swift 支持</h2>

<p>当前兼容版本（iOS5-9）暂时不支持swift</p>

<h2>特点</h2>

<!--- [x] CocoaPods Support-->


<ul>
<li>[x] 支持三种类型的弹框样式 (详见 <strong>截图 &amp; Alert Types</strong>)</li>
<li>[x] 提供可选的代理方法 (详见 <strong>Optional Delegate</strong> section)</li>
<li>[x] 本地化支持超过20+语言</li>
</ul>


<h2>屏幕截图</h2>

<ul>
<li><strong>左图：</strong>强制用户更新app</li>
<li><strong>中图：</strong>提供可选项是否前往更新</li>
<li><strong>右图：</strong>提供跳过当前版本更新的选项</li>
<li>这些样式全部可以通过<code>HarpyAletType</code>枚举进行控制，详见<code>Harpy.h</code></li>
</ul>


<p><img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/4.pic.jpg?raw=true" title="Forced Update" alt="Forced Update" />
<img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/5.pic.jpg?raw=true" title="Optional Update" alt="Optional Update" />
<img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/3.pic.jpg?raw=true" title="Optional Update" alt="Skipped Update" /></p>

<h2>安装</h2>

<h3>手动安装（正在准备CocoaPods）</h3>

<p>将‘Harpy’文件夹拖入到你的项目中，并选择'copy if needed',包括 <code>Harpy.h</code> 和 <code>Harpy.m</code> 文件</p>

<h2>配置</h2>

<ol>
<li>import <strong>Harpy.h</strong> 导入到 AppDelefate 类中 或者 Pre-Complier Header(.pch)文件中</li>
<li>在你的<code>Appdelegate</code>中设置<strong>appID</strong>（必要），设置你的<strong>alertType</strong>（可选）</li>
<li>在你的<code>Appdelegate</code>中调用<code>checkVersion</code>方法，三个检测方法调用位置分别位于Appdelegate的启动的代理方法中，可以自行选择使用

<ul>
<li>在 <code>application:didFinishLaunchingWithOptions:</code> 中调用 <code>checkVersion</code></li>
<li>在 <code>applicationDidBecomeActive:</code> 中调用 <code>checkVersionDaily</code></li>
<li>在 <code>applicationDidBecomeActive:</code> 中调用 <code>checkVersionWeekly</code> .</li>
</ul>
</li>
</ol>


<pre><code class="obj-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{

    // 启用Harpy之前确保你的window可用
    [self.window makeKeyAndVisible];

    // 为你的应用设置app id
    [[Harpy sharedInstance] setAppID:@"&lt;#app_id#&gt;"];

    // 设置 UIAlertController 将要基于哪个控制器显示 （适配iOS8+）
    [[Harpy sharedInstance] setPresentingViewController:_window.rootViewController];

  // (可选)设置代理来追踪用户点击事件，活着的使用自定义的界面来展示你的信息
      [[Harpy sharedInstance] setDelegate:self];

    // (可选) 设置alertController的tincolor（iOS8+可用）
    [[Harpy sharedInstance] setAlertControllerTintColor:@"&lt;#alert_controller_tint_color#&gt;"];

    // (可选) 设置你的应用名
    [[Harpy sharedInstance] setAppName:@"&lt;#app_name#&gt;"];

     /* （可选）设置弹框类型 默认为HarpyAlertTypeOption */
    [[Harpy sharedInstance] setAlertType:&lt;#alert_type#&gt;];

     /* (可选)如果你的应用只在某些国家或地区可用，你必须使用两个字符的country code来设置应用的可用区域 */
    [[Harpy sharedInstance] setCountryCode:@"&lt;#country_code#&gt;"];

    /* (可选) 强制指定应用显示语言, 请使用 Harpy.h 中定义的 HarpyLanguage 进行设置。*/
    [[Harpy sharedInstance] setForceLanguageLocalization:&lt;#HarpyLanguageConstant#&gt;];

    // 执行版本检测
    [[Harpy sharedInstance] checkVersion];
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{

    /*
        执行每天检测你的app是否需要更新版本，需要在`applicationDidBecomeActive:`执行最合适
        因为这对于的你的应用进如后台很长时间后非常有用。

        同时，也会在应用第一次启动时执行版本检测
    */
    [[Harpy sharedInstance] checkVersionDaily];

    /*
        执行每周检测你的app新版本。同理需要将此代码放置在`applicationDidBecomeActive:`中执行。

        同时，也会在应用第一次启动时执行版本检测
     */
    [[Harpy sharedInstance] checkVersionWeekly];

}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    /*
     执行app新版本检测，放在此是为了让用户从App Sore跳转回来并重新从后台进入你的
     app，并且没有在从App Store中跳转回来之前更新他们app的时候调用

     注意：只有当你使用*HarpyAlertTypeForce*样式弹框类型是才使用这种方法

    并且会在你第一次启动应用时检测。
    */
    [[Harpy sharedInstance] checkVersion];
}
</code></pre>

<p>至此设置全部完成！</p>

<h2>为不同的升级类型设置弹窗样式</h2>

<p>如果你喜欢为不同的升级类型比如修改(revision)，补丁(patch)，轻微改动(minor)，重大修改(major)等升级类型仅仅添加下面的几行可选代码即可，添加位置必须在调用版本检查的方法（checkVersion）之前</p>

<pre><code class="obj-c">    /* 默认情况下Harpy会设置所有的版本升级样式为HarpyAlertTypeOption */
    [[Harpy sharedInstance] setPatchUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMinorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMajorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setRevisionUpdateAlertType:&lt;#alert_type#&gt;];
</code></pre>

<h2>可选的代理和代理方法</h2>

<p>如果你想要个处理或者追踪终端用户的的行为，Harpy会为你提供四个代理方法进行监控</p>

<pre><code class="obj-c">    // 用户界面展示升级提示对话框
    - (void)harpyDidShowUpdateDialog;

    // 用户已经点击升级按钮并且进入到App Sotore
    - (void)harpyUserDidLaunchAppStore;

    // 用户已经点击跳过此次版本更新
    - (void)harpyUserDidSkipVersion;

    // 用户已经点击取消更行对话框
    - (void)harpyUserDidCancel;
</code></pre>

<p>If you would like to use your own UI, please use the following delegate method to obtain the localized update message if a new version is available:
如果你想使用自己的UI，如果有可用的新版本，使用下面的代理来获得本地化的升级信息（需要设置AlertTpye为HarpyAlertTypeNone）</p>

<pre><code class="obj-c">- (void)harpyDidDetectNewVersionWithoutAlert:(NSString *)message;
</code></pre>

<h2>强制本地化</h2>

<p>Harpy 已经本地化了的语言包括 Arabic, Basque, 简体中文, 繁体中文, Danish, Dutch, English, Estonian, French, German, Hebrew, Hungarian, Italian, Japanese, Korean, Latvian, Lithuanian, Malay, Polish, Portuguese (Brazil), Portuguese (Portugal), Russian, Slovenian, Swedish, Spanish, Thai, and Turkish.</p>

<p>你可能想要你的升级对话框<em>永远</em>显示正确的语言，而忽略iOS的语言设置（比如在指定国家发行的app）</p>

<p>你可以使用以下代码实现强制本地化</p>

<pre><code class="obj-c">[[Harpy sharedInstance] setForceLanguageLocalization&lt;#HarpyLanguageConstant#&gt;];
</code></pre>

<h2>在App Store上提交的重要注意事项</h2>

<p>App Store 审核人员将不会看到升级弹框</p>

<p><strong>English</strong>：</p>

<h1>Harpy（Compatible version Base On <a href="https://github.com/ArtSabintsev/Harpy">ArtSabintsev/Harpy v3.4.5</a>）</h1>

<h3>Notify users when a new version of your app is available, and prompt them with the App Store link.</h3>

<hr />

<h2>About</h2>

<p><strong>Harpy</strong> checks a user&rsquo;s currently installed version of your iOS app against the version that is currently available in the App Store. If a new version is available, an alert can be presented to the user informing them of the newer version, and giving them the option to update the application.</p>

<p>Harpy is built to work with the <a href="Semantic%20Versioning">http://www.semver.org</a> system.
- Semantic Versioning is a three number versioning system (e.g., 1.0.0)
- Harpy also supports two-number versioning (e.g., 1.0)
- Harpy also supports four-number versioning (e.g., 1.0.0.0)</p>

<h2>Swift Support</h2>

<ul>
<li>not support yet</li>
</ul>


<h2>Features</h2>

<!--- [x] CocoaPods Support-->


<ul>
<li>[x] Three types of alerts (see <strong>Screenshots &amp; Alert Types</strong>)</li>
<li>[x] Optional delegate methods (see <strong>Optional Delegate</strong> section)</li>
<li>[x] Localized for 20+ languages</li>
</ul>


<h2>Screenshots</h2>

<ul>
<li>The <strong>left picture</strong> forces the user to update the app.</li>
<li>The <strong>center picture</strong> gives the user the option to update the app.</li>
<li>The <strong>right picture</strong> gives the user the option to skip the current update.</li>
<li>These options are controlled by the <code>HarpyAlertType</code> typede that is found in <code>Harpy.h</code>.</li>
</ul>


<p><img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picForcedUpdate.png?raw=true" title="Forced Update" alt="Forced Update" />
<img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picOptionalUpdate.png?raw=true" title="Optional Update" alt="Optional Update" />
<img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picSkippedUpdate.png?raw=true" title="Optional Update" alt="Skipped Update" /></p>

<h2>Installation Instructions</h2>

<!--### CocoaPods Installation
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod 'Harpy'</span></code></pre></td></tr></table></div></figure>-->


<h3>Manual Installation</h3>

<p>Copy the &lsquo;Harpy&rsquo; folder into your Xcode project. It contains the Harpy.h and Harpy.m files.</p>

<h2>Setup</h2>

<ol>
<li>Import <strong>Harpy.h</strong> into your AppDelegate or Pre-Compiler Header (.pch)</li>
<li>In your <code>AppDelegate</code>, set the <strong>appID</strong>, and optionally, you can set the <strong>alertType</strong>.</li>
<li>In your <code>AppDelegate</code>, call <strong>only one</strong> of the <code>checkVersion</code> methods, as all three perform a check on your application&rsquo;s first launch. Use either:

<ul>
<li><code>checkVersion</code> in <code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>checkVersionDaily</code> in <code>applicationDidBecomeActive:</code>.</li>
<li><code>checkVersionWeekly</code> in <code>applicationDidBecomeActive:</code>.</li>
</ul>
</li>
</ol>


<pre><code class="obj-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{

    // Present Window before calling Harpy
    [self.window makeKeyAndVisible];

    // Set the App ID for your app
    [[Harpy sharedInstance] setAppID:@"&lt;#app_id#&gt;"];

    // Set the UIViewController that will present an instance of UIAlertController
    [[Harpy sharedInstance] setPresentingViewController:_window.rootViewController];

  // (Optional) Set the Delegate to track what a user clicked on, or to use a custom UI to present your message.
      [[Harpy sharedInstance] setDelegate:self];

    // (Optional) The tintColor for the alertController
    [[Harpy sharedInstance] setAlertControllerTintColor:@"&lt;#alert_controller_tint_color#&gt;"];

    // (Optional) Set the App Name for your app
    [[Harpy sharedInstance] setAppName:@"&lt;#app_name#&gt;"];

    /* (Optional) Set the Alert Type for your app
     By default, Harpy is configured to use HarpyAlertTypeOption */
    [[Harpy sharedInstance] setAlertType:&lt;#alert_type#&gt;];

    /* (Optional) If your application is not available in the U.S. App Store, you must specify the two-letter
     country code for the region in which your applicaiton is available. */
    [[Harpy sharedInstance] setCountryCode:@"&lt;#country_code#&gt;"];

    /* (Optional) Overrides system language to predefined language.
     Please use the HarpyLanguage constants defined in Harpy.h. */
    [[Harpy sharedInstance] setForceLanguageLocalization:&lt;#HarpyLanguageConstant#&gt;];

    // Perform check for new version of your app
    [[Harpy sharedInstance] checkVersion];
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{

    /*
     Perform daily check for new version of your app
     Useful if user returns to you app from background after extended period of time
     Place in applicationDidBecomeActive:

     Also, performs version check on first launch.
    */
    [[Harpy sharedInstance] checkVersionDaily];

    /*
     Perform weekly check for new version of your app
     Useful if you user returns to your app from background after extended period of time
     Place in applicationDidBecomeActive:

     Also, performs version check on first launch.
     */
    [[Harpy sharedInstance] checkVersionWeekly];

}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    /*
     Perform check for new version of your app
     Useful if user returns to you app from background after being sent tot he App Store,
     but doesn't update their app before coming back to your app.

     ONLY USE THIS IF YOU ARE USING *HarpyAlertTypeForce*

     Also, performs version check on first launch.
    */
    [[Harpy sharedInstance] checkVersion];
}
</code></pre>

<p>And you&rsquo;re all set!</p>

<h2>Differentiated Alerts for Patch, Minor, and Major Updates</h2>

<p>If you would like to set a different type of alert for revision, patch, minor, and/or major updates, simply add one or all of the following <em>optional</em> lines to your setup <em>before</em> calling any of the <code>checkVersion</code> methods:</p>

<pre><code class="obj-c">    /* By default, Harpy is configured to use HarpyAlertTypeOption for all version updates */
    [[Harpy sharedInstance] setPatchUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMinorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMajorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setRevisionUpdateAlertType:&lt;#alert_type#&gt;];
</code></pre>

<h2>Optional Delegate and Delegate Methods</h2>

<p>If you&rsquo;d like to handle or track the end-user&rsquo;s behavior, four delegate methods have been made available to you:</p>

<pre><code class="obj-c">    // User presented with update dialog
    - (void)harpyDidShowUpdateDialog;

    // User did click on button that launched App Store.app
    - (void)harpyUserDidLaunchAppStore;

    // User did click on button that skips version update
    - (void)harpyUserDidSkipVersion;

    // User did click on button that cancels update dialog
    - (void)harpyUserDidCancel;
</code></pre>

<p>If you would like to use your own UI, please use the following delegate method to obtain the localized update message if a new version is available:</p>

<pre><code class="obj-c">- (void)harpyDidDetectNewVersionWithoutAlert:(NSString *)message;
</code></pre>

<h2>Force Localization</h2>

<p>Harpy has localizations for Arabic, Basque, Chinese (Simplified), Chinese (Traditional), Danish, Dutch, English, Estonian, French, German, Hebrew, Hungarian, Italian, Japanese, Korean, Latvian, Lithuanian, Malay, Polish, Portuguese (Brazil), Portuguese (Portugal), Russian, Slovenian, Swedish, Spanish, Thai, and Turkish.</p>

<p>You may want the update dialog to <em>always</em> appear in a certain language, ignoring iOS&rsquo;s language setting (e.g. apps released in a specific country).</p>

<p>You can enable it like this:</p>

<pre><code class="obj-c">[[Harpy sharedInstance] setForceLanguageLocalization&lt;#HarpyLanguageConstant#&gt;];
</code></pre>

<h2>Important Note on App Store Submissions</h2>

<p>The App Store reviewer will <strong>not</strong> see the alert.</p>

<h2>Created and maintained by</h2>

<p><a href="http://www.sabintsev.com/">Arthur Ariel Sabintsev</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MPMovieplayerviewcontroller播放结束后自动消失的解决方案]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/01/mpmovieplayerviewcontrollerbo-fang-jie-shu-hou-zi-dong-xiao-shi-de-jie-jue-fang-an/"/>
    <updated>2016-01-01T03:30:11+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/01/mpmovieplayerviewcontrollerbo-fang-jie-shu-hou-zi-dong-xiao-shi-de-jie-jue-fang-an</id>
    <content type="html"><![CDATA[<hr />

<p>你可以使用这段代码来阻止控制器播放在播放结束后自动dismissing（消失），并且捕捉到用户点击完成的按钮事件去自己定义并处理让你的MPMoviePlayerViewController播放器的消失（dismiss）的时机</p>

<!--more-->


<hr />

<p>步骤 1. - 创建并初始化一个MPMoviePlayerViewController（videoPlayer）</p>

<pre><code class="objc">MPMoviePlayerViewController *videoPlayer = [[MPMoviePlayerViewController alloc] initWithContentURL:[[NSURL alloc ]initWithString:[aURL];
</code></pre>

<p>步骤 2. - 移除videoPlayer默认的通知事件并且加入自己的通知事件。
<code>objc
[[NSNotificationCenter defaultCenter] removeObserver:videoPlayer
name:MPMoviePlayerPlaybackDidFinishNotification object:videoPlayer.moviePlayer];
[[NSNotificationCenter defaultCenter] addObserver:self
selector:@selector(videoFinished:) name:MPMoviePlayerPlaybackDidFinishNotification object:videoPlayer.moviePlayer];
</code>
步骤 3. - 手动显示你的videoPlayer控制器
<code>objc
[self presentMoviePlayerViewControllerAnimated:videoPlayer];
</code>
步骤 4. - 添加 videoFinish: 方法处理通知事件</p>

<pre><code class="objc">-(void)videoFinished:(NSNotification*)aNotification{
    int value = [[aNotification.userInfo valueForKey:MPMoviePlayerPlaybackDidFinishReasonUserInfoKey] intValue];
    if (value == MPMovieFinishReasonUserExited) {
        [self dismissMoviePlayerViewControllerAnimated];
    }
}
</code></pre>

<hr />

<p>参考:<a href="http://stackoverflow.com/a/19596598">http://stackoverflow.com/a/19596598</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于在storyboard中使用静态cell的注意事项]]></title>
    <link href="http://yangchao0033.github.io/blog/2015/12/30/guan-yu-zai-storyboardzhong-shi-yong-jing-tai-cellde-zhu-yi-shi-xiang/"/>
    <updated>2015-12-30T15:26:05+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2015/12/30/guan-yu-zai-storyboardzhong-shi-yong-jing-tai-cellde-zhu-yi-shi-xiang</id>
    <content type="html"><![CDATA[<p> &ndash;关于在<em>storyboard</em>中使用静态TableViewCell的可变高度的使用技巧</p>

<p>起因:在storyboard使用之前，创建tableView视图，通常是采用代码控制数据源，通过数据源数据的长度来决定tableView中cell的个数，而这样做的好处还有就是可以通过将已经在界面中展示的cell放入缓存池中，以供后续数据展示再从缓存池中取出进行复用。这样做的好处是为了防止数据过大时创建大量的cell浪费不必要的空间。显而易见，tableView就是为了进行批量数据的展示。</p>

<!--more-->


<p> <br/>
然而，在现实开发中，会出现一种需求：展示的数据长度是确定的，而且需要向tableView一样实现视图上下滚动，单个cell视图可点击响应。这种情况下，继续使用原来的代码数据源控制一样可以实现，这时的数据源个数是确定的。即便如此，你也需要考虑处理cell滚动时发生的重用所带来的影响。而且当数据源确定时，你的产品经理绝对不甘于像平常一样每条数据都展示为同一个尺寸内容。而是会尽可能地在每个cell中加入丰富的控件，时间相应来是有限的tableView实现最为复杂的用户交互事件。此时，你会在自己的数据源拼命地书写if语句来保证视图的正确显示，又要避免发生未知的cell重用问题。<br/>
这样做是可行的，但是在主要时间将大量花费在处理有限个数cell上的逻辑处理，而并非我们所要实现的主要业务。<br/>
所以，在这种情况下，我们会考虑把这些重复而且无用的逻辑处理交给苹果自己搞定（当然，主要目的是为了偷懒^_^）<br/>
static cell，这是苹果为我们提供的解决方案。目前仅限于在storyboard中使用。</p>

<p> <code>static cell</code>的用法非常简单，这里不作为重点赘述，请大家自行学习。<br/>
  现在给大家这样一个场景，在你用<code>static cell</code>搭建好界面，然后轻松加愉快的拖拖控件，完成相关业务功能。<br/>
  上面老板开始验收项目，对产品  说你的界面不够详细，再改改。<br/>
  产品开始提需求，说我们的cell内容太少，需要在点击时展开详情。<br/>
  而恰好你用静态单元cell偷了个懒，现在要为了一个cell重新用动态cell写一遍？<br/>
  别闹了，明天还要和UI妹子去爬香山呢，绝壁不当加班狗。<br/>
  所以，我们开始探索静态cell的高度改变之旅。</p>

<hr />

<p>  方案一：
  既然我们可以将静态cell当做一个控件拖入控制器做属性。何不在代码中修改作为属性的静态cell的高度呢？
<code>objc   
        self.fuJianCell.height = 100;       
        [self.fuJianCell layoutIfNeeded];
        [self.tableView reloadData];
</code>
然并卵，这些方法对非cell的控件来说刷新高度足矣，然而<code>tableView</code>的高度始终是由代理来控制的，所以这样修改是没用的。<br/>
既然这样，我们就从高度代理入手。</p>

<hr />

<p>方案二：
通过代理入手，将每个cell的在storyBoard的设置高度用代码写到一个数组中，并通过代理返回。
<code>objc
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 变高行数
    NSInteger mutableHeightRow = 1;
    // 如果不展开
    if(!isOpen){
        self.heights[mutableHeightRow] = @(原始高度);
        return [self.heights[indexPath.row] integerValue];
    } else {
        self.heights[mutableHeightRow] = @(展开高度);
        return [self.heights[indexPath.row] integerValue];
    }
}
</code>
问题解决，但是违背了我们的初衷，说好的交给苹果自己算呢，为毛要手动将高度存在数组中？</p>

<hr />

<p>方案三：
交给tableView的父类方法返回我们在storyboard中预设的高度，然后单独处理变高的cell高度
<code>objc
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    // 变高行数
    NSInteger mutableHeightRow = 1;
    if (indexPath.row == mutableHeightRow) {
        if (!isOpen) {
            // 假设改行原来高度为200
            return 80;
        } else {
            return [super tableView:tableView heightForRowAtIndexPath:indexPath];
        }
    } else {
        /** 返回静态单元格故事板中的高度 */
        return [super tableView:tableView heightForRowAtIndexPath:indexPath];
    }
}
</code>
完美~</p>

<hr />

<pre><code class="objc">// 注意别忘了,在修改展开状态的时候刷新表格
    isOpen = YES;
    [self.tableView reloadData];
</code></pre>

<p>其实，这样处理静态cell的方式不光可以处理可变高度，还可以用在数据源的section个数或者每个section的row的个数上，再或者指定让某个位置的cell使用动态cell其他使用静态cell，让我们的静态cell比动态cell更好用。其方法都是通过<code>super</code>关键字调用父类方法返回storyboard中存储的的相关数据。</p>

<p>至于原理，暂时还不清楚，推测使用了运行时动态创建一个支持静态cell的tableView的子类，我们实际使用的是这个新的tableView类的实例，或者使用<code>类簇</code>，利用私有子类进行了相关的静态cell的逻辑处理。</p>

<p>总之，这让我们省去了很多处理逻辑的代码。</p>

<p>参考文章：<a href="http://codego.net/513617/">UITableView的：在处理混合cell表视图的静态和动态的cell小区选择</a></p>
]]></content>
  </entry>
  
</feed>
