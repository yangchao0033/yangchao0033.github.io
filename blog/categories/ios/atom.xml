<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | SuperYang`s Blog]]></title>
  <link href="http://yangchao0033.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yangchao0033.github.io/"/>
  <updated>2017-07-27T00:42:44+08:00</updated>
  <id>http://yangchao0033.github.io/</id>
  <author>
    <name><![CDATA[Super Yang]]></name>
    <email><![CDATA[757097678@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa 设计规范]]></title>
    <link href="http://yangchao0033.github.io/blog/2017/07/27/reactivecocoa-she-ji-gui-fan/"/>
    <updated>2017-07-27T00:36:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2017/07/27/reactivecocoa-she-ji-gui-fan</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/DesignGuidelines.md#use-descriptive-declarations-for-methods-and-properties-that-return-a-signal">Design Guidelines</a>【译】</p>

<h4>RACSequence 的一些约定</h4>

<ol>
<li>默认情况延迟发生</li>
<li>默认会阻塞调用者</li>
<li>副作用只发生一次</li>
</ol>


<h4>RACSignal 的约定</h4>

<ol>
<li>信号事件有序串行执行，保证不会同时到达两个或多个信号，但是可以运行在不同的scheduler之上。</li>
<li>订阅事件总会在一个 scheduler 上</li>
<li>错误会立即传播（优先级最高）</li>
<li>订阅事件会产生副作用</li>
<li>订阅关系总会在complete或error时自动销毁</li>
<li>销毁会取消正在执行的任务并且清理相关的资源</li>
</ol>


<!--more-->


<h4>常用练习</h4>

<ul>
<li><p>为返回信号的方法或属性使用描述性声明
声明语义有三个维度</p>

<ol>
<li>冷信号（是否在此时被激活）还是热信号（需要订阅后激活）</li>
<li>信号返回值的个数是0个一个或更多？</li>
<li>信号是否有副作用</li>
</ol>
</li>
<li><p>举个栗子</p>

<ul>
<li><strong>没有副作用的热信号：</strong>通常声明为属性来代替方法。暗示订阅之前不需要任何初始化，并且之后附加的任何订阅不会影响当前的订阅语义（没有副作用且每次订阅都是独立的语义）。信号属性通常命名在事件之后（eg: <code>textChangedSignal</code>）</li>
<li><strong>没有副作用的冷信号：</strong>通常使用一个方法返回信号，并且通常使用名词命名（eg:<code>-currentText</code>）。方法声明暗示信号不会被保存（持有），暗示只有在订阅时才会执行任务。如果信号发送多个值，该名词必须是复数的。(-<code>currentModels</code>）</li>
<li><strong>有副作用的冷信号：</strong>通常使用方法返回，并且使用动词命名（eg:<code>-logIn</code>）.动词命名暗示该方法的执行不是幂等得并且使用该方法的调用者需要小心清楚副作用的影响，除非副作用是被需要的或允许范围内的。如果该信号包含一个或多个值，需要用一个名词命名，并且使用对应的单复数形式。</li>
</ul>
</li>
</ul>


<h4>缩进流操作一致</h4>

<p> 如果不适当的格式化，纯流式的代码将会变得很密集并且混乱。使用一致的缩进来高亮链式流的开始和结束。</p>

<p>当在单个流上调用方法时，不需要额外的缩进。
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RACStream</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">stream</span> <span class="nl">startWith</span><span class="p">:</span><span class="mi">@0</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">RACStream</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">result2</span> <span class="o">=</span> <span class="p">[</span><span class="n">stream</span> <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNumber</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="l">@(</span><span class="n">value</span><span class="p">.</span><span class="n">integerValue</span> <span class="o">+</span> <span class="mi">1</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="err">``</span>
</span><span class='line'><span class="err">当多次转换相同的流时，请确保所有步骤都对齐。</span> <span class="err">复杂运算符</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;+</span> <span class="n">zip</span><span class="err">：</span><span class="n">reduce</span><span class="err">：</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="err">或</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;+</span> <span class="n">combineLatest</span><span class="err">：</span><span class="n">reduce</span><span class="err">：`可以拆分为多行以提高可读性：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span> <span class="k">class</span><span class="o">=</span><span class="s">&quot;objc&quot;</span><span class="o">&gt;</span><span class="n">RACStream</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">RACStream</span>
</span><span class='line'>    <span class="nl">zip</span><span class="p">:</span><span class="l">@[</span> <span class="n">firstStream</span><span class="p">,</span> <span class="n">secondStream</span> <span class="l">]</span>
</span><span class='line'>    <span class="nl">reduce</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">first</span><span class="p">,</span> <span class="bp">NSNumber</span> <span class="o">*</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="l">@(</span><span class="n">first</span><span class="p">.</span><span class="n">integerValue</span> <span class="o">+</span> <span class="n">second</span><span class="p">.</span><span class="n">integerValue</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="nl">filter</span><span class="p">:</span><span class="o">^</span> <span class="kt">BOOL</span> <span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">integerValue</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}]</span>
</span><span class='line'>    <span class="nl">map</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSNumber</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="l">@(</span><span class="n">value</span><span class="p">.</span><span class="n">integerValue</span> <span class="o">+</span> <span class="mi">1</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">当然，使用</span><span class="n">block</span><span class="err">参数嵌套的流需要从</span><span class="n">block</span><span class="err">的自然缩进开始。</span>
</span></code></pre></td></tr></table></div></figure>objc
[[signal
    then:^{
        @strongify(self);</p>

<pre><code>    return [[self
        doSomethingElse]
        catch:^(NSError *error) {
            @strongify(self);
            [self presentError:error];

            return [RACSignal empty];
        }];
}]
subscribeCompleted:^{
    NSLog(@"All done.");
}];
</code></pre>

<pre><code>
#### 单个流中的所有值类型必须保持一致。
使用不同类型需要使用复杂的操作流程，且会给使用流的消费者增加额外的负担。

#### 避免过久的持有流
如果持有流的时间超过他本身需要存活的时间时，将会导致流本身持有的或依赖的资源无法释放，潜在的造成内存使用过高。

#### 只处理需要的信号
除了会增加内存使用，不必要的持有流或者 `RACSignal` 订阅关系会导致 CPU 使用增加, 因为不必要的任务执行所得出的结果永远不会被使用到。一般可以使用`-take`或`-takeUntil`可以自动在不必要的时候取消流执行

#### 在已知的 Scheduler 上传送信号事件
流信号返回的值可能会来自很多复杂的场景，很可能是在底层线程中造作得出，所以在给UI元素这是返回的信号值时，一定要保证其赋值造作发成在`mainScheduler` (主线程)只上。

#### 尽可能少的切换调度者（`scheduler`）

非必须的情况下，务必让流信号的执行发生在同一 `Scheduler` 之上。因为切换 `Scheduler` 会引入不必要的延迟并且会增加CPU资源的消耗。

通常 `-deliverOn:`严格限制只会在信号链的尾部使用，比如在订阅之前，或为属性绑定值时

#### 明确信号的副作用
通常一定要避免副作用的发生，但是有一些副作用是我们所期望的,一般应用在一些hook方法进行调试，例如 `-doNext:`、`-doError:`、`-doCompleted:`等
</code></pre>

<p>NSMutableArray <em>nexts = [NSMutableArray array];
__block NSError </em>receivedError = nil;
__block BOOL success = NO;
RACSignal <em>bookkeepingSignal = [[[valueSignal
    doNext:^(id x) {
        [nexts addObject:x];
    }]
    doError:^(NSError </em>error) {
        receivedError = error;
    }]
    doCompleted:^{
        success = YES;
    }];</p>

<p>RAC(self, value) = bookkeepingSignal;</p>

<pre><code>
#### 使用组播分享带有副作用的信号
使用组播可以允许单个信号拥有任意数量的订阅关系。
</code></pre>

<p>// This signal starts a new request on each subscription.
RACSignal <em>networkRequest = [RACSignal createSignal:^(id<RACSubscriber> subscriber) {
    AFHTTPRequestOperation </em>operation = [client
        HTTPRequestOperationWithRequest:request
        success:^(AFHTTPRequestOperation <em>operation, id response) {
            [subscriber sendNext:response];
            [subscriber sendCompleted];
        }
        failure:^(AFHTTPRequestOperation </em>operation, NSError *error) {
            [subscriber sendError:error];
        }];</p>

<pre><code>[client enqueueHTTPRequestOperation:operation];
return [RACDisposable disposableWithBlock:^{
    [operation cancel];
}];
</code></pre>

<p>}];</p>

<p>// Starts a single request, no matter how many subscriptions <code>connection.signal</code>
// gets. This is equivalent to the -replay operator, or similar to
// +startEagerlyWithScheduler:block:.
RACMulticastConnection *connection = [networkRequest multicast:[RACReplaySubject subject]];
[connection connect];</p>

<p>[connection.signal subscribeNext:^(id response) {
    NSLog(@&ldquo;subscriber one: %@&rdquo;, response);
}];</p>

<p>[connection.signal subscribeNext:^(id response) {
    NSLog(@&ldquo;subscriber two: %@&rdquo;, response);
}];
```</p>

<h4>通过给信号命名进行调试</h4>

<pre><code class="objc">RACSignal *signal = [[[RACObserve(self, username)
    distinctUntilChanged]
    take:3]
    filter:^(NSString *newUsername) {
        return [newUsername isEqualToString:@"joshaber"];
    }];

NSLog(@"%@", signal);
// 打印结果 [[[RACObserve(self, username)] -distinctUntilChanged] -take: 3] -filter:
</code></pre>

<p>使用 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACStream.h">-setNameWithFormat:</a> 对信号自定义信号名。
此外，<code>RACSignal</code> 还提供了 <code>-logNext</code>, <code>-logError</code>,<code>-logCompleted</code>, <code>-logAll</code>方法，当信号事件执行时自动打印信号的信息（包括 <code>name</code>），更方便检测到信号的实时状况。</p>

<h4>避免显式的订阅和销毁</h4>

<p>虽然-subscribeNext：error：completed：和它的变体是处理信号的最基本的方式，但是它们较少的声明性，鼓励使用副作用和潜在地复制内置功能而使代码复杂化。</p>

<p>同时，显式的调用 <code>RACDisposable</code> 类会快速导致一堆乱七八糟的资源管理并且清理代码。</p>

<ul>
<li>解决方案 ：使用较高级别的模式来替换手动订阅和销毁

<ul>
<li>使用 <code>RAC()</code> 或者 <code>RACChannelTo</code> 宏定义可以用来绑定信号或者属性，代替在状态变化时手动更新。</li>
<li>例如 <code>-takeUntil:</code> 等操作符可以用来当参数中的事件发生时自动销毁一段订阅关系（比如 <code>取消按钮</code> 被点击时）。</li>
</ul>
</li>
</ul>


<p>通常 ，相比于使用订阅的回调，使用内置的 <code>stream</code> 和 <code>signal</code> 操作符将会让代码变得更简洁并且能产生更少的易错代码。</p>

<h4>尽可能避免使用 subjects</h4>

<p><code>Subject</code> 是一个用来桥接代码到 signal 世界的强大工具，但是就像 RAC 中的可变变量一样，当发生滥用时，他们会更快的导致程序变得复杂。</p>

<p>Subjects 通常会被 ReactiveCocoa 的其他模式所代替：
  * 相比于给 <code>Subject</code> 提供初始值，不如考虑使用  <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACSignal.h">+createSignal:</a> block 产生值代替。
  * 相比于将一些中间值发送给发送给 subject，不如使用 <code>+combineLatest:</code> 或者 <code>+zip:</code>操作符组合多个信号的输出值。
  * 基于一个 Signal 使用 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/Documentation/DesignGuidelines.md#share-the-side-effects-of-a-signal-by-multicasting">multicast</a> (组播)，而不是使用多个 订阅者共享 <code>subjects</code> 的结果。
  * 使用 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACCommand.h">command</a> 或者 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/NSObject+RACSelectorSignal.h">-rac_signalForSelector:</a> ，而不是为了简单的控制一个 subject 实现一个事件方法。</p>

<p>  当不得不使用 subject 时，他们必须是信号链中最基本的输入，而不是其中的一个。</p>

<h3>支持自定义操作符</h3>

<h4>推荐使用 RACStream 的方法</h4>

<h4>尽可能使用现有的操作符进行构思</h4>

<h3>尽量避免引入并发</h3>

<p>尽量使用 RACScheduler 代替</p>

<h4>在 disposable 中取消任务和清理所有关联资源。</h4>

<p>当使用 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACSignal.h">+createSignal:</a> 创建信号是，通常会返回一个 <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACDisposable.h">RACDisposable</a> 对象。而这个 disposable 对象应该：
* 尽可能方便优雅的取消正在进行的由 <code>signal</code> 开启的任务。
* 立即销毁任何信号的订阅关系，由此来触发他们的取消和清除代码。
* 释放任何信号开辟的内存和占用的资源。</p>

<h4>不要在操作符中分块</h4>

<p>流操作符应该立即返回一个新的流。操作符需要执行的任何操作都应该是执行新流的一部分，而不是运算符调用本身的一部分。</p>

<pre><code class="objc">// WRONG!
- (RACSequence *)map:(id (^)(id))block {
    RACSequence *result = [RACSequence empty];
    for (id obj in self) {
        id mappedObj = block(obj);
        result = [result concat:[RACSequence return:mappedObj]];
    }

    return result;
}

// Right!
- (RACSequence *)map:(id (^)(id))block {
    return [self flattenMap:^(id obj) {
        id mappedObj = block(obj);
        return [RACSequence return:mappedObj];
    }];
}
</code></pre>

<h4>避免深度递归导致的堆栈溢出</h4>

<p>任何可能无限递归的操作符都应该使用 <code>-scheduleRecursiveBlock:</code>  <a href="https://github.com/ReactiveCocoa/ReactiveObjC/blob/master/ReactiveObjC/RACScheduler.h">RACScheduler</a> 方法。这个方法将会把递归转换为迭代来防止堆栈溢出。
例如：下面的例子将会错误地实现 <code>-repeat</code> ,应为这将潜在的引起堆栈溢出并且崩溃。</p>

<pre><code class="objc ">- (RACSignal *)repeat {
    return [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];

        __block void (^resubscribe)(void) = ^{
            RACDisposable *disposable = [self subscribeNext:^(id x) {
                [subscriber sendNext:x];
            } error:^(NSError *error) {
                [subscriber sendError:error];
            } completed:^{
                resubscribe();
            }];

            [compoundDisposable addDisposable:disposable];
        };

        return compoundDisposable;
    }];
}
</code></pre>

<p>相比之下，下面的版本将会避免。</p>

<pre><code class="objc">- (RACSignal *)repeat {
    return [RACSignal createSignal:^(id&lt;RACSubscriber&gt; subscriber) {
        RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];

        RACScheduler *scheduler = RACScheduler.currentScheduler ?: [RACScheduler scheduler];
        RACDisposable *disposable = [scheduler scheduleRecursiveBlock:^(void (^reschedule)(void)) {
            RACDisposable *disposable = [self subscribeNext:^(id x) {
                [subscriber sendNext:x];
            } error:^(NSError *error) {
                [subscriber sendError:error];
            } completed:^{
                reschedule();
            }];

            [compoundDisposable addDisposable:disposable];
        }];

        [compoundDisposable addDisposable:disposable];
        return compoundDisposable;
    }];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript 骨骼动画 (DragonBones) 在 iOS 端截屏功能]]></title>
    <link href="http://yangchao0033.github.io/blog/2017/07/25/js-gu-ge-dong-hua-dragonbones-zai-ios-duan-jie-ping-gong-neng/"/>
    <updated>2017-07-25T23:30:10+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2017/07/25/js-gu-ge-dong-hua-dragonbones-zai-ios-duan-jie-ping-gong-neng</id>
    <content type="html"><![CDATA[<h3>需求背景：</h3>

<p>使用 DragonBones 在 Webview 中绘制骨骼动画，并对当前的骨骼页面进行图层截取，实现保存本地和分享功能。</p>

<h3>问题：</h3>

<p>使用 DragonBones 制作骨骼动画时遇到一个问题，使用 WKWebView 加载骨骼动画正常，再对 WKWebView 的父容器 view （控制器 view ）进行截图是出现空白。</p>

<h4>解决思路及方案一：</h4>

<!--more-->


<p>通过资料查阅，发现 WKWebView 在截图时比较特殊,需要调用 UIView 的分类，也就是
<code>objc
- (nullable UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates NS_AVAILABLE_IOS(7_0);
</code>
进行View图层的快照获取，推测和 WKWebView 的渲染原理相关。因为正常流程都是通过 UIGraphics 去捕捉 UIView 的上下文来生成 UIImage 对象，进而分享或保存到本地。
<code>objc
+ (UIImage *)getSharingImageWithView:(UIView *)originView {
    UIImage *snapshotImage = nil;
    UIGraphicsBeginImageContextWithOptions(originView.bounds.size, NO, [UIScreen mainScreen].scale);
    [originView.layer renderInContext:UIGraphicsGetCurrentContext()];
    snapshotImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return snapshotImage;
}
</code>
对 WkWebView、TableView 等滚动视图循环截屏可参考 <a href="https://github.com/TonyReet/TYSnapshotScroll">TYSnapshotScroll</a>。
当然，例如 TYSnapshotScroll 提供的 WKWebView 截图方式（snapshotViewAfterScreenUpdates）截取方式对类似 github、google 等首页的截取非常完美。</p>

<p>但是，在加载骨骼动画时只有动画背景，没有任务形象。</p>

<h4>解决思路及方案二：</h4>

<p>根据从安卓和前端收集的信息来看:
1. h5 骨骼动画底层使用了 canvas 绘图(一个类似于 iOS CoreGraphic 的库，专门负责绘制复杂图形。)
2. JavaScript 使用 canvas 绘图时，会存在这样的关系，直接上图</p>

<p><img src="http://upload-images.jianshu.io/upload_images/1445110-6f6cd7e375e337f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="canvas 的七大姑八大姨" /></p>

<ol>
<li>上图中最有价值的线索是，canvas 会调用 webGL 进行渲染，同时会调用硬件加速功能</li>
<li>安卓端在手动关闭硬件加速后，该页面截屏恢复正常。</li>
</ol>


<p>然鹅，只有 Safari 中有对 WebGL 有控制权，WKWebView 并不能通过代码关闭硬件加速。
所以只能放弃使用 canvas 动态绘制的 webView 进行图像提取。</p>

<p>所以，我们采取了采取了双端结合的思路：
* 由 JavaScript 通过 canvas 输出 base64 图片字符串，以及人物背景图片的URL
JavaScript生成图片：
<code>js
var fullQuality = canvas.toDataURL('image/jpeg', 1.0); // 参数二控制图片质量
// data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ...9oADAMBAAIRAxEAPwD/AD/6AP/Z"
var mediumQuality = canvas.toDataURL('image/jpeg', 0.5);
var lowQuality = canvas.toDataURL('image/jpeg', 0.1);
</code>
Native 解析图片：
<code>objc
NSData *decodedImageData = [NSData dataWithContentsOfURL:[NSURL URLWithString:base64String]];
UIImage *decodedImage = [UIImage imageWithData:decodedImageData
                                         scale:[UIScreen mainScreen].scale];
personImageView.image = decodedImage;
</code>
* 由 Native 对使用这些资源进行布局渲染，并且控制截屏时用户信息、二维码等元素的展示，效果如图：</p>

<p><img src="http://upload-images.jianshu.io/upload_images/1445110-9d3101208a5f022e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="骨骼动画截屏" /></p>

<h3>总结</h3>

<p>对于部分特殊控件的图像处理可能要会出现位置的异常，需要对对应的底层实现技术点进行剖析，倒推引起的原因。</p>

<h4>参考：</h4>

<p><a href="http://www.zhangxinxu.com/wordpress/2011/10/html5-canvas-webgl-css-shaders-glsl%E7%9A%84%E6%9A%A7%E6%98%A7%E5%85%B3%E7%B3%BB/">HTML5 Canvas,WebGL,CSS Shaders,GLSL的暧昧关系</a>
<a href="https://www.egret.com/">egret</a>
<a href="http://dragonbones.com/cn/index.html">dragonBone</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让 iOS/Android 网络API开发更加自由-charles模拟服务器返回本地数据]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/03/05/develop-moblie-api-with-charles-and-server-data-with-charles/"/>
    <updated>2016-03-05T14:52:25+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/03/05/develop-moblie-api-with-charles-and-server-data-with-charles</id>
    <content type="html"><![CDATA[<blockquote><p><strong>原因：</strong>在与服务器联调接口之后，所有的API都能正常跑通，但是涉及到具体的业务逻辑时，比如界面遇到不同的数据做出特定的布局操作或弹框提示，再或者只有当数据字段符合特定的值时才能做出更多复杂的逻辑操作。如果依赖于服务器或者数据库，那么需要他们去帮你制造假数据来检测你的代码的正确性，这样是一次两次没问题，但是量大的时候，会影响双方的开发进度。能不能采取解耦的思想让移动端和服务端分隔开，在移动端测试开发阶段，自己根据接口文档制造自己需要的特定的返回数据呢？</p></blockquote>

<p><strong>解决方案：</strong>这时候我们需要自己的代理服务器来实现&ndash;使用 Charles 制作代理服务器。</p>

<p><strong>具体需求：</strong>当API有所改动时，服务器正在开发相应功能，但是还没有部署到服务器上去，只是在原接口的返回数据中多加了一个字段“id”。现在移动端的业务逻辑写好了，就等数据测试了。</p>

<p><strong>具体操作步骤：</strong></p>

<!--more-->


<p><strong>一、</strong>首先你需要下载一个 Charles，并且安装起来，具体的使用方法这里不做赘述。可以移步<a href="http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles">这里</a>学习。
<strong>二、</strong>抓取你需要修改的接口
<img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%8A%93%E5%8F%96%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3.png?raw=true" alt="抓取一个接口.png" />
大家可以看到，这个接口返回的是一个json串。这个请求是手机发起的，我们看到的只是软件抓到的包数据。那么如何加入新的“id”字段呢？)
大家可以看到，这个接口返回的是一个json串。这个请求是手机发起的，我们看到的只是软件抓到的包数据。那么如何加入新的“id”字段呢？</p>

<p><strong>三、</strong>使用 Charles 的 local map 功能</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%BF%9D%E5%AD%98response%E6%95%B0%E6%8D%AE.png?raw=true" alt="保存response数据.png" /></p>

<p>保存 response 数据到本地电脑上去</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E9%80%89%E6%8B%A9localmap.png?raw=true" alt="选择localmap.png" /></p>

<p>选择local map</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%B7%BB%E5%8A%A0%E9%9C%80%E8%A6%81map%E7%9A%84%E6%8E%A5%E5%8F%A3.png?raw=true" alt="添加需要map的接口.png" /></p>

<p>点击 Add 添加 map 规则</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/map%E8%A7%84%E5%88%99.png?raw=true" alt="map规则.png" />
这些地方填入你的API信息，以及刚才保存的 response 文件地址</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E7%82%B9%E5%87%BB%E4%BF%9D%E5%AD%98map.png?raw=true" alt="点击保存map.png" />
点击ok保存map规则。之后，只要是从你手机通过 Charles 代理发出的这个接口的请求，都会被重定向到你电脑上本地的 response 文件中。</p>

<p>现在，我们在通过手机调用一下之前的接口，结果呢？结果是还不如原来的，呵呵哒。。。</p>

<p>之前我们还能获取到 title、content和type三个字段以及他们的值，现在直接返回的数据为nil。</p>

<p>找了半天原因，最终通过对比发现了一个问题，两种请求的响应头不一样</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE.png?raw=true" alt="从服务器取到的数据.png" /></p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%9C%AC%E5%9C%B0map%E7%9A%84%E6%95%B0%E6%8D%AE.png?raw=true" alt="本地map的数据.png" /></p>

<p>所以怎么修改 response 的 content type 类型为 json/application 呢？</p>

<p><strong>三、</strong>使用 Rewrite 替换特定接口的响应头参数</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%89%93%E5%BC%80rewrite.png?raw=true" alt="打开rewrite.png" /></p>

<p>打开 Rewrite</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/rewrite%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2.png?raw=true" alt="rewrite配置页面.png" /></p>

<p>Rewrite 配置页面简介</p>

<p>1、首先创建一个规则集</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E6%B7%BB%E5%8A%A0%E6%8E%A5%E5%8F%A3%E9%9B%86%E5%90%88%E5%92%8C%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4.png?raw=true" alt="添加接口集合和适用范围.png" /></p>

<p>添加 Rewrite 替换规则</p>

<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/3/%E4%B9%A6%E5%86%99rewrite%E6%9B%BF%E6%8D%A2%E8%A7%84%E5%88%99.png?raw=true" alt="书写rewrite替换规则.png" /></p>

<p>这里相当于是在响应回来之前，通过字段的匹配，替换掉原有的响应头中的Content-Type 类型为 json/application</p>

<p>所有的对话框都点击 ok 或者 apply 确定保存</p>

<p>现在我们开始测试啦，继续调用该接口。</p>

<p>四、根据需求修改数据</p>

<p>数据修改前刚才看过了，只有 title/content/type 三个字段</p>

<pre><code class="json">{
"title":"标题",
"content":"内容正文",
"type":"类型"
}
</code></pre>

<p>而现在需要添加 “id” 字段。所以，用 vim 或者其他文本编辑器打开刚才保存的 response 文件，将他修改成这样</p>

<pre><code class="json">{
"id":"00000001",
"title":"标题",
"content":"内容正文",
"type":"类型"
}
</code></pre>

<p>修改后记得保存一下，现在重新开始请求该接口，查看log日志。</p>

<pre><code>{
"id":"00000001",
"title":"标题",
"content":"内容正文",
"type":"类型"
}
</code></pre>

<p>完美！下面开始愉快的测试我们自己的代码吧~</p>

<hr />

<h2>总结：</h2>

<h2>本文的目的主要是为了提高客户端和服务器各自独立开发的能力，像制造特定的假数据这种很简单的需求，如果不借助 Charles 代理去自己制造，恐怕你需要自己搭建一个服务器去各种恶补服务器的知识了。其实我们的原理十分简单，就是通过代理软件对网络请求进行拦截，并且返回我们想要的数据。这样做的好处就是，大大加强了客户端的自主开发能力，不需要依赖服务器对我们的特定逻辑进行开发，缩短开发周期。节约大家的时间，试想如果我们自己制造的数据如果在app中能跑通，即便服务器开发出来，如果出现跑不通的错误，那问题最有可能出现在服务器端，当然还要看具体的反馈信息。Charles 还有很多强大的功能，有待大家慢慢探索，祝大家玩得开心~</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HLS-iOS视频播放服务架构深入探究（二）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/02/14/hls-2/"/>
    <updated>2016-02-14T18:51:24+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/02/14/hls-2</id>
    <content type="html"><![CDATA[<p>HLS-Demo地址：<a href="https://github.com/yangchao0033/HLS-Demo">https://github.com/yangchao0033/HLS-Demo</a></p>

<p><strong>使用demo前请注意下面的问题，我在代码中也做了注释。</strong></p>

<pre><code class="objc">//#warning 注意，不要直接使用切换流的主索引，当前代码的协议只提供对.ts定位的子索引的下载和播放，而且其中只有点播协议那一小段是可以下载的，直播协议只能播放，无法下载，无法下载的原因是因为m3u8的那个库中只对特定的一种m3u8的格式做了解析，而m3u8的格式有很多种，所以无法加息出来，该demo只做演示，不会对所有格式进行全解析，如果大家感兴趣的话可以对m3u8的库进行扩展，在github 上 pull request 我做一个补充扩展😁，我会及时在博客中进行更新。博客地址：superyang.gitcafe.io或yangchao0033.github.io 同简书：http://www.jianshu.com/users/f37a8f0ba6f8/latest_articles

/** 点播协议 (只有这个是可以下载的，但是苦于太短，没办法播放出来，正在寻找可以下载并播放的新的点播或直播源,希望有读者可以帮忙提供哈，不甚感激~)*/
//#define TEST_HLS_URL @"http://m3u8.tdimg.com/147/806/921/3.m3u8"
/** 视频直播协议 */
/** 父索引(无法下载，只作为结构分析) */
//#define TEST_HLS_URL @"http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5.m3u8"
/** 子索引(无法下载，只作为结构分析) */
//#define TEST_HLS_URL @"http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5"
/** wwcd视频，果然苹果自己就用这个协议(无法下载，只作为结构分析) */
//#define TEST_HLS_URL @"http://devstreaming.apple.com/videos/wwdc/2015/413eflf3lrh1tyo/413/hls_vod_mvp.m3u8"
</code></pre>

<p>如果觉得文章有用的话，请读者在github上点个star😁，或者在<a href="http://www.jianshu.com/users/f37a8f0ba6f8/latest_articles">简书</a>上点个赞。</p>

<p>Demo配置原理：</p>

<p>1、 需要导入第三方库：ASIHttpRequest，CocoaHTTPServer，m3u8（其中ASI用于网络请求，CocoaHTTPServer用于在ios端搭建服务器使用，m3u8是用来对返回的索引文件进行解析的）</p>

<!--more-->


<p><img src="https://github.com/yangchao0033/HLS-Demo/blob/master/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%831.png?raw=true" alt="ASI配置注意事项" /></p>

<p><img src="https://github.com/yangchao0033/HLS-Demo/blob/master/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%832.png?raw=true" alt="MRC报错处理" /></p>

<p>2、导入系统库：libsqlite3.dylib、libz.dylib、libxml2.dylib、CoreTelephony.framework、SystemConfiguration.framework、MobileCoreServices.framework、Security.framework、CFNetwork.framework、MediaPlayer.framework</p>

<p>3、添加头文件</p>

<pre><code class="c">YCHLS-Demo.h
</code></pre>

<p>4、demo介绍
<img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/2/HLS_demo_UI.png?raw=true" alt="demo样式" /></p>

<ul>
<li><strong>播放：</strong>直接播放在线的直播链接，是由系统的MPMoviePlayer完成的，它自带解析HLS直播链的功能。</li>
<li><strong>下载：</strong>遵循HLS的协议，通过索引文件的资源路径下载相关的视频切片并保存到手机本地。</li>
<li><strong>播放本地视频：</strong>使用下载好的视频文件片段进行连续播放。</li>
<li><strong>清除缓存：</strong>删除下载好的视频片段</li>
</ul>


<p>原理：</p>

<ol>
<li>通过ASI请求链接，通过m3u8库解析返回的m3u8索引文件。</li>
<li>再通过ASI下载解析出的视频资源地址，仿照HLS中文件存储路径存储。</li>
<li>利用CocoaHTTPServer在iOS端搭建本地服务器，并开启服务，端口号为：12345（高位端口即可）。配置服务器路径与步骤二存储路径一致。</li>
<li>设置播放器直播链接为本地服务器地址，直接播放，由于播放器遵守HLS协议，所以能够解析我们之前使用HLS协议搭建的本地服务器地址。</li>
<li>点击在线播放，校验是否与本地播放效果一致。</li>
</ol>


<p><img src="https://github.com/yangchao0033/yangchao0033.github.io/blob/source/images/ios/2016/2/HLS%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%20.png?raw=true" alt="HLS协议文件存储结构" /></p>

<p>上面是HLS中服务器存储视频文件切片和索引文件的结构图</p>

<p>整个操作流程就是：</p>

<ol>
<li>先点击下载，通过解析m3u8的第三方库解析资源。（m3u8的那个库只能解析一种特定格式的m3u8文件，代码里会有标注）</li>
<li>点击播放本地视频播放下载好的资源。</li>
<li>点击播放是用来预览直播的效果，与整个流程无关。</li>
<li>其中进度条用来显示下载进度。</li>
</ol>


<blockquote><p>总结：
整个Demo并不只是让我们搭建一个Hls服务器或者一个支持Hls的播放器。目的在于了解Hls协议的具体实现，以及服务器端的一些物理架构。通过Demo的学习，可以详细的了解Hls直播具体的实现流程。</p></blockquote>

<p>部分源码贴出：</p>

<p>开启本地服务器：</p>

<pre><code class="objc">- (void)openHttpServer
{
    self.httpServer = [[HTTPServer alloc] init];
    [self.httpServer setType:@"_http._tcp."];  // 设置服务类型
    [self.httpServer setPort:12345]; // 设置服务器端口

    // 获取本地Library/Cache路径下downloads路径
    NSString *webPath = [kLibraryCache stringByAppendingPathComponent:kPathDownload];
    NSLog(@"-------------\nSetting document root: %@\n", webPath);
    // 设置服务器路径
    [self.httpServer setDocumentRoot:webPath];
    NSError *error;
    if(![self.httpServer start:&amp;error])
    {
        NSLog(@"-------------\nError starting HTTP Server: %@\n", error);
    }
</code></pre>

<p>视频下载：</p>

<pre><code class="objc">- (IBAction)downloadStreamingMedia:(id)sender {

    UIButton *downloadButton = sender;
    // 获取本地Library/Cache路径
    NSString *localDownloadsPath = [kLibraryCache stringByAppendingPathComponent:kPathDownload];

    // 获取视频本地路径
    NSString *filePath = [localDownloadsPath stringByAppendingPathComponent:@"XNjUxMTE4NDAw/movie.m3u8"];
    NSFileManager *fileManager = [NSFileManager defaultManager];
    // 判断视频是否缓存完成，如果完成则播放本地缓存
    if ([fileManager fileExistsAtPath:filePath]) {
        [downloadButton setTitle:@"已完成" forState:UIControlStateNormal];
        downloadButton.enabled = NO;
    }else{
        M3U8Handler *handler = [[M3U8Handler alloc] init];
        handler.delegate = self;
        // 解析m3u8视频地址
        [handler praseUrl:TEST_HLS_URL];
        // 开启网络指示器
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
    }
}
</code></pre>

<p>播放本地视频：</p>

<pre><code class="objc">- (IBAction)playVideoFromLocal:(id)sender {

    NSString * playurl = [NSString stringWithFormat:@"http://127.0.0.1:12345/XNjUxMTE4NDAw/movie.m3u8"];
    NSLog(@"本地视频地址-----%@", playurl);

    // 获取本地Library/Cache路径
    NSString *localDownloadsPath = [kLibraryCache stringByAppendingPathComponent:kPathDownload];
    // 获取视频本地路径
    NSString *filePath = [localDownloadsPath stringByAppendingPathComponent:@"XNjUxMTE4NDAw/movie.m3u8"];
    NSFileManager *fileManager = [NSFileManager defaultManager];

    // 判断视频是否缓存完成，如果完成则播放本地缓存
    if ([fileManager fileExistsAtPath:filePath]) {
        MPMoviePlayerViewController *playerViewController =[[MPMoviePlayerViewController alloc]initWithContentURL:[NSURL URLWithString: playurl]];
        [self presentMoviePlayerViewControllerAnimated:playerViewController];
    }
    else{
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"Sorry" message:@"当前视频未缓存" delegate:self cancelButtonTitle:@"确定" otherButtonTitles:nil, nil];
        [alertView show];
    }
}
</code></pre>

<p>播放在线视频</p>

<pre><code class="objc">- (IBAction)playLiveStreaming {

    NSURL *url = [[NSURL alloc] initWithString:TEST_HLS_URL];
    MPMoviePlayerViewController *player = [[MPMoviePlayerViewController alloc] initWithContentURL:url];
    [self presentMoviePlayerViewControllerAnimated:player];
}
</code></pre>

<p><del>当然，《芈月传》的直播链接到现在也还没有找到，各位热心读者如果有链接的话可以留言给我，也让这篇文章能实至名归了，能对得文章的标题了😁。</del></p>

<p>同志们，找到了官方的切片工具，已将《芈月传》切片放到了服务器上，1080P高清无码，敬请观看😁
具体代码我也做了更新，请大家更新代码后测试<a href="https://github.com/yangchao0033/HLS-Demo">Demo</a>~</p>

<p>具体播放地址为:<a href="http://yangchao0033.github.io/hlsSegement/0640.m3u8">http://yangchao0033.github.io/hlsSegement/0640.m3u8</a>(可在safari中直接观看)
切片工具博客：<a href="http://www.henishuo.com/hls-streaming-tool/">http://www.henishuo.com/hls-streaming-tool/</a>
总算不用做标题党了，摔🤓~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HLS-iOS视频播放服务架构深入探究（一）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/29/hls-1/"/>
    <updated>2016-01-29T18:10:36+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/29/hls-1</id>
    <content type="html"><![CDATA[<h1>HTTP Live Streaming (HLS)</h1>

<p>苹果官方对于视频直播服务提出了 HLS 解决方案，该方案主要适用范围在于：</p>

<ul>
<li>使用 iPhone 、iPod touch、 iPad 以及 Apple TV 进行流媒体直播功能。（MAC 也能用）</li>
<li>不使用特殊的服务软件进行流媒体直播。</li>
<li>需要通过加密和鉴定（authentication）的视频点播服务。</li>
</ul>


<p>首先，需要大家先对 HLS 的概念进行预览。</p>

<!--more-->


<p>HLS 的目的在于，让用户可以在苹果设备（包括MAC OS X）上通过普通的网络服务完成流媒体的播放。 HLS 同时支持流媒体的<strong>实时广播</strong>和<strong>点播服务</strong>。同时也支持不同 bit 速率的<strong>多个备用流</strong>（平时根据当前网速去自适应视频的清晰度），这样客户端也好根据当前网络的带宽去只能调整当前使用的视频流。安全方面，HLS 提供了通过 HTTPS 加密对媒体文件进行加密 并 对用户进行验证，允许视频发布者去保护自己的网络。</p>

<p>HLS 是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p>

<p>HLS只请求基本的HTTP报文，与实时传输协议（RTP)不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流。</p>

<p>苹果对于自家的 HLS 推广也是采取了强硬措施，当你的直播内容持续十分钟
或者每五分钟内超过 5 MB 大小时，你的 APP 直播服务必须采用 HLS 架构，否则不允许上架。（<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW5">详情</a>）</p>

<h1>相关服务支持环境 （重要组成）</h1>

<ul>
<li><code>Adobe Flash Media Server</code>：从4.5开始支持HLS、Protected HLS（PHLS）。5.0改名为Adobe Media Server</li>
<li><a href="http://www.flussonic.com/">Flussonic Media Server</a>：2009年1月21日，版本3.0开始支持VOD、HLS、时移等。</li>
<li>RealNetworks的 <code>Helix Universal Server</code> ：2010年4月，版本15.0开始支持iPhone, iPad和iPod的HTTP直播、点播H.264/AAC内容，最新更新在2012年11月。</li>
<li>微软的IIS Media Services：从4.0开始支持HLS。</li>
<li><code>Nginx RTMP Module</code>：支持直播模式的HLS。</li>
<li><a href="https://wmspanel.com/nimble">Nimber Streamer</a></li>
<li><a href="http://www.unified-streaming.com/">Unified Streaming Platform</a></li>
<li><a href="https://zh.wikipedia.org/wiki/VLC_Media_Player">VLC Media Player</a>：从2.0开始支持直播和点播HLS。</li>
<li>Wowza Media Server：2009年12月9日发布2.0，开始全面支持HLS。</li>
<li>VODOBOX Live Server：始支持HLS。</li>
<li><a href="http://github.com/i4tv/gstreamill">Gstreamill</a>是一个支持hls输出的，基于gstreamer的实时编码器。</li>
</ul>


<h1>相关客户端支持环境</h1>

<ul>
<li>iOS从3.0开始成为标准功能。</li>
<li>Adobe Flash Player从11.0开始支持HLS。</li>
<li>Google的Android自Honeycomb（3.0）开始支持HLS。</li>
<li>VODOBOX HLS Player (Android,iOS, Adobe Flash Player)</li>
<li>JW Player (Adobe Flash player)</li>
<li>Windows 10 的 EDGE 浏览器开始支持HLS。</li>
</ul>


<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/art/transport_stream_2x.png" alt="HLS架构" /></p>

<p>其中输入视频源是由摄像机预先录制好的。之后这些源会被编码 <code>MPEG-4</code>（H.264 video 和 AAC audio）格式然后用硬件打包到 <code>MPEG-2</code> 的传输流中。<code>MPEG-2</code> 传输流会被分散为小片段然后保存为一个或多个系列的 .ts 格式的媒体文件。这个过程需要借助编码工具来完成，比如 Apple stream segmenter。</p>

<p>纯音频会被编码为一些音频小片段，通常为 ADTS头的AAC、MP3、或者 AC-3格式。</p>

<p>同时上面提到的那个切片器（segmenter）也会创建一个索引文件，通常会包含这些媒体文件的一个列表，也能包含元数据。他一般都是一个.M38U 个hi的列表。列表元素会关联一个 URL 用于客户端访问。然后按序去请求这些 URL。</p>

<h3>服务器端</h3>

<p>服务端可以采用硬件编码和软件编码两种形式，其功能都是按照上文描述的规则对现有的媒体文件进行切片并使用索引文件进行管理。而软件切片通常会使用 Apple 公司提供的工具或者第三方的集成工具。</p>

<h4>媒体编码</h4>

<p>媒体编码器获取到音视频设备的实时信号，将其编码后压缩用于传输。而编码格式必须配置为客户端所支持的格式，比如 H.264 视频和HE-AAC 音频。当前，支持 用于视频的 MPEG-2 传输流和 纯音频 MPEG 基本流。编码器通过本地网络将 MPEG-2 传输流分发出去，送到流切片器那里。标准传输流和压缩传输流无法混合使用。传输流可以被打包成很多种不同的压缩格式，这里有两个表详细列举了支持的压缩格式类型。
* <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW2">Audio Technologies</a>
* <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/MediaLayer/MediaLayer.html#//apple_ref/doc/uid/TP40007898-CH9-SW6">Vedio Technologies</a></p>

<h5>[重点]在编码中图，不要修改视频编码器的设置，比如视频大小或者编码解码器类型。如果避免不了，那修改动作必须发生在一个片段边界。并且需要早之后相连的片段上用 <code>EXT-X-DISCONTINUITY</code> 进行标记。</h5>

<h4>流切片器</h4>

<p>流切片器（通常是一个软件）会通过本地网络从上面的媒体编码器中读取数据，然后将着这些数据一组相等时间间隔的 <code>小</code> 媒体文件。虽然没一个片段都是一个单独的文件，但是他们的来源是一个连续的流，切完照样可以无缝重构回去。</p>

<p>切片器在切片同时会创建一个索引文件，索引文件会包含这些切片文件的引用。每当一个切片文件生成后，索引文件都会进行更新。索引用于追踪切片文件的有效性和定位切片文件的位置。切片器同时也可以对你的媒体片段进行加密并且创建一个密钥文件作为整个过程的一部分。</p>

<h4>文件切片器（相对于上面的流切片器）</h4>

<p>如果已近有编码后的文件（而不是编码流），你可以使用文件切片器，通过它对编码后的媒体文件进行 MPEG-2 流的封装并且将它们分割为等长度的小片段。切片器允许你使用已经存在的音视频库用于 HLS 服务。它和流切片器的功能相似，但是处理的源从流替换流为了文件。</p>

<h3>媒体片段文件</h3>

<p>媒体片段是由切片器生成的，基于编码后的媒体源，并且是由一系列的 <code>.ts</code> 格式的文件组成，其中包含了你想通过 MPEG-2 传送流携带的 H.264 视频 和 AAC
/MP3/AC-3 音频。对于纯音频的广播，切片器可以生产 MPEG 基础音频流，其中包含了 ADTS头的AAC、MP3、或者AC3等音频。</p>

<h3>索引文件（PlayLists）</h3>

<p>通常由切片器附带生成，保存为 <code>.M3U8</code> 格式，<code>.m3u</code> 一般用于 MP3 音频的索引文件。
<a href="">Note</a>如果你的扩展名是.m3u,并且系统支持.mp3文件，那客户的软件可能要与典型的 MP3 playList 保持一致来完成 流网络音频的播放。</p>

<p>下面是一个 <code>.M3U8</code> 的 playlist 文件样例，其中包含了三个没有加密的十秒钟的媒体文件：</p>

<pre><code>#EXT-X-VERSION:3
#EXTM3U
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:1

# Old-style integer duration; avoid for newer clients.
#EXTINF:10,
http://media.example.com/segment0.ts

# New-style floating-point duration; use for modern clients.
#EXTINF:10.0,
http://media.example.com/segment1.ts
#EXTINF:9.5,
http://media.example.com/segment2.ts
#EXT-X-ENDLIST
</code></pre>

<p>为了更精确，你可以在 version 3 或者之后的协议版本中使用 float 数来标记媒体片段的时长，并且要明确写明版本号，如果没有版本号，则必须与 version 1 协议保持一致。你可以使用官方提供的切片器去生产各种各样的 playlist 索引文件，详见 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW7">媒体文件切片器</a></p>

<h3>分布式部分</h3>

<p>分布式系统是一个网络服务或者一个网络缓存系统，用于通过 HTTP 向客户端发送媒体文件和索引文件。不用自定义模块发送内容。通常仅仅需要很简单的网络配置即可使用。而且这种配置一般就是限制指定 .M38U 文件和 .ts 文件的 MIME 类型。详见 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW3">部署 HTTP Live Streaming</a></p>

<h3>客户端部分</h3>

<p>客户端开始时回去抓取 索引文件(.m3u8/.m3u)，其中用URL来标记不同的流。索引文件可以指定可用媒体文件的位置，解密的密钥，以及任何可以切换的流。对于选中的流，客户端会有序的下载每一个可获得的文件。每一个文件都包含流中的连环碎片。一旦下载到足够量的数据，客户端会开始向用户展示重新装配好的媒体资源。</p>

<p>客户端负责抓取任何解密密钥，认证或者展示一个用于认证的界面，之后再解密需要的文件。</p>

<p>这个过程会一直持续知道出现 结束标记 <code>#EXT-X-ENDLIST</code>。如果结束标记不出现，该索引就是用于持续广播的。客户端会定期的加载一些新的索引文件。客户端会从新更新的索引文件中去查找加密密钥并且将关联的URL加入到请求队列中去。</p>

<h3>HLS 的使用</h3>

<p>使用 HLS 需要使用一些工具，当然大部分工具都是服务器端使用的，这里简单了解一下就行，包括 media stream segmenter, a media file segmenter, a stream validator, an id3 tag generator, a variant playlist generator.这些工具用英文注明是为了当你在<a href="https://developer.apple.com/">苹果开发中心</a>中寻找时方便一些。</p>

<h3>会话模式</h3>

<p>通常包含 Live 和 VOD （点播）两种</p>

<p><strong>点播VOD</strong>的特点就是可以获取到一个静态的索引文件，其中那个包含一套完整的资源文件地址。这种模式允许客户端访问全部节目。VOD点播拥有先进的下载技术，包括加密认证技术和动态切换文件传输速率的功能（通常用于不同分辨率视频之间的切换）。</p>

<p><strong>Live</strong> 会话就是实时事件的录制展示。它的索引文件一直处于动态变化的，你需要不断的更新索引文件 playlist 然后移除旧的索引文件。这种类型通过向索引文件添加媒体地址可以很容易的转化为VOD类型。在转化时不要移除原来旧的源，而是通过添加一个 <code>#ET-X-ENDLIST</code> 标记来终止实时事件。转化时如果你的索引文件中包含 <code>EXT-X-PLAYLIST-TYPE</code> 标签，你需要将值从 <code>EVENT</code> 改为 <code>VOD</code>。</p>

<p>ps:自己抓了一个直播的源，从索引中看到的结果是第一次回抓到代表不同带宽的playList(抓取地址：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5.m3u8</code>)</p>

<pre><code>#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056509,BANDWIDTH=700000,RESOLUTION=1280x720
34338_PVMT5_700/index.m3u8?Dnion_vsnae=34338_PVMT5
#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056535,BANDWIDTH=400000
34338_PVMT5_400/index.m3u8?Dnion_vsnae=34338_PVMT5
#EXT-X-STREAM-INF:PROGRAM-ID=1,PUBLISHEDTIME=1453914627,CURRENTTIME=1454056535,BANDWIDTH=1024000
34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5
</code></pre>

<p>这里面的链接不是视频源URL，而是一个用于流切换的主索（下面会有介绍）引我猜想是需要对上一次的抓包地址做一个拼接</p>

<p>组合的结果就是：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5</code>(纯属小学智力题😂。。。)将它作为抓取地址再一次的结果</p>

<pre><code>#EXTM3U
#EXT-X-VERSION:3
#EXT-X-MEDIA-SEQUENCE:134611
#EXT-X-TARGETDURATION:10
#EXTINF:9.960,
35/1454056634183_128883.ts?Dnion_vsnae=34338_PVMT5
#EXTINF:9.960,
35/1454056644149_128892.ts?Dnion_vsnae=34338_PVMT5
#EXTINF:9.960,
35/1454056654075_128901.ts?Dnion_vsnae=34338_PVMT5
</code></pre>

<p>同理，继续向下抓：（拼接地址：<code>http://dlhls.cdn.zhanqi.tv/zqlive/34338_PVMT5_1024/index.m3u8?Dnion_vsnae=34338_PVMT5/35/1454056634183_128883.ts?Dnion_vsnae=34338_PVMT5/36/1454059958599_131904.ts?Dnion_vsnae=34338_PVMT5</code>）
抓取结果：</p>

<pre><code>#EXTM3U
#EXT-X-VERSION:3
#EXT-X-MEDIA-SEQUENCE:134984
#EXT-X-TARGETDURATION:10
#EXTINF:9.280,
36/1454059988579_131931.ts?Dnion_vsnae=34338_PVMT5
#EXTINF:9.960,
36/1454059998012_131940.ts?Dnion_vsnae=34338_PVMT5
#EXTINF:9.960,
36/1454060007871_131949.ts?Dnion_vsnae=34338_PVMT5
</code></pre>

<p>相比于第二次又获取了一个片段的索引，而且只要是第二次之后，资源地址都会包含 <code>.ts</code>，说明里面是有视频资源URL的，不过具体的截取方法还是需要查看前面提到的IETF的那套标准的HLS的协议，利用里面的协议应该就能拼接出完整的资源路径进行下载。反正我用苹果自带的MPMoviePlayerController直接播放是没有问题的，的确是直播资源。与之前说过的苹果自带的QuickTime类似，都遵循了HLS协议用于流媒体播放。而每次通过拼接获取下一次的索引，符合协议里提到的不断的更替索引的动作。</p>

<h3>内容加密</h3>

<p>如果内容需要加密，你可以在索引文件中找到密钥的相关信息。如果索引文件中包含了一个密钥文件的信息，那接下来的媒体文件就必须使用密钥解密后才能解密打开了。当前的 HLS 支持使用16-octet 类型密钥的 AES-128 加密。这个密钥格式是一个由着在二进制格式中的16个八进制组的数组打包而成的。</p>

<p>加密的配置模式通常包含三种：
1. 模式一：允许你在磁盘上制定一个密钥文件路径，切片器会在索引文件中插入存在的密钥文件的 URL。所有的媒体文件都使用该密钥进行加密。
2. 模式二：切片器会生成一个随机密钥文件，将它保存在指定的路径，并在索引文件中引用它。所有的媒体文件都会使用这个随机密钥进行加密。
3. 模式三：每 n 个片段生成一个随机密钥文件，并保存到指定的位置，在索引中引用它。这个模式的密钥处于轮流加密状态。每一组 n 个片段文件会使用不同的密钥加密。</p>

<blockquote><p>理论上，不定期的碎片个数生成密钥会更安全，但是定期的生成密钥不会对系统的性能产生太大的影响。</p></blockquote>

<p>你可以通过 HTTP 或者 HTTPS 提供密钥。也可以选择使用你自己的基于会话的认证安排去保护发送的key。更多详情可以参考 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/DeployingHTTPLiveStreaming/DeployingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH2-SW2">通过 HTTPS 安全的提供预约</a></p>

<p>密钥文件需要一个 initialization vector (IV) 去解码加密的媒体文件。IV 可以随着密钥定期的改变。</p>

<h3>缓存和发送协议</h3>

<p>HTTPS通常用于发送密钥，同时，他也可以用于平时的媒体片段和索引文件的传输。但是当扩展性更重要时，这样做是不推荐的。HTTPS 请求通常都是绕开 web 服务缓存，导致所有内容请求都是通过你的服务进行转发，这有悖于分布式网络连接系统的目的。</p>

<p>处于这个原因，确保你发送的网络内容都明白非常重要。当处于实况广播模式时索引文件不会像分片媒体文件一样长时间的被缓存，他会动态不停地变化。</p>

<h3>流切换</h3>

<p>如果你的视频具备流切换功能，这对于用户来说是一个非常棒的体验，处于不同的带宽、不同的网速播放不同清晰度的视频流，这样只能的流切换可以保证用户感觉到非常流畅的观影体验，同时不同的设备也可以作为选择的条件，比如视网膜屏可以再网速良好的情况下播放清晰度更高的视频流。</p>

<p>这种功能的实现在于，索引文件的特殊结构</p>

<p><img src="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/art/indexing_2x.png" alt="流切换索引文件结构" /></p>

<p>有别于普通的索引，具备流热切换的索引通常由主索引和链接不同带宽速率的资源的子索引，由子索引再链接对引得.ts视频切片文件。其中主索引只下载一次，而子索引则会不停定期的下载，通常会先使用主索引中列出的第一个子索引，之后才会根据当时的网络情况去动态切换合适的流。客户端会在任何时间去切换不同的流。比如连入或者退出一个 wifi 热点。所有的切换都会使用相同的音频文件（换音频没多大意思相对于视频）在不同的流之间平滑的进行切换。
这一套不同速率的视频都是有工具生成的，使用<code>variantplaylistcreator</code> 工具并且为 <code>mediafilesegmenter</code> 或者 <code>mediastreamsegmenter</code> 指定 -generate-variant-playlist 选项,详情参考 <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/UsingHTTPLiveStreaming/UsingHTTPLiveStreaming.html#//apple_ref/doc/uid/TP40008332-CH102-SW3">下载工具</a></p>

<p>概念先写到这吧，前面的知识够对HSL的整体结构做一个初步的了解。</p>

<p>后面一篇博客会结合代码对整个流程进行说明。</p>

<h4>参考文献：</h4>

<p><a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/HTTPStreamingArchitecture/HTTPStreamingArchitecture.html#//apple_ref/doc/uid/TP40008332-CH101-SW4">苹果官方文档</a></p>

<p><a href="https://zh.wikipedia.org/wiki/HTTP_Live_Streaming#.E5.AE.A2.E6.88.B7.E7.AB.AF.E6.94.AF.E6.8C.81">维基百科</a></p>

<p><a href="http://my.oschina.net/CgShare/blog/302303">http://my.oschina.net/CgShare/blog/302303</a></p>

<p><a href="http://blog.csdn.net/woaifen3344/article/details/40837803">http://blog.csdn.net/woaifen3344/article/details/40837803</a></p>
]]></content>
  </entry>
  
</feed>
