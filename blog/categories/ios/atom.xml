<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | SuperYang`s Blog]]></title>
  <link href="http://yangchao0033.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yangchao0033.github.io/"/>
  <updated>2016-01-12T14:51:29+08:00</updated>
  <id>http://yangchao0033.github.io/</id>
  <author>
    <name><![CDATA[Super Yang]]></name>
    <email><![CDATA[757097678@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（四）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/08/runloopshen-du-tan-jiu-(4)/"/>
    <updated>2016-01-08T18:45:07+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/08/runloopshen-du-tan-jiu-(4)</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Run Loops</a></p>

<p>Run loops 是与线程相关联的基础设施的一部分。Run loop 是用来调度工作并且协调传入事件的时间处理循环。run loop 的目的是：让你的线程在有工作的任务的事后保持忙碌，并且在空闲的事后使线程保持休眠。</p>

<!--more-->


<p>Run loop 的管理并不是完全自动的，你仍然需要设计你的线程代码，并利用这些代码在合适的时机开启 run loop 并且相应传入的事件。Cocoa 和 Core Foundation 框架都提供了run loop 对象，以便于帮助你配置和管理你的线程 run loop。你的应用不需要显式的创建这些 run loop 对象。每条线程，包括应用的主线程，都会配有一个相关联的 run loop 对象。只有子线程们需要显式的（手动）运行它们的 run loop。然而，该 app 框架将会自动设置并且运行作为应用程序启动过程的一部分的处于 main thread （主线程）的 run loop。</p>

<p>接下来，我们一起看看关于 run loop 以及它们的配置相关的更多信息。参照<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/uid/TP40003725">NSRunLoop Class Reference</a> 以及 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/doc/uid/20001441-CH1g-112707">CFRunLoop Reference</a>。</p>

<h3>Run Loop 剖析</h3>

<p>run loop 是一个名副其实的循环。他会是你的线程不停地循环工作，具体包括线程的进入并且用来响应输入源所运行的事件处理程序。你的代码提供的控制状态将会被用来实现run loop具体的循环部分。换句话说，你的代码需要提供 while 或 for 循环来驱动你的 run loop。在你的 run loop 中，你使用一个 run loop 对象去“执行”接收事件的事件处理代码和调用已经安装好的 handlers。</p>

<p>run loop 通过两种不同类型的 source 来接收事件。Input source 传递异步事件，通常包括从其他线程或者其他应用发来的 message 。Timer source 也传递异步事件，通常发生在一个被安排好的时间或者重复的时间间隔。这两种类型的 source 都会使用 application-specific 处理例程来处理到来的事件。</p>

<p>插图3-1展示了 run loop 各种 source 的概念结构。input source 传递异步事件到相对应的 handler（处理程序）并且引起 <code>runUtilDate:</code> 方法（调用线程相关的 NSRunLoop 对象）退出。</p>

<p><em>插图3-1 run loop 和它的 source 结构</em>
<img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="插图3-1" /></p>

<p>除了处理 input source，run loop 同样也会生成一些关于 run loop 的行为的通知。注册 run-loop observers（观察者）去接收这些通知并且使用他们去在线程上做额外的处理。你可以使用 Core Foundation 框架去在你的线程上安装 run-loop observer 。</p>

<p>下面这些段落提供了更多地关于 runloop的组成 和 它们可以操作的modes，它们还描述了在事件处理的不同时间点生成的通知。</p>

<h3>Run Loop Modes</h3>

<p>一个 run loop mode 是一个包含 input sources 和 被监视的 timers 和 将要被通知的 run-loop 的observer 所组成的集合。每次你启动你的 run loop 时，你都会指定（隐式或者显式的）一种特定的“mode”来运行。在执行该运行循环的期间，只有与指定运行的 mode 相关联的 source 才会被检测和允许去发送他们的事件。（相同的，只有与指定运行的 mode 相关联的 observer 会被 run loop 的进度（progress）所通知）。关联到其他 modes 的 sources 直到 run loop 切换到对应的 mode 时才会继续让新的事件通行（只有到对应的mode下，相关的 source 才会继续其对应的功能）。</p>

<p>在你的代码中，可以使用名字来标记 modes，包括 Cocoa 和 Core Foundation 都定义了一些默认的mode和一些常用的mode，代码中你可以通过字符串来区别这些mode，你可以定义自定义的mode，仅仅通过指定简单的字符串来标记这些自定义的mode。尽管可以随意的对 mode 名字进行复制，但是这些 mode 的内容却不行。你必须确保你添加到得任何你创建的 mode 中的一个或多个input sources, timers, 或者 run-loop observer都是有用的。</p>

<p>你使用 modes 并通过你的 run loop 特定的扫描中过滤掉干扰的事件。大多数情况下，你都会将你的 run loop 运行在系统默认的 mode 中。模态面板可能会运行在“ modal ” mode 中。当处于这种 mode 下，只有和 source 关联的模态面板才可以发送事件到线程中去。对于子线程来说，你可能会使用自定义 modes 去防止优先级抵的 source 在时间要求严格的操作中发送事件。</br>
<code>
Note: modes 的区别取决于 event（事件） 的 source ，不是 event 的类型。比如，你可能不会用 mode 去仅仅匹配一个鼠标点击事件或者键盘点击事件。 你可能会用 mode 去监听一组不同的端口。暂停 timer ，或者改变当前监视的 source ，然后，run loop observer 会立即开始监视。
</code>
</br>
列表3-1列出了 Cocoa 和 Core Foundation 框架中你可以使用的具有官方文档描述的一些标准的 mode，列名称列出了你在代码中需要指定 mode 时需要使用的实际常量。</p>

<h4><strong>Table 3-1</strong> <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW18">预定义的 run loop modes</a></h4>

<!--
| Mode | Name |Description|
| :------ | :------ | :------ |
| Default | [NSDefaultRunLoopMode](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode) (Cocoa)</br>[kCFRunLoopDefaultMode](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopDefaultMode) (Core Foundation) | Default Mode 是用的最多的 mode 操作。在大多数情况下，你应该使用此模式启动 Run Loop 和配置您的 input source。 |
|Connection|`NSConnectionReplyMode`(Cocoa)|Cocoa 使用这个 mode 来 `NSConnection` 对象共同监视 replies （回复响应），你一般不需要自己使用该 mode |
|Modal|`NSModalPanelRunLoopMode`(Cocoa)|Cocoa 使用这个 mode 来标记确认用于 modal panel（面板、控制器）的事件|
|Event tracking|`NSEventTrackingRunLoopMode`(Cocoa)|Cocoa 使用这个 mode 来约束鼠标拖动循环和其他类型的用户界面跟踪循环的输入事件|
|Common modes |[NSRunLoopCommonModes](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSRunLoopCommonModes)(Cocoa)</br>[kCFRunLoopCommonModes](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopCommonModes) (Core Foundation)|这是一个 common mode 的可配置组，用该 mode 关联的某个 input source 同时也被组中的这些 mode 所关联。对于 Cocoa 的应用，这一套包括 default modal， 和 默认的 event tracking 这些 mode。Core Foundation 只包括开始的 default mode。你可以使用[CFRunLoopAddCommonMode](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddCommonMode) function（函数）来添加自定义的 mode 到 mode 组中。|-->




<!--内嵌官方HTML-->


<hr />

<div class="tableholder"><table class="graybox" border="0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number"><!--Table 3-1--></strong>&nbsp;&nbsp;<!--Predefined run loop modes--></br></br></caption><tbody><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Mode</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Name</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr>
<tr><td scope="row"><p>Default</p></td><td><p><code><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoo_4&quot;;return this.s_oc?this.s_oc(e):true">NSDefaultRunLoopMode</a></code> (Cocoa)</p><p><code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopDefaultMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_2&quot;;return this.s_oc?this.s_oc(e):true">kCFRunLoopDefaultMode</a></code> (Core Foundation)</p></td><td><p> Default Mode 是用的最多的 mode 操作。在大多数情况下，你应该使用此模式启动 Run Loop 和配置您的 input source。 </p></td></tr><tr><td scope="row"><p>Connection</p></td><td><p><code><!--a target="_self" -->NSConnectionReplyMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 和<code><!--a target="_self" -->NSConnection<!--/a--></code>  对象共同监视 replies （回复响应），你一般不需要自己使用该 mode 
</p></td></tr><tr><td scope="row"><p>Modal</p></td><td><p><code><!--a target="_self" -->NSModalPanelRunLoopMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 来标记确认用于 modal panel（面板、控制器）的事件</p></td></tr><tr><td scope="row"><p>Event tracking</p></td><td><p><code><!--a target="_self" -->NSEventTrackingRunLoopMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 来约束鼠标拖动循环和其他类型的用户界面跟踪循环的输入事件 </p></td></tr><tr><td scope="row"><p>Common modes</p></td><td><p><code><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSRunLoopCommonModes" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoo_5&quot;;return this.s_oc?this.s_oc(e):true">NSRunLoopCommonModes</a></code> (Cocoa)</p><p><code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopCommonModes" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_3&quot;;return this.s_oc?this.s_oc(e):true">kCFRunLoopCommonModes</a></code> (Core Foundation)</p></td><td><p>这是一个 common mode 的可配置组，用 mode 关联的某个 input source 同时也被组中的这些 mode 所关联。对于 Cocoa 的应用，这一套包括 default modal， 和 默认的 event tracking 这些 mode。Core Foundation 只包括 开始的 default mode。你可以使用 <code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddCommonMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_4&quot;;return this.s_oc?this.s_oc(e):true">CFRunLoopAddCommonMode</a></code> function 来添加自定义的 mode 到 mode 组中。</p></td></tr></tbody></table></div>


<hr />

<!--内嵌官方HTML-->


<h3>Input Sources</h3>

<p>input source 异步传递事件到你的线程中。event 的source 取决于 input source 的类型，通常是两个类型中的一个。<code>基于 port 的 input source</code> 监视着你的应用中的 Mach Port 。<code>自定义的 input source</code> 监视着你的自定义的事件 source 。至于你的run loop 来讲，他不应该在是否是基于 port 的 input source 还是 自定义 input source 出现问题。系统通常会实现这两种全部允许程序员自己使用类型的 input source 。这两种 source 之间唯一的不同在于它们是如何被发送信号的。基于 port 的 source 可以通过 kernel 内核接收发送的信号，而自定义的 source 必须手动从另一个线程发送信号过来。</p>

<p>当你创建一个 input source 时，你可以给它分配一个或多个你的 run loop 的 mode 。受 mode 影响的 input source 会在任何给定的时刻受到监视，在大多数情况下，你的 run loop 会运行在 default mode 下，但是你也可以自己指派自定义的mode给它。如果一个 input source 没有处于当前受监视的 mode 下，那么任何它产生的事件都会被挂起，除非你的 run loop 在正确的 mode 下运行（就是让你的 run loop 以你需要监视的 input source 所属的 mode 开始运行，这样 run loop 才能监视到你的 input source 产生的事件）。</p>

<p>下面介绍一些 input source 。。。</p>

<h4>基于 port 的 source</h4>

<p>Cocoa 和 Core Foundation 框架都提供了内置的支持&ndash;使用 port 相关的对象和函数来创建基于 port 的input source。例如，在 Cocoa 中，你根本不用自己直接创建一个 input source，你只需要创建一个 port 对象，并使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSPort_Class/index.html#//apple_ref/occ/cl/NSPort">NSPort</a> 的方法去将 port 添加到 run loop 中去。port 对象会为你处理好创建和配置一个你需要的 input source 这些底层的事情。</p>

<p>在 Core Foundation 中， 你必须手动的两者都创建，其中包括 port 和 它的 run loop source ，在两种情况下， 你可以使用 port 不透明类型的 (<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMachPortRef/index.html#//apple_ref/c/tdef/CFMachPortRef">CFMachPortRef</a>, <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessagePortRef/index.html#//apple_ref/c/tdef/CFMessagePortRef">CFMessagePortRef</a>, or <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/tdef/CFSocketRef">CFSocketRef</a>) 相关的函数来创建合适的对象（you use the functions associated with the port opaque type (CFMachPortRef, CFMessagePortRef, or CFSocketRef) to create the appropriate objects）。</p>

<p>如何创建和配置自定义的基于 port 的源，可以参照<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281">创建一个基于 port 的 input source</a>
</br>
</br></p>

<h4>自定义 input source</h4>

<p>为了自定义一个 input source，你必须使用 Core Foundation 框架中 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/c/tdef/CFRunLoopSourceRef">CFRunLoopSourceRef</a>的不透明类型相关联的函数。你可以使用多个回调函数来配置你的自定义 input source ，Core Foundation 框架会配置你的  source 在不同的点去调用这些函数，处理将要发生的事件，并在 source 被移出 run loop 的时候销毁 source。</p>

<p>除了定义在事件到来时自定义 source 的行为，你还必须定义事件传递机制。source 的这部分运行在一个单独的线程中，并且负责 当数据已经准备好去被处理的时候，这部分会去提供一个拥有数据的 input source，并且发信号给 input source。这个事件传递机制取决于你，但是也不用过于复杂。</p>

<p>有关如何创建一个自定义 input source 的例子，可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3">定义一个自定义 input source</a>， 关于自定义 input source 的详细信息， 可以参考 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/doc/uid/20001443">CFRunLoopSourceReference</a></p>

<h3>Run Loop 的时间执行次序</h3>

<p>每一次你运行 run loop 时，你的线程的 run loop 都会处理未完成的事件，并且为已经注册的任何观察者生成通知信息。下面是它执行的具体步骤：</p>

<ol>
<li>通知观察者 runloop 已经进入。</li>
<li>通知观察者 任何就绪的 timer 即将触发。</li>
<li>通知观察者 任何 不是基于端口的 input source （source0）即将触发</li>
<li>触发任何不是基于端口的并且准备就绪的 input source。</li>
<li>假如存在已经准备好的基于端口的 input source （source1），将会等待被触发。并立即开始处理事件。跳转至步骤 9 。</li>
<li>通知观察者 线程即将睡眠。</li>
<li>设置让线程在符合如下条件之一时从睡眠状态唤醒：

<ul>
<li>一个基于端口的 input source（source1）产生的事件到来。</li>
<li>timer 触发了。</li>
<li>超出 runloop 预定的时间。</li>
<li>run loop 明确唤醒</li>
</ul>
</li>
<li>通知观察者，线程刚刚唤醒。</li>
<li>处理剩余的事件：

<ul>
<li>  如果一个用户定义的 timer 触发，处理 timer 的事件并且重启 ru loop ，跳转值步骤 2 。</li>
<li>如果一个 input source 触发，传递这个事件。</li>
<li>run loop 已经明确地被唤醒但是还没有超时。重启 run loop，并且跳转至 第二步。</li>
</ul>
</li>
<li>通知观察者，run loop 已经退出。
因为 timer 和 input source 发出的 observer 通知是在这些事件确实是发生时被发送的，那么在事件发生的时间和 observer 收到的通知的时间会存在时间间隙。如果对事件发生时间的准确性要求非常严格，那么你需要采取 <code>睡眠</code> 和 <code>唤醒睡眠</code> 的通知方式来帮助你纠正事件实际发生的时间。</li>
</ol>


<p>由于定时器等周期性事件是在 run loop 运行的时候发送的，需要避免在发送这些事件时被打断。典型的例子比如：只要进入运行循环，并且反复实时地从应用中请求事件来实现对鼠标跟踪的常规动作。由于你的代码是直接抓取事件的，而不是像平时一样让应用分发这些事件的，所以 timer 是不能被触发的，除非鼠标追踪程序退出并返回到应用程序控制。</p>

<p>一个 run loop 可以使用 run loop 对象显示唤醒，其他的事件可能也会引起 run loop 的唤醒。比如，添加另一个 <code>不是基于端口的 input source</code>（source1） 唤醒 run loop 从而使 input source 可以被立即处理（相比于一直处于等待状态直到其他时间发生才唤醒）。</p>

<h3>在什么时候适合使用 RunLoop ？</h3>

<p><strong><code>唯一需要你显示的使用 run loop 的时候是：当你为你的应用创建了子线程的时候。</code></strong>在你的应用中，主线程的 run loop 是基础设施中至关重要的一部分。所以，app 的框架都会提供运行主线程 loop 的代码并且自动开启 loop。iOS中<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/index.html#//apple_ref/occ/cl/UIApplication">UIApplication</a>（或者OSX中<code>NSApplication</code>）的<code>run</code>方法会开启一个应用中的主 loop 作为应用程序启动步骤的一部分。如果你使用 Xcode 的项目模板来创建你的应用，你完全不用自已去显示的调用这些常规方法。</p>

<p>对子线程来讲，你需要决定是否一个 run loop 对它来说是必要的，如果是，需要你自己配置并且启动它。你并不需要在任何情况下都开启线程的 run loop。比如：你使用线程去执行一些长期的并且预先决定的任务的时候，你可能需要避免开启 run loop 。Run loop 通常服务于一些需要你和线程之间互动性更强的特殊场景。比如，你需要在以下这些场景中开启你的 run loop：</p>

<ul>
<li>使用 port 或者自定义 input source 来和其他线程进行通信。</li>
<li>在线程中使用 timer 。</li>
<li>在 Cocoa 的应用中使用任何与 <code>performSelector…</code>相关的方法。</li>
<li>让你的线程继续执行周期性的任务。</li>
</ul>


<p>如果你选择使用 run loop，配置和建立它是非常简单的。如同所有的多线程编程一样，你需要有计划的在合适的情况下退出子线程。让它（run loop）更好的退出而不是迫使它终止永远都是更好的更干净的结束线程的方法。关于如何配置并且退出的方法将在<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5">使用Run Loop对象</a>中向大家展示。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（三）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(3)/"/>
    <updated>2016-01-07T11:54:24+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(3)</id>
    <content type="html"><![CDATA[<h2>苹果用 RunLoop 实现的功能</h2>

<p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>

<pre><code class="objc">CFRunLoop {
    current mode = kCFRunLoopDefaultMode
    common modes = {
        UITrackingRunLoopMode
        kCFRunLoopDefaultMode
    }

    common mode items = {

        // source0 (manual)
        CFRunLoopSource {order =-1, {
            callout = _UIApplicationHandleEventQueue}}
        CFRunLoopSource {order =-1, {
            callout = PurpleEventSignalCallback }}
        CFRunLoopSource {order = 0, {
            callout = FBSSerialQueueRunLoopSourceHandler}}

        // source1 (mach port)
        CFRunLoopSource {order = 0,  {port = 17923}}
        CFRunLoopSource {order = 0,  {port = 12039}}
        CFRunLoopSource {order = 0,  {port = 16647}}
        CFRunLoopSource {order =-1, {
            callout = PurpleEventCallback}}
        CFRunLoopSource {order = 0, {port = 2407,
            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}
        CFRunLoopSource {order = 0, {port = 1c03,
            callout = __IOHIDEventSystemClientAvailabilityCallback}}
        CFRunLoopSource {order = 0, {port = 1b03,
            callout = __IOHIDEventSystemClientQueueCallback}}
        CFRunLoopSource {order = 1, {port = 1903,
            callout = __IOMIGMachPortPortCallback}}

        // Ovserver
        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry
            callout = _wrapRunLoopWithAutoreleasePoolHandler}
        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting
            callout = _UIGestureRecognizerUpdateObserver}
        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit
            callout = _afterCACommitHandler}
        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit
            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit
            callout = _wrapRunLoopWithAutoreleasePoolHandler}

        // Timer
        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,
            next fire date = 453098071 (-4421.76019 @ 96223387169499),
            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}
    },

    modes ＝ {
        CFRunLoopMode  {
            sources0 =  { /* same as 'common mode items' */ },
            sources1 =  { /* same as 'common mode items' */ },
            observers = { /* same as 'common mode items' */ },
            timers =    { /* same as 'common mode items' */ },
        },

        CFRunLoopMode  {
            sources0 =  { /* same as 'common mode items' */ },
            sources1 =  { /* same as 'common mode items' */ },
            observers = { /* same as 'common mode items' */ },
            timers =    { /* same as 'common mode items' */ },
        },

        CFRunLoopMode  {
            sources0 = {
                CFRunLoopSource {order = 0, {
                    callout = FBSSerialQueueRunLoopSourceHandler}}
            },
            sources1 = (null),
            observers = {
                CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000,
                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
            )},
            timers = (null),
        },

        CFRunLoopMode  {
            sources0 = {
                CFRunLoopSource {order = -1, {
                    callout = PurpleEventSignalCallback}}
            },
            sources1 = {
                CFRunLoopSource {order = -1, {
                    callout = PurpleEventCallback}}
            },
            observers = (null),
            timers = (null),
        },

        CFRunLoopMode  {
            sources0 = (null),
            sources1 = (null),
            observers = (null),
            timers = (null),
        }
    }
}
</code></pre>

<p>可以看到，系统默认注册了5个Mode:</p>

<!--more-->


<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。
4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。
5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>


<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>

<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 1. 通知Observers，即将进入RunLoop</span>
</span><span class='line'>    <span class="c1">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="k">strong</span><span class="o">&gt;</span><span class="n">CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</span><span class="o">&lt;/</span><span class="k">strong</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kCFRunLoopEntry</span><span class="p">);</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="c1">/// 2. 通知 Observers: 即将触发 Timer 回调。</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeTimers</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeSources</span><span class="p">);</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 4. 触发 Source0 (非基于port的) 回调。</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><span class="p">(</span><span class="n">source0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 6. 通知Observers，即将进入休眠</span>
</span><span class='line'>    <span class="c1">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeWaiting</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 7. sleep to wait msg.</span>
</span><span class='line'>    <span class="n">mach_msg</span><span class="p">()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">mach_msg_trap</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 8. 通知Observers，线程被唤醒</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopAfterWaiting</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 9. 如果是被Timer唤醒的，回调Timer</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="p">(</span><span class="n">dispatched_block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><span class="p">(</span><span class="n">source1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">}</span> <span class="k">while</span> <span class="p">(...);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// 10. 通知Observers，即将退出RunLoop</span>
</span><span class='line'><span class="c1">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span>
</span><span class='line'><span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopExit</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h3>AutoreleasePool</h3>

<p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>

<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>

<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>

<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>

<h3>事件响应</h3>

<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>

<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>

<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>

<h3>手势识别</h3>

<p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>

<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>

<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>

<h3>界面更新</h3>

<p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>

<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：
_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>

<p>这个函数内部的调用栈大概是这样的：</p>

<pre><code class="objc">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()
    QuartzCore:CA::Transaction::observer_callback:
        CA::Transaction::commit();
            CA::Context::commit_transaction();
                CA::Layer::layout_and_display_if_needed();
                    CA::Layer::layout_if_needed();
                        [CALayer layoutSublayers];
                            [UIView layoutSubviews];
                    CA::Layer::display_if_needed();
                        [CALayer display];
                            [UIView drawRect];
</code></pre>

<h3>定时器</h3>

<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>

<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>

<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>

<h3>PerformSelector</h3>

<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>

<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>

<h3>关于GCD</h3>

<p>实际上 RunLoop 底层也会用到 GCD 的东西。同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>

<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>

<h3>关于网络请求</h3>

<p>iOS 中，关于网络请求的接口自下至上有如下几层:
<code>objc
CFSocket
CFNetwork       -&gt;ASIHttpRequest
NSURLConnection -&gt;AFNetworking
NSURLSession    -&gt;AFNetworking2, Alamofire
</code>
• CFSocket 是最底层的接口，只负责 socket 通信。
• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。
• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。
• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</p>

<p>下面主要介绍下 NSURLConnection 的工作过程。</p>

<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>

<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_network.png?raw=true" alt="NSURLConnection" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>

<h2>RunLoop 的实际应用举例</h2>

<h3>AFNetworking</h3>

<p><a href="https://github.com/AFNetworking/AFNetworking/blob/2.6.3/AFNetworking/AFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">networkRequestThreadEntryPoint:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">__unused</span> <span class="n">object</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]</span> <span class="nl">setName</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">AFNetworking</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
</span><span class='line'>        <span class="bp">NSRunLoop</span> <span class="o">*</span><span class="n">runLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="nl">addPort</span><span class="p">:[</span><span class="bp">NSMachPort</span> <span class="n">port</span><span class="p">]</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="n">run</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">NSThread</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">networkRequestThread</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="bp">NSThread</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">networkRequestThread</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">oncePredicate</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">oncePredicate</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">networkRequestThread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkRequestThreadEntryPoint</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">networkRequestThread</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">networkRequestThread</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</li>
</ul>


<pre><code class="objc">- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
</code></pre>

<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>

<h3>AsyncDisplayKit</h3>

<p><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>

<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>

<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。
绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。
UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>

<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>

<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>

<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。
具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>

<h4>特别致谢：</h4>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<h4>参考文章</h4>

<p>深入理解RunLoop(ibireme)：</p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p>iPhoneDevWiki :</p>

<p><a href="http://iphonedevwiki.net/index.php/CFRunLoop">iphonedevwiki.net/index.php/CFRunLoop</a>
<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">iphonedevwiki.net/index.php/IOHIDFamily</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（二）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(er-)/"/>
    <updated>2016-01-07T10:38:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(er-)</id>
    <content type="html"><![CDATA[<h2>RunLoop 的内部逻辑</h2>

<p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，RunLoop 内部的逻辑大致如下:
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_1.png?raw=true" alt="内部逻辑" /></p>

<p>内部代码整理为：</p>

<!--more-->


<pre><code class="objc">/// 用DefaultMode启动
void CFRunLoopRun(void) {
    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
}

/// 用指定的Mode启动，允许设置RunLoop超时时间
int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {
    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}

/// RunLoop的实现
int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {

    /// 首先根据modeName找到对应mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);
    /// 如果mode里没有source/timer/observer, 直接返回。
    if (__CFRunLoopModeIsEmpty(currentMode)) return;

    /// 1. 通知 Observers: RunLoop 即将进入 loop。
    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);

    /// 内部函数，进入loop
    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {

        Boolean sourceHandledThisLoop = NO;
        int retVal = 0;
        do {

            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);
            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);

            /// 4. RunLoop 触发 Source0 (非port) 回调。
            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);

            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。
            if (__Source0DidDispatchPortLastTime) {
                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)
                if (hasMsg) goto handle_msg;
            }

            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。
            if (!sourceHandledThisLoop) {
                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
            }

            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。
            /// • 一个基于 port 的Source 的事件。
            /// • 一个 Timer 到时间了
            /// • RunLoop 自身的超时时间到了
            /// • 被其他什么调用者手动唤醒
            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) {
                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg
            }

            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);

            /// 收到消息，处理消息。
            handle_msg:

            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。
            if (msg_is_timer) {
                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())
            } 

            /// 9.2 如果有dispatch到main_queue的block，执行block。
            else if (msg_is_dispatch) {
                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            } 

            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件
            else {
                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
                if (sourceHandledThisLoop) {
                    mach_msg(reply, MACH_SEND_MSG, reply);
                }
            }

            /// 执行加入到Loop的block
            __CFRunLoopDoBlocks(runloop, currentMode);


            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
                /// 进入loop时参数说处理完事件就返回。
                retVal = kCFRunLoopRunHandledSource;
            } else if (timeout) {
                /// 超出传入参数标记的超时时间了
                retVal = kCFRunLoopRunTimedOut;
            } else if (__CFRunLoopIsStopped(runloop)) {
                /// 被外部调用者强制停止了
                retVal = kCFRunLoopRunStopped;
            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {
                /// source/timer/observer一个都没有了
                retVal = kCFRunLoopRunFinished;
            }

            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。
        } while (retVal == 0);
    }

    /// 10. 通知 Observers: RunLoop 即将退出。
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
}
</code></pre>

<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回</p>

<h2>RunLoop 的底层实现</h2>

<p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。</p>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_3.png?raw=true" alt="底层逻辑" /></p>

<p>苹果官方将整个系统大致划分为上述4个层次：
应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。
应用框架层即开发人员接触到的 Cocoa 等框架。
核心框架层包括各种核心框架、OpenGL 等内容。
Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/">opensource.apple.com</a> 里找到。</p>

<p>我们在深入看一下 Darwin 这个核心的架构
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_4.png?raw=true" alt="Darwin" />
其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。
XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。
BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。
IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>

<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为"对象"。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。"消息"是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>

<p>Mach 的消息定义是在 &lt;mach/message.h> 头文件的，很简单：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">mach_msg_header_t</span> <span class="n">header</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_body_t</span> <span class="n">body</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="kt">mach_msg_base_t</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">mach_msg_bits_t</span> <span class="n">msgh_bits</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_size_t</span> <span class="n">msgh_size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_t</span> <span class="n">msgh_remote_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_t</span> <span class="n">msgh_local_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_name_t</span> <span class="n">msgh_voucher_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_id_t</span> <span class="n">msgh_id</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="kt">mach_msg_header_t</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">一条</span> <span class="n">Mach</span> <span class="err">消息实际上就是一个二进制数据包</span> <span class="p">(</span><span class="n">BLOB</span><span class="p">)</span><span class="err">，其头部定义了当前端口</span> <span class="n">local_port</span> <span class="err">和目标端口</span> <span class="n">remote_port</span><span class="err">，</span>
</span><span class='line'><span class="err">发送和接受消息是通过同一个</span> <span class="n">API</span> <span class="err">进行的，其</span> <span class="n">option</span> <span class="err">标记了消息传递的方向：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">objc</span>
</span><span class='line'><span class="kt">mach_msg_return_t</span> <span class="n">mach_msg</span><span class="p">(</span>
</span><span class='line'>            <span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_msg_option_t</span> <span class="n">option</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_msg_size_t</span> <span class="n">send_size</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_msg_size_t</span> <span class="n">rcv_size</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_port_name_t</span> <span class="n">rcv_name</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_msg_timeout_t</span> <span class="n">timeout</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_port_name_t</span> <span class="n">notify</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>
为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_5.png?raw=true" alt="Darwin" />
这些概念可以参考维基百科:<a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing">Trap_(computing)</a>)</p>

<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>

<p>关于具体的如何利用 mach port 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/">NSHipster</a> 这一篇文章，或者<a href="http://segmentfault.com/a/1190000002400329">这里</a>的中文翻译 。</p>

<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://history.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>

<h4>特别致谢：</h4>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p><strong>参考文章：</strong></p>

<p>深入理解RunLoop(ibireme)：</p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p>Apple Document：
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html</a></p>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">Apple&ndash;RunLoopManagement文档</a></p>

<p><a href="http://opensource.apple.com/">opensource.apple.com</a></p>

<p>维基百科：</p>

<p><a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、
<a href="http://en.wikipedia.org/wiki/Trap_(computing">Trap_(computing)</a>)</p>

<p>NSHipster：</p>

<p><a href="http://nshipster.com/inter-process-communication/">inter-process-
communication</a> <a href="http://segmentfault.com/a/1190000002400329">inter-process-communication中文</a></p>

<p><a href="http://history.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（一）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/06/runloopshen-du-tan-jiu/"/>
    <updated>2016-01-06T18:15:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/06/runloopshen-du-tan-jiu</id>
    <content type="html"><![CDATA[<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：
<code>swift
function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code>
这种模型通常被称作 <a href="https://en.wikipedia.org/wiki/Event_loop">Event Loop</a>。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>

<!--more-->


<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 &ldquo;接受消息->等待->处理&rdquo; 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>

<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。
CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>

<p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c">开源</a>的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz">http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz</a> 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span>
</span><span class='line'><span class="k">static</span> <span class="n">CFMutableDictionaryRef</span> <span class="n">loopsDic</span><span class="p">;</span>
</span><span class='line'><span class="c1">/// 访问 loopsDic 时的锁</span>
</span><span class='line'><span class="k">static</span> <span class="n">CFSpinLock_t</span> <span class="n">loopsLock</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">/// 获取一个 pthread 对应的 RunLoop。</span>
</span><span class='line'><span class="n">CFRunLoopRef</span> <span class="n">_CFRunLoopGet</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">OSSpinLockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">loopsLock</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loopsDic</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span>
</span><span class='line'>    <span class="n">loopsDic</span> <span class="o">=</span> <span class="n">CFDictionaryCreateMutable</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">mainLoop</span> <span class="o">=</span> <span class="n">_CFRunLoopCreate</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CFDictionarySetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="n">pthread_main_thread_np</span><span class="p">(),</span> <span class="n">mainLoop</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// 直接从 Dictionary 里获取。</span>
</span><span class='line'><span class="n">CFRunLoopRef</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">CFDictionaryGetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="kr">thread</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 取不到时，创建一个</span>
</span><span class='line'>    <span class="n">loop</span> <span class="o">=</span> <span class="n">_CFRunLoopCreate</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CFDictionarySetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">loop</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span>
</span><span class='line'>    <span class="n">_CFSetTSD</span><span class="p">(...,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="n">__CFFinalizeRunLoop</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">OSSpinLockUnLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="n">loop</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">CFRunLoopRef</span> <span class="n">CFRunLoopGetMain</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_CFRunLoopGet</span><span class="p">(</span><span class="n">pthread_main_thread_np</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">CFRunLoopRef</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_CFRunLoopGet</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
综上：线程和RunLoop之间是一一对应的，并且关系是保存在一个全局的字典中的，并且线程刚创建时是没有RunLoop的，如果你不获取它，他一直都不会有，RunLoop的创建发生在第一次获取的时候，RunLoop的销毁发生在线程结束时。并且只能在线程内部获取runloop（主线程除外）。</p>

<h1>RunLoop 对外的接口</h1>

<p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>

<pre><code class="objc">CFRunLoopRef
CFRunLoopModeRef
CFRunLoopSourceRef
CFRunLoopTimerRef
CFRunLoopObserverRef
</code></pre>

<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_0.png?raw=true" alt="image" />
一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>

<p><strong>CFRunLoopSourceRef</strong>是事件产生的地方。Source有两个版本：Source0 和 Source1。
• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。
• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopSourceRef.png?raw=true" alt="image" /></p>

<p><strong>CFRunLoopTimerRef</strong>是基于时间的触发器，他和NSTimer是toll-free bridged的，可以混用。其包含一个时间长度和一个回调（函数指针）。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopTimeRef.png?raw=true" alt="image" /></p>

<p><strong>CFRunLoopObserverRef</strong>是观察者，每个Observer都包含了一个回调（函数指针），当RunLoop的状态发生变法时，观察者就能通过回调接受这个变化。可以观测的时间点有以下几个：
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopObserverRef.png?raw=true" alt="image" />
<code>objc
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
</code></p>

<h2>RunLoop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下：
<code>objc
struct __CFRunLoopMode {
    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
    CFMutableSetRef _sources0;    // Set
    CFMutableSetRef _sources1;    // Set
    CFMutableArrayRef _observers; // Array
    CFMutableArrayRef _timers;    // Array
    ...
};
struct __CFRunLoop {
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
};
</code>
这里有个概念叫：“CommonModes”一个Mode可以将自己标记为“Common”属性（通过将其ModeName添加到RunLoop得“commonModes”中）。每当RnuLoop的内容发生变化时，RunLoop的都会自动将_commonModeItems里的Source/Timer/Observer同步到具有“Common”标记的所有的Mode。
应用举例：主线程 RunLoop 默认会预制两个 Mode ：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个Mode都已经被标记为“Common”属性。DefaultMode是App平时所处的状态，TrackingRunLoop是为了追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调。此时滑动TableView时，RunLoop会将mode切换为TrackingRunLoopMode，这时Timer就不会被回调，也不会影响滑动的操作了。具体用例类似于在tableView中加入滚动广告栏，当你在操作tableView时会回调自动滚动栏的Timer，造成滚动栏的滑动出现卡顿。</p>

<p>有时你需要一个Timer，在两个Mode中都能得到回调，一种办法就是讲这个Timer加入两个Mode。还有一种就是讲Timer加入到顶层的RunLoop的“commonModeItems”中。“commonModeItems”被RunLoop自动更新到所有具有“Common”属性的Mode里去。</p>

<p>CFRunLoop对外暴漏的管理Mode的接口只有下面两个：
<code>objc
CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName); // 给RunLoop添加到CommonMode中
CFRunLoopRunInMode(CFStringRef modeName, ...); // 返回当前线程中指定mode的CFRunLoop对象
</code>
Mode暴露的管理mode item的接口有下面几个
<code>objc
CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);// 添加一个CFRunLoopSource对象到一个run loop mode中（如果添加的Source是source0的话，这个方法将会调用 schedule 回调在source的上下文结构（context structure）的指定方法）。一个runloop source 可以同时被注册到多个 runloop 和 runloop modes 中。当source被发出信号，无论哪一个被注册的 runloop 都会开始检测第一个发出信号的 source 。 如过rl的mode中已经包含source时，这个方法将不会做任何事。
CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName); // 添加CFRunLoopObserver对象到一个run loop mode中去。 讨论：一个 runloop 观察者只能被同时注册在一个 runloop 中，尽管它可以被通过他的tunloop添加到多个runloop modes中。 如果rl已经在 mode中 包含 obsever 中，这个方法将不会做任何事。
CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName); // 添加CFRunLoopTimer 对象到一个runloop mode中 讨论：一个runloop timer 在同一时刻只能注册在一个run loop，尽管它可以被通过他的tunloop添加到多个runloop modes中。 如果rl已经在 mode中 包含 obsever 中，这个方法将不会做任何事
CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName); // 从run loop mode 移除 Observer 对象，如果 rl 没有包含参数中的Observer，则该函数不做任何处理
CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); // 从run loop mode 移除 timer 对象，如果 rl 没有包含参数中的timer，则该函数不做任何处理
</code>
以上接口可以看出，只能通过mode name操作内部mode，当你传入一个新的mode name但runloop内部没有对应的mode时，runloop会自动帮你创建对应的CFRunloopModeRef。并且官方文档明确指出，对于runloop来说，其内部的mode只能增加不能删除。</p>

<p>苹果官方公开的内部mode有两个：CFRunLoopDefaultMode（NSDefaultRunLoopMode）和UITrackingRunLoopMode，你可以用这两个 Mode Name来操作对应的 Mode。
同时苹果还提出了一个操作Common标记的字符串：kCFRunLoopCommonModes（NSRunLoopCommonModes），你可以用这个字符串来操作Common Items，或标记一个Mode为“Common”。使用时注意区分该字符串与其他mode name。</p>

<h4>特别致谢：</h4>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p><strong>参考文章：</strong></p>

<p>深入理解RunLoop:</p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/2015/05/18/runloop/#more-41710</a></p>

<p>Apple Document:</p>

<p><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[宏定义的高级用法]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/definede-gao-ji-yong-fa/"/>
    <updated>2016-01-04T11:44:51+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/definede-gao-ji-yong-fa</id>
    <content type="html"><![CDATA[<p>1、# （stringizing）字符串化操作符。其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。
如：</p>

<pre><code class="c">#define example(instr) printf("the input string is:\t%s\n",#instr)
#define example1(instr) #instr
</code></pre>

<p>当使用该宏定义时：</p>

<!--more-->


<pre><code class="c">example(abc)；
</code></pre>

<p> 在编译时将会展开成：</p>

<pre><code>printf("the input string is:\t%s\n","abc");
string str=example1(abc);
</code></pre>

<p>将会展成：</p>

<p><code>string str="abc";</code></p>

<p>注意：
对空格的处理
a。忽略传入参数名前面和后面的空格。</p>

<p>   如：<code>str=example1(   abc )</code>； 将会被扩展成<code>str="abc"</code>；</p>

<p>b.当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串中只以一个空格连接，忽略其中多余一个的空格。</p>

<p>   如：<code>str=exapme( abc    def)</code>; 将会被扩展成 <code>str="abc def"</code>；</p>

<p>2、## （token-pasting）符号连接操作符(让参数值转换为参数名)
宏定义中：参数名，即为形参，如#define sum(a,b) (a+b)；中a和b均为某一参数的代表符号，即形式参数。
而##的作用则是将宏定义的多个形参成一个实际参数名。</p>

<p>如：</p>

<p><code>#define exampleNum(n) num##n
</code></p>

<p><code>int num9=9</code>;</p>

<p>使用：</p>

<p><code>int num=exampleNum(9)</code>;</p>

<p>将会扩展成 <code>int num=num9</code>;</p>

<p>注意：</p>

<p>1.当用##连接形参时，##前后的空格可有可无。</p>

<p>如：<code>#define exampleNum(n) num ## n</code>相当于 <code>#define exampleNum(n) num##n</code></p>

<p>2.连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义</p>

<p>// preprocessor_token_pasting.cpp</p>

<pre><code>#include 
#define paster( n ) printf_s( "token" #n " = %d", token##n )
int token9 = 9;
int main()
{
   paster(9);
}
</code></pre>

<p>运行结果：</p>

<p><code>token9 = 9</code></p>

<p>3、@# （charizing）字符化操作符。
只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。作用是将传的单字符参数名转换成字符，以一对单引用括起来。</p>

<p><code>#define makechar(x)  #@x
a = makechar(b);</code></p>

<p>展开后变成了：</p>

<p><code>a= 'b';</code></p>

<p>4、\ 行继续操作符
当定义的宏不能用一行表达完整时，可以用"\&ldquo;表示下一行继续此宏的定义。</p>

<p><a href="http://blog.csdn.net/hjmhz/article/details/8667185">更多高级用法&hellip;</a></p>

<p><a href="http://blog.chinaunix.net/uid-23254875-id-341055.html">转自http://blog.chinaunix.net/uid-23254875-id-341055.html</a></p>
]]></content>
  </entry>
  
</feed>
