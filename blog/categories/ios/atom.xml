<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | SuperYang`s Blog]]></title>
  <link href="http://yangchao0033.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yangchao0033.github.io/"/>
  <updated>2016-01-25T13:42:17+08:00</updated>
  <id>http://yangchao0033.github.io/</id>
  <author>
    <name><![CDATA[Super Yang]]></name>
    <email><![CDATA[757097678@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CocoaPod Version Update]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/18/cocoapod-version-update/"/>
    <updated>2016-01-18T15:58:44+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/18/cocoapod-version-update</id>
    <content type="html"><![CDATA[<h3>问题描述：</h3>

<p>使用 pod 安装第三方库时无法使用 <code>pod search</code> 搜索最新的版本</p>

<h3>定位问题：</h3>

<p>使用的 pod 版本过低</p>

<h3>方案：</h3>

<!--more-->


<p>升级pod版本
<code>
$ sudo gem update --system
$ gem sources --remove https://rubygems.org/
$ gem sources -a https://ruby.taobao.org/
$ sudo gem install cocoapods
$ pod setup
</code>
line 1: 为 <code>gem</code> 升级到最新版<br/>
line 2: 删除 <code>gem</code> 默认的源<br/>
line 3: 添加淘宝的源，为了解除天朝对gem的隔离（ps：<code>gem</code> 到底干了啥，这么苦大仇深？）<br/>
line 4: 安装 <code>CocoaPod</code> (会去新加的源去检查是否有新的内容，有则更新，保持你本地pod拥有最新的库信息)<br/>
line 5: <code>pod</code> 安装将利用刚才的配置更新本地镜像</p>

<h3>使用：</h3>

<p>继续使用 <code>pod search 库名</code>
例如： <code>pod search ReactiveCocoa</code></p>

<p>就能搜到最新的库版本了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（五）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/18/runloop-5/"/>
    <updated>2016-01-18T12:34:58+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/18/runloop-5</id>
    <content type="html"><![CDATA[<h2>使用 Run Loop 对象</h2>

<p>一个 run loop 对象提供了一些主要接口用于向你的 run loop 中添加 input source ，timers， 和run loop observer，并且运行它。每一条线程有且只有一个run loop 与他相关联。在 Cocoa 中，这个对象是 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 类的一个实例。在底层的应用中，它是指向 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/tdef/CFRunLoopRef">CFRunLoopRef</a> 这种不透明类型的一个指针。</p>

<h2>获取 Run Loop 对象</h2>

<p>你需要使用以下其中之一来获取当前线程的 Run Loop ：</p>

<!--more-->


<ul>
<li>在 Cocoa 中，使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 的类方法 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/clm/NSRunLoop/currentRunLoop">currentRunLoop</a> 去拿到一个 <code>NSRunLoop</code> 对象。</li>
<li>使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopGetCurrent">CFRunLoopGetCurrent</a> 函数。</li>
</ul>


<p>尽管这两种方法不是 <a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">toll-free bridged type</a>(在Foundation 和 Core Foundation 中拥有等价替换接口的能力的类型)的类型,但是如果你需要可以从 <code>NSRunLoop</code> 对象里拿到 CFRunLoopRef 这种<code>不透明类型</code>(苹果封装在内部的C语言类型)。<code>NSRunLoop</code> 类定义了 <code>getCFRunLoop</code> 方法用来返回一个可以传入到 Core Foundation 代码中的 <code>CFRunLoopRef</code> 类型的C语言指针对象（结构体指针）。这两种对象都可以来自于同一个 run loop，你可以根据你的需要来选择具体使用 <code>NSRunLoop</code> 和 <code>CFRunLoopRef</code> 这两种对象的哪一种。</p>

<h2>配置 Run Loop</h2>

<p>在你运行一个子线程的 run loop 之前，你必须向其添加至少一个 input source 或者 timer。如果 run loop 没有任何需要监视的 source， 它将会在你尝试运行它的时候立即退出。请参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7">配置RunLoop Sounce</a>（本文接下来的章节将有介绍）。</p>

<p>除了安装 source，你还可以 run loop observer 并且使用他们检测 runloop的处于不同执行阶段。为了安装 run loop observer ，你需要创建一个 CFRunLoopObserverRef 不透明类型的指针并使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddObserver">CFRunLoopAddObserver</a> 函数将 Observer 添加到你的 run loop 中去，Run Loop Observer 必须使用 Core Foundation 框架接口创建，在 Cocoa 应用中也一样。</p>

<p>表 3-1 展示了在线程 runloop 中，添加 run loop Observer 的主要代码流程。本例的目的旨在告诉你如何创建一个 run loop Observer， 所以代码只是简单设置了一个run loop Observer 用来监视 run loop 的所有活动 。基本的处理代码（没有展示）仅仅是日志输出 run loop 的各项活动行为 作为 timer 的事件回调。</p>

<p>表3-1 创建 runloop Observer
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">threadMain</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 应用使用垃圾回收，所以不需要 自动释放池 autorelease pool</span>
</span><span class='line'>    <span class="bp">NSRunLoop</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">myRunLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 创建一个 run loop observer 并且将他添加到当前 run loop 中去</span>
</span><span class='line'>    <span class="o">/&lt;/</span><span class="n">em</span><span class="o">&gt;!</span>
</span><span class='line'>     <span class="o">*</span>  <span class="p">@</span><span class="n">author</span> <span class="err">杨超</span><span class="p">,</span> <span class="mi">16</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">13</span> <span class="mi">15</span><span class="o">:</span><span class="mo">01</span><span class="o">:</span><span class="mi">45</span>
</span><span class='line'>     <span class="o">*</span>
</span><span class='line'>     <span class="o">*</span>  <span class="p">@</span><span class="n">brief</span> <span class="n">CFRunLoopObserverContext</span> <span class="err">用来配置</span> <span class="n">CFRunLoopObserver</span> <span class="err">对象行为的结构体</span>
</span><span class='line'>     <span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CFIndex</span> <span class="n">version</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">void</span> <span class="o">*</span>  <span class="n">info</span><span class="p">;</span>
</span><span class='line'>        <span class="k">const</span> <span class="kt">void</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="k">retain</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">info</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">void</span>    <span class="p">(</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="k">release</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">info</span><span class="p">);</span>
</span><span class='line'>        <span class="n">CFStringRef</span> <span class="p">(</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">copyDescription</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">info</span><span class="p">);</span>
</span><span class='line'>     <span class="p">}</span> <span class="n">CFRunLoopObserverContext</span><span class="p">;</span>
</span><span class='line'>     <span class="o">*</span>
</span><span class='line'>     <span class="o">*</span>  <span class="p">@</span><span class="n">param</span> <span class="n">version</span> <span class="err">结构体版本号，必须为</span><span class="mi">0</span>
</span><span class='line'>     <span class="o">*</span>  <span class="p">@</span><span class="n">param</span> <span class="n">info</span> <span class="err">一个程序预定义的任意指针，可以再</span> <span class="n">run</span> <span class="n">loop</span> <span class="n">Observer</span> <span class="err">创建时为其关联。这个指针将被传到所有</span> <span class="n">context</span> <span class="err">多定义的所有回调中。</span>
</span><span class='line'>     <span class="o">*</span>  <span class="p">@</span><span class="n">param</span> <span class="k">retain</span> <span class="err">程序定义</span> <span class="n">info</span> <span class="err">指针的内存保留（</span><span class="k">retain</span><span class="err">）回调</span><span class="p">,</span><span class="err">可以为</span> <span class="nb">NULL</span>
</span><span class='line'>     <span class="o">*</span>  <span class="p">@</span><span class="n">param</span> <span class="k">release</span> <span class="err">程序定义</span> <span class="n">info</span> <span class="err">指针的内存释放（</span><span class="k">release</span><span class="err">）回调，可以为</span> <span class="nb">NULL</span>
</span><span class='line'>     <span class="o">*</span>  <span class="p">@</span><span class="n">param</span> <span class="n">copyDescription</span> <span class="err">程序定于</span> <span class="n">info</span> <span class="err">指针的</span> <span class="k">copy</span> <span class="err">描述回调，可以为</span> <span class="nb">NULL</span>
</span><span class='line'>     <span class="o">*</span>
</span><span class='line'>     <span class="o">*</span>  <span class="p">@</span><span class="n">since</span>
</span><span class='line'>     <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'>    <span class="n">CFRunLoopObserverContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span> <span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="nb">self</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'>    <span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span> <span class="o">=</span> <span class="n">CFRunLoopObserverCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="n">kCFRunLoopAllActivities</span><span class="p">,</span> <span class="nb">YES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">myRunLoopObserverCallBack</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">context</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="n">observer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">cfLoop</span> <span class="o">=</span> <span class="p">[</span><span class="n">myRunLoop</span> <span class="n">getCFRunLoop</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CFRunLoopAddObserver</span><span class="p">(</span><span class="n">cfLoop</span><span class="p">,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">kCFRunLoopDefaultMode</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建并安排好 timer</span>
</span><span class='line'><span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">0.1</span> <span class="nl">target</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">doFireTimer</span><span class="p">)</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSInteger</span> <span class="n">loopCount</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 3秒后运行 run loop 实际效果是每三秒进入一次当前 while 循环</span>
</span><span class='line'>    <span class="p">[</span><span class="n">myRunLoop</span> <span class="nl">runUntilDate</span><span class="p">:[</span><span class="bp">NSDate</span> <span class="nl">dateWithTimeIntervalSinceNow</span><span class="p">:</span><span class="mi">3</span><span class="p">]];</span>
</span><span class='line'>    <span class="n">loopCount</span> <span class="o">--</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">loopCount</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">myRunLoopObserverCallBack</span><span class="p">(</span><span class="n">CFRunLoopObserverRef</span> <span class="n">observer</span><span class="p">,</span> <span class="n">CFRunLoopActivity</span> <span class="n">activity</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">observer</span><span class="err">正在回调\</span><span class="n">n</span><span class="o">%</span><span class="p">@</span><span class="o">&amp;</span><span class="n">mdash</span><span class="p">;</span><span class="o">-%</span><span class="n">tu</span><span class="o">&amp;</span><span class="n">mdash</span><span class="p">;</span><span class="o">-%</span><span class="p">@</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="n">observer</span><span class="p">,</span> <span class="n">activity</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">doFireTimer</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="err">计时器回调</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></li>
</ul>


<p>当为一个长期存活的现场配置 runloop 时，至少添加一个 input source 去接收消息。尽管你可以仅仅使用一个 关联的timer 就可以进入 run loop，一旦 timer 启动，通常都会被作废掉，这将会硬气 run loop 的退出。关联一个重复执行的 timer 定时器可以保持让 runloop 在很长的一段时期内得以运行，但是需要周期性的去启动定时器 timer 来唤醒你的线程，这是投票有效的另一种形式（这句莫名其妙，不懂是干吗的）。相比之下， input source 会等待事件的发生，并保持线程处于睡眠状态直到事件确实发生了。</p>

<h2>开动 run loop</h2>

<p>在应用中，只有在子线程中才是有必要开启 run loop 的，一个 run loop 必须至少有一个用来监视的 input source 。如果一个关联的都没有，run loop 将会立即退出。</p>

<p>下面有一些方法开启 run loop：
* 无条件的
* 通过一套时间限制
* 在一个特别的 mode 下</p>

<p>无条件的进入你的 run loop 是最简单的选项，但这种也是最不可取的。无条件地运行你的 run loop 将会使你的线程进入进入永久的循环中，这使你很难控制运行循环本身。你可以添加和移除 input source 和 timer，但是只有一种方式去停止 run loop，那就是将它杀死。同时也不存在在自定义 mode 中运行 run loop 的方法。</p>

<p>为了替代无条件的运行 run loop ，更好的办法是使用超时值来运行 runloop。当你使用超时值时，run loop 会一直运行直到在事件来临时 或者 分配的时间结束时。当你的事件到达时，系统会分配一个 handler 去处理它，并且之后 run loop 会退出。你可以用代码重启你的 run loop 以便处理下一个事件。如果不想继续使用刚才分配时间结束的原则，也可以简单的重启 runloop 或者使用这些时间去做任何你需要做的事。</p>

<p>除了使用超时值，你也可以使用指定的 mode 运行 run loop。mode 和超时值不会互相排斥，并且都可以用来启动一个线程。</p>

<p>表 3-2 展示了一个线程入口的常用的例行程序。示例代码的关键部分展示了一个 run loop 的基础架构。本质上，你将 input sources 和 timers 添加到你的 runloop 中，然后重复的调用其中一个例行程序来启动 run loop 。每一次例行程序返回时，你需要检查一下是否满足可能会退出线程的条件。示例使用了 Core Foundation 的框架的例行程序以便检查返回结果并且可以决定如何退出 runloop。如果你是用的是 Cocoa ，你也可以使用类似的方式通过 NSRunLoop 的方法去运行 runloop ，    并且不需要检查返回值。（使用 NSRunLoop 的方法的例子可以参考 表3-14.）</p>

<p>表 3-2 运行 runloop</p>

<pre><code class="objc">- (void)skeletionThreadMain {
    // 如果你的应用没有使用垃圾回收 请在这里添加 自动释放池（ps：这示例代码也太老了，谁还用垃圾回收啊）

    BOOL done = NO;

    // 给 runloop 添加 source 或timer，然后做一些其他的配置

    do {
        // 开启 runloop 并且被一个 source 被处理后要返回
        /** SInt32 32位有符号整数 */
        SInt32 result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);

        // 如果 source 已经显式的停止了 runloop ，或者根本不存在任何 source 或 timer，将会退出。
        if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished)) {
            done = YES;
            // 在这里检查任何其他符合退出的条件并且按需设置 done 变量的值。
        }
    } while (!done);

    // 在这里清除代码。确保释放任何之前创建的自动释放池。
}
</code></pre>

<p>可以递归开启 runloop，换句话说，你可以使用 input source 或者 timer 的例行程序来调用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopRun">CFRunLoopRun</a>,<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopRunInMode">CFRunLoopRunInMode</a>或者任何 NSRunLoop 的 runloop 启动方法。这样做你可以使用任何你想用的 mode 来运行一个 嵌套的 run loop ，包括 通过外层 run loop 使用的 mode 。</p>

<h3>退出 RunLoop</h3>

<p>有两种途径可以让 runloop 在处理事件之前退出：</p>

<ul>
<li>使用超时值配置 runloop 运行。</li>
<li>直接告诉 runloop 停止（ps：。。。这条太搞了）。</li>
</ul>


<p>使用超时值无疑是更偏爱的方法，如果你能管理它，指定一个超时值使 runloop 结束所有他的正常处理的任务， 包括在退出前向 runloop observer 发送通知。</p>

<p>使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopStop">CFRunLoopStop</a> 函数显示地停止 runloop，产生的结果和超时相似。runloop 会发送任何 runloop 提醒通知然后才退出。不同的是你可以将这项技术应用在你用无条件方式开启的 runloop 上。</p>

<p>尽管移除一个 runloop 的 input source 和 timer 可以造成 runloop 的退出，但这并不是一个可靠的方式来停止 runloop 。一些系统例行程序给 runloop 添加一些 input source 来处理必要的事件。你的代码可能无法看出这些 input source，你可能不能移除这些用来防止 runloop  退出的 source。</p>

<h3>线程安全 和 Run Loop 对象</h3>

<p>线程安全大多取决于你用来操作 runloop 的API。Core Foundation 函数 一般来说都是线程安全的，所以可以被任何线程调用。假如你正在执行一个修改 runloop 配置的操作，那么继续吧，对拥有 runloop 的线程来说这样做仍然是很好的作法。</p>

<p>Cocoa 的 <code>NSRunLoop</code> 类内部不像 Core Foundation 中的接口那样是线程安全的。如果你要使用 NSRunLoop 类去修改你的 runloop，你只能在 runloop 所在的线程中这样做。先其他线程中的 runloop 中添加 input source 或 timer 会引起你的程序崩溃或出现不可预知的异常。</p>

<h3>配置 run loop source</h3>

<p>接下来的章节将展示如何在 Cocoa 和 Core Foundation 中设置不同类型的 input source。</p>

<h4>定义一个自定义自定义 input source</h4>

<p>创建一个自定义的 input source 你需要实现以下这些条件：</p>

<ul>
<li>你想要你的 source 处理的信息</li>
<li>一段调度模块的例行程序让感兴趣的客户机了解如何连接你的 input source。</li>
<li>一段处理模块例行程序用来处理任何客户机发送的请求</li>
<li>一段取消模块的例行程序用来销毁你的 source</li>
</ul>


<p>因为你创建了一个自定义的 input source 来处理自定义的信息，所以实际上的配置会设计的非常灵活。调度模块，处理模块和取消模块的例行程序几乎都是你的自定义 input source 的关键例行程序。剩下的大多数 input source 行为都发生在这些例行处理程序之外。比如，由你来定义一个工具用来将数据传到你的 input source并且传递你的 input source 的数据到其他线程中去。</p>

<p>插图 3-2 展示了一个简单的自定义 input source 的配置。在本例中，应用程序主线程维持引用了input source ， input source 的缓冲模块，还有安装 input source 的 runloop。当主线程有一个任务向切换到工作子线程中去，他会发送一个命令，命令缓冲区以及启动任务所需的任何线程的信息（因为主线程和工作子线程的 input source 都有权限去访问命令缓冲区，访问必须同步）一旦命令发送了，主线程会发送信号给 input source 来唤醒工作子线程的 runloop。一旦受到唤醒的命令， runloop 会调用 input source 的处理程序 去处理命令缓存器中缓存的命令。</p>

<p>图 3-2 操作一个自定义 input source</p>

<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt="图 3-2" /></p>

<p>接下来的章节将会解释如何通过上图实现一个自定义 input source 并展示你需要实现的关键代码。</p>

<h3>定义 input source</h3>

<p>定义一个自定义 input source 需要使用 Core Foundation 的例行程序配置你的 runloop input source 并且 将它与你的 runloop 关联。尽管基础处理程序是基于 C-语言 函数的，但这不会阻止你使用 Objective-C 或者 C++ 去封装它为面向对象的代码。</p>

<p>插图3-2中介绍的 input source 使用一个 objective-C 对象去管理一个命令缓存器，并与 runloop 进行协调。列表3-3 展示了这个对象的定义。<code>RunLoopSource</code> 对象管理一个命令缓冲器，并且使用命令缓存器接受来自其他线程的消息。该表也展示了 <code>RunLoopContext</code> 对象的定义，该对象仅仅是一个容器，用来传递一个 <code>RunLoopSource</code> 对象和应用主线程的 runloop 引用。</p>

<p>表 3-3 自定义 input source 对象的定义
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">YCRunLoopSource</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopSourceRef</span> <span class="n">runLoopSource</span><span class="p">;</span>
</span><span class='line'>    <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">commands</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">init</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 添加&lt;/li&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">addToCurrentRunLoop</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 销毁&lt;/li&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">invalidate</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// 处理方法</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">sourceFired</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// 用来注册需要处理的命令的客户机接口</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">addCommand</span><span class="p">:(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="n">command</span> <span class="nl">withData</span><span class="p">:(</span><span class="kt">id</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fireAllCommandsOnRunLoop:</span><span class="p">(</span><span class="n">CFRunLoopSourceRef</span><span class="p">)</span><span class="nv">runloop</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// 这些是CFRunLoopRef 的回调函数</span>
</span><span class='line'><span class="o">/&lt;</span><span class="k">strong</span><span class="o">&gt;</span> <span class="err">调度函数</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="kt">void</span> <span class="n">RunLoopSourceScheduleRoutine</span><span class="p">(</span><span class="kt">void</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">r1</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span>
</span><span class='line'><span class="o">/&lt;/</span><span class="k">strong</span><span class="o">&gt;</span> <span class="err">处理函数</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="kt">void</span> <span class="n">RunLoopSourcePerformRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">info</span><span class="p">);</span>
</span><span class='line'><span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="err">取消函数</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="kt">void</span> <span class="n">RunLoopSourceCancelRoutine</span> <span class="p">(</span><span class="kt">void</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">info</span><span class="p">,</span> <span class="n">CFRunLoopRef</span> <span class="n">rl</span><span class="p">,</span> <span class="n">CFStringRef</span> <span class="n">mode</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">@end</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// RunLoopContext 是一个 在注册 input source 时使用的容器对象&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">@interface</span> <span class="nc">YCRunLoopContext</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span><span class="p">;</span>
</span><span class='line'>    <span class="n">YCRunLoopSource</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">source</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">/**</span> <span class="err">持有</span> <span class="n">runloop</span> <span class="err">和</span> <span class="n">source</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">CFRunLoopRef</span> <span class="n">runLoop</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">readonly</span><span class="p">)</span> <span class="n">YCRunLoopSource</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nl">initWithSource</span><span class="p">:(</span><span class="n">YCRunLoopSource</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="nl">andLoop</span><span class="p">:(</span><span class="n">CFRunLoopRef</span><span class="p">)</span><span class="n">loop</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>尽管 Objective-C 代码管理着 input source 的自定义数据。关联一个 input source 到一个具备 基于 C-语言 的回调函数的 runloop 。其中第一个函数是当你实际将 input source 添加到 runloop 中的时刻调用。流程将展示在 表 3-4 中。因为这个 input source 仅只有一个 客户机（主线程）。它使用调度者函数通过目标线程 application 的代理发送消息在目标线程注册自己。当 application 的代理和 input source 进行通信时 ,会使用 RunLoopContext 对象中的 <code>info</code> 信息来完成这个事。</p>

<p>表 3-4 调度 run loop source</p>

<pre><code class="objc">void RunLoopSourceScheduleRoutine(void *info, CFRunLoopRef r1, CFStringRef mode){
    YCRunLoopSource *obj = (__bridge YCRunLoopSource *)info;
    // 这里的 Appdelegate 是主线程的代理  
    AppDelegate *del = [AppDelegate sharedAppDelegate];

    // 上下文对象中持有source自己
    YCRunLoopContext *theContext = [[YCRunLoopContext alloc] initWithSource:obj andLoop:r1];
    // 通过代理去注册 Source 自己 
    [del performSelectorOnMainThread:@selector(registerSource:) withObject:theContext waitUntilDone:NO];

}
</code></pre>

<p>其中最重要的回调例行程序是当你的 input source 被信号激活时处理自定义数据的部分。表3-5中展示了与 <code>RunLoopSource</code> 对象关联的执行者回调例行程$序,这个函数仅仅转发用来 <code>sourceFired</code> 方法工作的请求，该请求用来处理任何 <code>command buffer</code> （命令缓冲区）中存在的命令。</p>

<p>表3-5 input source 中的执行者
<code>objc
void RunLoopSourcePerformRoutine (void *info)
{
    RunLoopSource*  obj = (RunLoopSource*)info;
    [obj sourceFired];
}
</code>
如果你使用 <code>CFRunLoopSourceInvalidate</code> 函数将 input source 从 runloop 重移除。系统会调用你的 input source 中的取消者例行程序。你可以利用这个例行程序去通知客户机你的 input source 不再可用并且他们应该移除任何自己的相关的引用。表3-6 展示了取消者例行回调程序通过 RunLoopSource 对象进行注册。这个函数发送另一个 RunLoopContext 对象给 application 代理。但是这让代理去移除 runloop surce 的相关引用。</p>

<p>表3-6 销毁一个 input source</p>

<pre><code class="objc">void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)
{
    RunLoopSource* obj = (RunLoopSource*)info;
    AppDelegate* del = [AppDelegate sharedAppDelegate];
    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];

    [del performSelectorOnMainThread:@selector(removeSource:)
                                withObject:theContext waitUntilDone:YES];
}
</code></pre>

<p><code>
笔记：应用代理方法  registerSource: 和 removeSource 方法在下面的章节 《协调 input source 的客户机》展示
</code></p>

<h3>为 runloop 安装 input source</h3>

<p>表3-7 展示了 <code>RunLoopSource</code> 类的 <code>init</code> 方法 和 <code>addToCurrentRunLoop</code> 方法。<code>init</code> 方法创建了 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/c/tdef/CFRunLoopSourceRef">CFRunLoopSource</a> 不透明类型的必须关联到 runloop 的对象。它会传递 <code>RunLoopSource</code> 对象自己作为 山下文信息 以便于例行回调程序有一个指向对象的指针。input source 直到线程唤起 <code>addToCurrentRunLoop</code> 方法时才会执行安装，准确将在 RunLoopSourceScheduleRoutine 回调函数调用时。 一旦 input source 安装到 runloop 中，线程将会运行自己的 runloop 去等待 input source 发出事件。</p>

<p>表3-7 安装 run loop source</p>

<pre><code class="objc">- (id)init {
    // 创建上下文容器，其中会连接自己的 info，retain info release info，还会关联三个例行程序。
    CFRunLoopSourceContext context = {0, (__bridge void *)(self), NULL, NULL, NULL ,NULL, NULL, &amp;RunLoopSourceScheduleRoutine, RunLoopSourceCancelRoutine, RunLoopSourcePerformRoutine};
    /** 通过索引，上下文，和CFAllocator创建source */
    runLoopSource = CFRunLoopSourceCreate(NULL, 0, &amp;context);
    commands = [[NSMutableArray alloc] init];
    return  self;
}

- (void)addToCurrentRunLoop{
    CFRunLoopRef runLoop = CFRunLoopGetCurrent();
    CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);
}
</code></pre>

<h3>协调 input source 的客户机</h3>

<p>对于你的 input source 会非常有用，你需要操作它并且从其他线程向它提供消息。input source 的要点是将其添加到线程并睡眠直到有事情要做时才唤醒。事实上很有必要让其他线程了解 input surce 并且有方法可以和它交流（沟通数据）。</p>

<p>通知你的 input source 客户机的方法之一是发出注册请求 当你的 input source 第一次安装到你的 runloop 中时。你可以向你的 input source 注册尽可能多的客户机。或者你仅仅只是简单的用一些中央机构，然后将你的 input source 声明为感兴趣的客户端进行注册。表3-8 展示了  通过代理 和 调用唤起定义的 注册方法 当 RunLoopSource 对象的调度者函数被调用时。这个方法将会收到 RunLoopSource 提供的 RunLoopContext 对象并且将它添加到他的 source 列表中。这个表也会展示 当 input source 从 他的 runloop 中被移除时 用来注销的例行程序。
表 3-8 使用 application 的 代理 注销并且移除 input source</p>

<pre><code class="objc"> #import "YCRunLoopSource.h"
 #import "YCRunLoopContext.h"
@interface AppDelegate : NSObject
@property (nonatomic, strong) NSMutableArray *sourcesToPing;

/** 应该是一个单例 */
+ (instancetype)sharedAppDelegate;
- (void)registerSource:(YCRunLoopContext *)context;
- (void)removeSource:(YCRunLoopContext *)context;

@end

static AppDelegate *_instance;
@implementation AppDelegate

+ (instancetype)sharedAppDelegate
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        _instance = [[self alloc] init];
    });
    return _instance;
}

- (void)registerSource:(YCRunLoopContext *)context
{
    [self.sourcesToPing addObject:context];
}

- (void)removeSource:(YCRunLoopContext *)context
{
    id objToRemove = nil;

    for (YCRunLoopContext *contextObj in self.sourcesToPing) {
        if ([contextObj isEqual:context]) {
            objToRemove = contextObj;
            break;
        }
    }

    if (objToRemove) {
        [self.sourcesToPing removeObject:objToRemove];
    }
}

- (NSMutableArray *)sourcesToPing {
    if (_sourcesToPing == nil) {
        _sourcesToPing = @[].mutableCopy;
    }
    return _sourcesToPing;
}
@end
</code></pre>

<p><code>Note：回调函数会在之前的表3-4和3-6中调用这些函数</code></p>

<h5>信号激活 input source</h5>

<p>释放 input source 的数据之后，客户机必须发信号给 source 并且唤醒它的 runloop。发信号给 source 是让 runloop 知道 source 已经准备好被处理。因为线程可能会在发信号的时处于睡眠状态，所以那你必须显式的让 run loop 保持唤醒。除非如此，不然在处理 input source 时会出现延迟。</p>

<p>表 3-9 展示了 <code>RunLoopSource</code> 对象的 <code>fireCommandsOnRunLoop</code> 方法，客户机会在它准备好为 source 处理添加到 buffer 缓冲区中的 command 命令时调用这个方法。</p>

<p>表 3-9 唤醒 run loop
<code>objc
- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop
{
    CFRunLoopSourceSignal(runLoopSource);
    CFRunLoopWakeUp(runloop);
}
</code>
<code>Note:你不能通过向一个自定义 input source 发信息来处理一个 SIGHUP 或者其他处理类型的信号</code>，Core Foundation 框架中用于唤醒 runloop 的函数不是信号安全的。并且不能作为你的应用程序中内置信号处理的例行程序使用。关于更多的关于信号处理程序，详见 <a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man2/sigaction.2.html#//apple_ref/doc/man/2/sigaction">sigaction</a> man 页面。</p>

<h3>配置 Timer Source</h3>

<p>为了创建 timer source，所有你需要做的就是创建一个 timer 对象，并且在你的 run loop 中调度它。在 Cocoa 中，你使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/cl/NSTimer">NSTimer</a> 类来创建一个新的 timer 对象。在 Core Foundation 框架中，你可以使用 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/c/tdef/CFRunLoopTimerRef]">CFRunLoopTimerRef</a> 不透明类型来创建。<code>NSTimer</code> 类只是 Core Foundation 框架中的一个扩展，是用来方便的提供一些功能，比如使用相同的方法创建和调度 timer 。
在 Cocoa 中，你能通过以下两种类方法创建和调度 timer。<br/>
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</a>
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:">scheduledTimerWithTimeInterval:invocation:repeats:</a></p>

<p>这些方法创建 timer 并且将它们添加到当前线程的 run loop 中的 default mode(<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode">NSDefaultRunLoopMode</a>) 中去。如果你使用的是 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/occ/cl/NSTimer">NSTimer</a> 对象，那就可以手动调度 timer 并且可以使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/cl/NSRunLoop">NSRunLoop</a> 的 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/occ/instm/NSRunLoop/addTimer:forMode:">addTimer:forMode:</a> 手动将它添加到 runloop 中去。这两种技术都是基于同一种，但是通过timer 的配置给你不同级别的控制。比如你手动创建 timer 并将它添加到 run loop 中，并添加到除 default mode 之外的其他 mode 中去。表3-10 展示了如何使用两种技术创建 timer。第一个 timer 初始化为 延迟一秒但是会在延迟后有规律的每个0.1秒触发一次。第二个 timer 会在 0.2 秒延迟后开始触发，并且在延迟结束后 每 0.2 秒触发一次。</p>

<p>表3-10 使用 NSTimer 创建和调度 timer
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSRunLoop</span><span class="o">*</span> <span class="n">myRunLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// 创建并调度第一个 timer</span>
</span><span class='line'><span class="bp">NSDate</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">futureDate</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="nl">dateWithTimeIntervalSinceNow</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
</span><span class='line'><span class="bp">NSTimer</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">myTimer</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSTimer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFireDate</span><span class="p">:</span><span class="n">futureDate</span>
</span><span class='line'>                        <span class="nl">interval</span><span class="p">:</span><span class="mf">0.1</span>
</span><span class='line'>                        <span class="nl">target</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'>                        <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myDoFireTimer1</span><span class="p">:)</span>
</span><span class='line'>                        <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                        <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">myRunLoop</span> <span class="nl">addTimer</span><span class="p">:</span><span class="n">myTimer</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// 创建并调动第二个 timer</span>
</span><span class='line'><span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">0.2</span>
</span><span class='line'>                        <span class="nl">target</span><span class="p">:</span><span class="nb">self</span>
</span><span class='line'>                        <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">myDoFireTimer2</span><span class="p">:)</span>
</span><span class='line'>                        <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span>
</span><span class='line'>                        <span class="nl">repeats</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>表3-11 展示了使用 Core Foundation 框架时需要配置的代码。尽管实例代码中没有传递任何用户自定义的信息的上下文结构，但是你可以使>用这个结构去传递任何你的 timer 所需要自定义数据。关于更多该结构的内容可以浏览 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/doc/uid/20001444">CFRunLoopTimer 参考</a>。</p>

<p>表 3-11 使用 Core Foundation 框架创建和调度一个 timer
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFRunLoopRef</span> <span class="n">runLoop</span> <span class="o">=</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">();</span>
</span><span class='line'><span class="n">CFRunLoopTimerContext</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
</span><span class='line'><span class="n">CFRunLoopTimerRef</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">CFRunLoopTimerCreate</span><span class="p">(</span><span class="n">kCFAllocatorDefault</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>                                        <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">myCFTimerCallback</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">context</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">CFRunLoopAddTimer</span><span class="p">(</span><span class="n">runLoop</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">kCFRunLoopCommonModes</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></p>

<h3>配置一个基于 port 的 input source</h3>

<p>Cocoa 和 Core Foundation 都支持用于和线程间或者进程间通信的基于 端口的对象。接下来的章节将会向你展示如何使用一些不同类型的 port 构建 port 通信。</p>

<h3>配置一个NSMachPort Object</h3>

<p>使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSMachPort_Class/index.html#//apple_ref/occ/cl/NSMachPort">NSMachPort</a> 对象创建一个本地连接。你创建一个 port 对象并把它添加到你的主线程 run loop 中去。当启动你的子线程时，你要传一些相同的对象到你的线程入口点函数中去。子线程可以使用相同的对象发送信息回到你的主线程中去。</p>

<h3>实现主线程代码</h3>

<p><a href="#list3-12">表 3-12</a> 中展示了用于启动子工作线程的主线程代码。因为 Cocoa 框架执行很多介入步骤用于配置 port 和 run loop ，Cocoa 的 <code>launchThread</code> 方法相比于 Core Foundation 的等价功能<a href="#list3-17">表 3-17</a>更加简洁明了。尽管如此，这两个框架在这一模块的功能表现基本都是相同的。其中一个存在的差异是与发送本地 port 到工作线程的方式不同，这个方法是直接发送 NSPort 对象的。</p>

<p><strong>表 3-12</strong> list3-12 Main Thread lauch method</p>

<pre><code class="objc">- (void)launchThread {
    NSPort *myPort = [NSMachPort port];
    if (myPort) {
        // 这个类处理即将过来的 port 信息
        [myPort setDelegate:self];
        // 将此端口作为 input source 安装到当前 run loop 中去
        [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];
        // 开启工作子线程，让工作子线程去释放 port
        [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:) toTarget:[MyWorkerClass class] withObject:myPort];
    }
}
</code></pre>

<p>为了设置为线程间双向通信信
道，在
登记信息中，你需要让工作线程发送自己的本地 port 到主线程。接收登记信息是为了让你的主线程知道开动子线程的过程进行的非常顺利，同时也为我们为提供了一种方法去向该线程发送更多信息。</p>

<p>表 3-13 展示了用于主线程的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSPortDelegate_Protocol/index.html#//apple_ref/occ/intfm/NSPortDelegate/handlePortMessage:">handlePortMessage:</a>方法，这个方法会在线程到达自己的本地 port 时进行调用。当登记信息(check-in message)到达时，该方法将直接从 port 信息中检索子线程的 port 并保存以备后用。</p>

<p><strong>表 3-13</strong>    <span id = "listing 3-13">处理 Mach port 信息</span></p>

<pre><code class="objc">
# define kCheckinMessage 100

// 处理工作线程的响应的代理方法
- (void)handlePortMessage:(NSPortMessage *)portMessage
{
    unsigned int message = [portMessage msgid];
    // 定义远程端口
    NSPort *distantPort = nil;
    if (message == kCheckinMessage) {
        // 获取工作线程的通信 port
        distantPort = [portMessage sendPort];

// 引用计数+1 并 保存工作端口以备后用
        [self storeDistantPort:distantPort];
    } else {
        // 处理其他信息
    }
}

- (void)storeDistantPort:(NSPort *)port {
    // 保存远程端口
}
</code></pre>

<h4>实现子线程代码</h4>

<p>对于工作子线程，你必须配置它并且是使用指定的端口进行信息沟通并返回到主线程。</p>

<p>表 3-14 展示了用于设置工作线程的代码。在创建一个 qutorealease  pool 之后，该方法会创建一个工作对象去驱动线程执行。该工作对象 的 <code>sendCheckinMessage:</code> 方法（表3-15 所示）为工作线程创建一个本地端口然后回复一个 check-in 信息给主线程。
表 3-14 <span id = "liting3-14"> 使用 Mach port 启动子线程 </span></p>

<pre><code class="objc">+(void)LaunchThreadWithPort:(id)inData
{
    NSAutoreleasePool*  pool = [[NSAutoreleasePool alloc] init];

    // 设置本线程与主线程的连接 
    NSPort* distantPort = (NSPort*)inData;

    MyWorkerClass*  workerObj = [[self alloc] init];
    [workerObj sendCheckinMessage:distantPort];
    [distantPort release];

    // 让 run loop 处理这些逻辑 
    do
    {
        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode
                            beforeDate:[NSDate distantFuture]];
    }
    while (![workerObj shouldExit]);

    [workerObj release];
    [pool release];
}
</code></pre>

<p>当使用 <code>NSMachPort</code> 时,本地和远端线程都可以使用相同的 port 对象 完成线程之间的单工通信（单向通信）。换句话说，通过一个线程创建的本地对象会成为另一个线程的远端 port 对象。（ps：现在总算明白本地就是当前线程环境，远端就是其他线程环境）。</p>

<p>表 3-15展示了子线程的 check-in 例行程序 （登记信息例行程序）。这个方法设置了他自己的用于和以后进行通讯的本地端口。并且回复一个 check-in 登记信息给主线程。该方法使用 port 对象去接收 <code>LaunchThreadWithport:</code> 方法作为信息目标。</p>

<p>表 3-15 使用 Mach port 发送 check-in 登记信息</p>

<pre><code class="objc">// Worker thread check-in method
- (void)sendCheckinMessage:(NSPort*)outPort
{
    // 保留（retain）并保存远端的 port 以备后用
    [self setRemotePort:outPort];

    // 创建和配置工作线程的端口（ps：当前线程端口）    
    NSPort* myPort = [NSMachPort port];
    [myPort setDelegate:self];
    [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];

    // 创建 check-in 登记信息
    NSPortMessage* messageObj = [[NSPortMessage alloc] initWithSendPort:outPort
                                         receivePort:myPort components:nil];

    if (messageObj)
    {
        // 完成配置信息 并 立即发送出去
        [messageObj setMsgId:setMsgid:kCheckinMessage];
        [messageObj sendBeforeDate:[NSDate date]];
    }
</code></pre>

<h4>配置一个 NSMessagePort 对象</h4>

<p>如果想要使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSM%20%20%20%20essagePort_Class/index.html#//apple_ref/occ/cl/NSMessagePort">NSMessagePort</a> 对象创建一个本地连接，你不能在线程间仅仅值传递一个 port 对>    象。远端信息端口必须通过名字获取。
在Cocoa中，如果你想实现这个功能，需要使用一个指定的名字去注册你的本地端口，然后向远端线程传递注册的名字以便于他可以包含一
    个合适的端口对象用于交流。表 3-16 展示了 port 创建方法和注册方法 用于你想要使用 消息端口（message port）的地方。</p>

<p>表 3-16 注册一个 message port</p>

<pre><code class="objc">NSPort* localPort = [[NSMessagePort alloc] init];

// 配置对象并将它添加到当前 run loop 中去
[localPort setDelegate:self];
[[NSRunLoop currentRunLoop] addPort:localPort forMode:NSDefaultRunLoopMode];

// 使用指定的名字注册端口。名字必须唯一。
NSString* localPortName = [NSString stringWithFormat:@"MyPortName"];
[[NSMessagePortNameServer sharedInstance] registerPort:localPort
name:localPortName];
</code></pre>

<p> (未完待续。。。)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（四）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/08/runloopshen-du-tan-jiu-(4)/"/>
    <updated>2016-01-08T18:45:07+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/08/runloopshen-du-tan-jiu-(4)</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1">Run Loops</a></p>

<p>Run loops 是与线程相关联的基础设施的一部分。Run loop 是用来调度工作并且协调传入事件的时间处理循环。run loop 的目的是：让你的线程在有工作的任务的事后保持忙碌，并且在空闲的事后使线程保持休眠。</p>

<!--more-->


<p>Run loop 的管理并不是完全自动的，你仍然需要设计你的线程代码，并利用这些代码在合适的时机开启 run loop 并且相应传入的事件。Cocoa 和 Core Foundation 框架都提供了run loop 对象，以便于帮助你配置和管理你的线程 run loop。你的应用不需要显式的创建这些 run loop 对象。每条线程，包括应用的主线程，都会配有一个相关联的 run loop 对象。只有子线程们需要显式的（手动）运行它们的 run loop。然而，该 app 框架将会自动设置并且运行作为应用程序启动过程的一部分的处于 main thread （主线程）的 run loop。</p>

<p>接下来，我们一起看看关于 run loop 以及它们的配置相关的更多信息。参照<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/uid/TP40003725">NSRunLoop Class Reference</a> 以及 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/doc/uid/20001441-CH1g-112707">CFRunLoop Reference</a>。</p>

<h3>Run Loop 剖析</h3>

<p>run loop 是一个名副其实的循环。他会是你的线程不停地循环工作，具体包括线程的进入并且用来响应输入源所运行的事件处理程序。你的代码提供的控制状态将会被用来实现run loop具体的循环部分。换句话说，你的代码需要提供 while 或 for 循环来驱动你的 run loop。在你的 run loop 中，你使用一个 run loop 对象去“执行”接收事件的事件处理代码和调用已经安装好的 handlers。</p>

<p>run loop 通过两种不同类型的 source 来接收事件。Input source 传递异步事件，通常包括从其他线程或者其他应用发来的 message 。Timer source 也传递异步事件，通常发生在一个被安排好的时间或者重复的时间间隔。这两种类型的 source 都会使用 application-specific 处理例程来处理到来的事件。</p>

<p>插图3-1展示了 run loop 各种 source 的概念结构。input source 传递异步事件到相对应的 handler（处理程序）并且引起 <code>runUtilDate:</code> 方法（调用线程相关的 NSRunLoop 对象）退出。</p>

<p><em>插图3-1 run loop 和它的 source 结构</em>
<img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="插图3-1" /></p>

<p>除了处理 input source，run loop 同样也会生成一些关于 run loop 的行为的通知。注册 run-loop observers（观察者）去接收这些通知并且使用他们去在线程上做额外的处理。你可以使用 Core Foundation 框架去在你的线程上安装 run-loop observer 。</p>

<p>下面这些段落提供了更多地关于 runloop的组成 和 它们可以操作的modes，它们还描述了在事件处理的不同时间点生成的通知。</p>

<h3>Run Loop Modes</h3>

<p>一个 run loop mode 是一个包含 input sources 和 被监视的 timers 和 将要被通知的 run-loop 的observer 所组成的集合。每次你启动你的 run loop 时，你都会指定（隐式或者显式的）一种特定的“mode”来运行。在执行该运行循环的期间，只有与指定运行的 mode 相关联的 source 才会被检测和允许去发送他们的事件。（相同的，只有与指定运行的 mode 相关联的 observer 会被 run loop 的进度（progress）所通知）。关联到其他 modes 的 sources 直到 run loop 切换到对应的 mode 时才会继续让新的事件通行（只有到对应的mode下，相关的 source 才会继续其对应的功能）。</p>

<p>在你的代码中，可以使用名字来标记 modes，包括 Cocoa 和 Core Foundation 都定义了一些默认的mode和一些常用的mode，代码中你可以通过字符串来区别这些mode，你可以定义自定义的mode，仅仅通过指定简单的字符串来标记这些自定义的mode。尽管可以随意的对 mode 名字进行复制，但是这些 mode 的内容却不行。你必须确保你添加到得任何你创建的 mode 中的一个或多个input sources, timers, 或者 run-loop observer都是有用的。</p>

<p>你使用 modes 并通过你的 run loop 特定的扫描中过滤掉干扰的事件。大多数情况下，你都会将你的 run loop 运行在系统默认的 mode 中。模态面板可能会运行在“ modal ” mode 中。当处于这种 mode 下，只有和 source 关联的模态面板才可以发送事件到线程中去。对于子线程来说，你可能会使用自定义 modes 去防止优先级抵的 source 在时间要求严格的操作中发送事件。</br>
<code>
Note: modes 的区别取决于 event（事件） 的 source ，不是 event 的类型。比如，你可能不会用 mode 去仅仅匹配一个鼠标点击事件或者键盘点击事件。 你可能会用 mode 去监听一组不同的端口。暂停 timer ，或者改变当前监视的 source ，然后，run loop observer 会立即开始监视。
</code>
</br>
列表3-1列出了 Cocoa 和 Core Foundation 框架中你可以使用的具有官方文档描述的一些标准的 mode，列名称列出了你在代码中需要指定 mode 时需要使用的实际常量。</p>

<h4><strong>Table 3-1</strong> <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW18">预定义的 run loop modes</a></h4>

<!--
| Mode | Name |Description|
| :------ | :------ | :------ |
| Default | [NSDefaultRunLoopMode](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode) (Cocoa)</br>[kCFRunLoopDefaultMode](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopDefaultMode) (Core Foundation) | Default Mode 是用的最多的 mode 操作。在大多数情况下，你应该使用此模式启动 Run Loop 和配置您的 input source。 |
|Connection|`NSConnectionReplyMode`(Cocoa)|Cocoa 使用这个 mode 来 `NSConnection` 对象共同监视 replies （回复响应），你一般不需要自己使用该 mode |
|Modal|`NSModalPanelRunLoopMode`(Cocoa)|Cocoa 使用这个 mode 来标记确认用于 modal panel（面板、控制器）的事件|
|Event tracking|`NSEventTrackingRunLoopMode`(Cocoa)|Cocoa 使用这个 mode 来约束鼠标拖动循环和其他类型的用户界面跟踪循环的输入事件|
|Common modes |[NSRunLoopCommonModes](https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSRunLoopCommonModes)(Cocoa)</br>[kCFRunLoopCommonModes](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopCommonModes) (Core Foundation)|这是一个 common mode 的可配置组，用该 mode 关联的某个 input source 同时也被组中的这些 mode 所关联。对于 Cocoa 的应用，这一套包括 default modal， 和 默认的 event tracking 这些 mode。Core Foundation 只包括开始的 default mode。你可以使用[CFRunLoopAddCommonMode](https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddCommonMode) function（函数）来添加自定义的 mode 到 mode 组中。|-->




<!--内嵌官方HTML-->


<hr />

<div class="tableholder"><table class="graybox" border="0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong class="caption_number"><!--Table 3-1--></strong>&nbsp;&nbsp;<!--Predefined run loop modes--></br></br></caption><tbody><tr><th scope="col" class="TableHeading_TableRow_TableCell"><p>Mode</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Name</p></th><th scope="col" class="TableHeading_TableRow_TableCell"><p>Description</p></th></tr>
<tr><td scope="row"><p>Default</p></td><td><p><code><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSDefaultRunLoopMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoo_4&quot;;return this.s_oc?this.s_oc(e):true">NSDefaultRunLoopMode</a></code> (Cocoa)</p><p><code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopDefaultMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_2&quot;;return this.s_oc?this.s_oc(e):true">kCFRunLoopDefaultMode</a></code> (Core Foundation)</p></td><td><p> Default Mode 是用的最多的 mode 操作。在大多数情况下，你应该使用此模式启动 Run Loop 和配置您的 input source。 </p></td></tr><tr><td scope="row"><p>Connection</p></td><td><p><code><!--a target="_self" -->NSConnectionReplyMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 和<code><!--a target="_self" -->NSConnection<!--/a--></code>  对象共同监视 replies （回复响应），你一般不需要自己使用该 mode 
</p></td></tr><tr><td scope="row"><p>Modal</p></td><td><p><code><!--a target="_self" -->NSModalPanelRunLoopMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 来标记确认用于 modal panel（面板、控制器）的事件</p></td></tr><tr><td scope="row"><p>Event tracking</p></td><td><p><code><!--a target="_self" -->NSEventTrackingRunLoopMode<!--/a--></code> (Cocoa)</p></td><td><p>Cocoa 使用这个 mode 来约束鼠标拖动循环和其他类型的用户界面跟踪循环的输入事件 </p></td></tr><tr><td scope="row"><p>Common modes</p></td><td><p><code><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/c/data/NSRunLoopCommonModes" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoo_5&quot;;return this.s_oc?this.s_oc(e):true">NSRunLoopCommonModes</a></code> (Cocoa)</p><p><code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/data/kCFRunLoopCommonModes" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_3&quot;;return this.s_oc?this.s_oc(e):true">kCFRunLoopCommonModes</a></code> (Core Foundation)</p></td><td><p>这是一个 common mode 的可配置组，用 mode 关联的某个 input source 同时也被组中的这些 mode 所关联。对于 Cocoa 的应用，这一套包括 default modal， 和 默认的 event tracking 这些 mode。Core Foundation 只包括 开始的 default mode。你可以使用 <code><a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddCommonMode" data-renderer-version="2" target="_self" onclick="s_objectID=&quot;https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopRef/index_4&quot;;return this.s_oc?this.s_oc(e):true">CFRunLoopAddCommonMode</a></code> function 来添加自定义的 mode 到 mode 组中。</p></td></tr></tbody></table></div>


<hr />

<!--内嵌官方HTML-->


<h3>Input Sources</h3>

<p>input source 异步传递事件到你的线程中。event 的source 取决于 input source 的类型，通常是两个类型中的一个。<code>基于 port 的 input source</code> 监视着你的应用中的 Mach Port 。<code>自定义的 input source</code> 监视着你的自定义的事件 source 。至于你的run loop 来讲，他不应该在是否是基于 port 的 input source 还是 自定义 input source 出现问题。系统通常会实现这两种全部允许程序员自己使用类型的 input source 。这两种 source 之间唯一的不同在于它们是如何被发送信号的。基于 port 的 source 可以通过 kernel 内核接收发送的信号，而自定义的 source 必须手动从另一个线程发送信号过来。</p>

<p>当你创建一个 input source 时，你可以给它分配一个或多个你的 run loop 的 mode 。受 mode 影响的 input source 会在任何给定的时刻受到监视，在大多数情况下，你的 run loop 会运行在 default mode 下，但是你也可以自己指派自定义的mode给它。如果一个 input source 没有处于当前受监视的 mode 下，那么任何它产生的事件都会被挂起，除非你的 run loop 在正确的 mode 下运行（就是让你的 run loop 以你需要监视的 input source 所属的 mode 开始运行，这样 run loop 才能监视到你的 input source 产生的事件）。</p>

<p>下面介绍一些 input source 。。。</p>

<h4>基于 port 的 source</h4>

<p>Cocoa 和 Core Foundation 框架都提供了内置的支持&ndash;使用 port 相关的对象和函数来创建基于 port 的input source。例如，在 Cocoa 中，你根本不用自己直接创建一个 input source，你只需要创建一个 port 对象，并使用 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSPort_Class/index.html#//apple_ref/occ/cl/NSPort">NSPort</a> 的方法去将 port 添加到 run loop 中去。port 对象会为你处理好创建和配置一个你需要的 input source 这些底层的事情。</p>

<p>在 Core Foundation 中， 你必须手动的两者都创建，其中包括 port 和 它的 run loop source ，在两种情况下， 你可以使用 port 不透明类型的 (<a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMachPortRef/index.html#//apple_ref/c/tdef/CFMachPortRef">CFMachPortRef</a>, <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFMessagePortRef/index.html#//apple_ref/c/tdef/CFMessagePortRef">CFMessagePortRef</a>, or <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/tdef/CFSocketRef">CFSocketRef</a>) 相关的函数来创建合适的对象（you use the functions associated with the port opaque type (CFMachPortRef, CFMessagePortRef, or CFSocketRef) to create the appropriate objects）。</p>

<p>如何创建和配置自定义的基于 port 的源，可以参照<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281">创建一个基于 port 的 input source</a>
</br>
</br></p>

<h4>自定义 input source</h4>

<p>为了自定义一个 input source，你必须使用 Core Foundation 框架中 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/c/tdef/CFRunLoopSourceRef">CFRunLoopSourceRef</a>的不透明类型相关联的函数。你可以使用多个回调函数来配置你的自定义 input source ，Core Foundation 框架会配置你的  source 在不同的点去调用这些函数，处理将要发生的事件，并在 source 被移出 run loop 的时候销毁 source。</p>

<p>除了定义在事件到来时自定义 source 的行为，你还必须定义事件传递机制。source 的这部分运行在一个单独的线程中，并且负责 当数据已经准备好去被处理的时候，这部分会去提供一个拥有数据的 input source，并且发信号给 input source。这个事件传递机制取决于你，但是也不用过于复杂。</p>

<p>有关如何创建一个自定义 input source 的例子，可以参考<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3">定义一个自定义 input source</a>， 关于自定义 input source 的详细信息， 可以参考 <a href="https://developer.apple.com/library/ios/documentation/CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/doc/uid/20001443">CFRunLoopSourceReference</a></p>

<h3>Run Loop 的时间执行次序</h3>

<p>每一次你运行 run loop 时，你的线程的 run loop 都会处理未完成的事件，并且为已经注册的任何观察者生成通知信息。下面是它执行的具体步骤：</p>

<ol>
<li>通知观察者 runloop 已经进入。</li>
<li>通知观察者 任何就绪的 timer 即将触发。</li>
<li>通知观察者 任何 不是基于端口的 input source （source0）即将触发</li>
<li>触发任何不是基于端口的并且准备就绪的 input source。</li>
<li>假如存在已经准备好的基于端口的 input source （source1），将会等待被触发。并立即开始处理事件。跳转至步骤 9 。</li>
<li>通知观察者 线程即将睡眠。</li>
<li>设置让线程在符合如下条件之一时从睡眠状态唤醒：

<ul>
<li>一个基于端口的 input source（source1）产生的事件到来。</li>
<li>timer 触发了。</li>
<li>超出 runloop 预定的时间。</li>
<li>run loop 明确唤醒</li>
</ul>
</li>
<li>通知观察者，线程刚刚唤醒。</li>
<li>处理剩余的事件：

<ul>
<li>  如果一个用户定义的 timer 触发，处理 timer 的事件并且重启 ru loop ，跳转值步骤 2 。</li>
<li>如果一个 input source 触发，传递这个事件。</li>
<li>run loop 已经明确地被唤醒但是还没有超时。重启 run loop，并且跳转至 第二步。</li>
</ul>
</li>
<li>通知观察者，run loop 已经退出。
因为 timer 和 input source 发出的 observer 通知是在这些事件确实是发生时被发送的，那么在事件发生的时间和 observer 收到的通知的时间会存在时间间隙。如果对事件发生时间的准确性要求非常严格，那么你需要采取 <code>睡眠</code> 和 <code>唤醒睡眠</code> 的通知方式来帮助你纠正事件实际发生的时间。</li>
</ol>


<p>由于定时器等周期性事件是在 run loop 运行的时候发送的，需要避免在发送这些事件时被打断。典型的例子比如：只要进入运行循环，并且反复实时地从应用中请求事件来实现对鼠标跟踪的常规动作。由于你的代码是直接抓取事件的，而不是像平时一样让应用分发这些事件的，所以 timer 是不能被触发的，除非鼠标追踪程序退出并返回到应用程序控制。</p>

<p>一个 run loop 可以使用 run loop 对象显示唤醒，其他的事件可能也会引起 run loop 的唤醒。比如，添加另一个 <code>不是基于端口的 input source</code>（source1） 唤醒 run loop 从而使 input source 可以被立即处理（相比于一直处于等待状态直到其他时间发生才唤醒）。</p>

<h3>在什么时候适合使用 RunLoop ？</h3>

<p><strong><code>唯一需要你显示的使用 run loop 的时候是：当你为你的应用创建了子线程的时候。</code></strong>在你的应用中，主线程的 run loop 是基础设施中至关重要的一部分。所以，app 的框架都会提供运行主线程 loop 的代码并且自动开启 loop。iOS中<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplication_Class/index.html#//apple_ref/occ/cl/UIApplication">UIApplication</a>（或者OSX中<code>NSApplication</code>）的<code>run</code>方法会开启一个应用中的主 loop 作为应用程序启动步骤的一部分。如果你使用 Xcode 的项目模板来创建你的应用，你完全不用自已去显示的调用这些常规方法。</p>

<p>对子线程来讲，你需要决定是否一个 run loop 对它来说是必要的，如果是，需要你自己配置并且启动它。你并不需要在任何情况下都开启线程的 run loop。比如：你使用线程去执行一些长期的并且预先决定的任务的时候，你可能需要避免开启 run loop 。Run loop 通常服务于一些需要你和线程之间互动性更强的特殊场景。比如，你需要在以下这些场景中开启你的 run loop：</p>

<ul>
<li>使用 port 或者自定义 input source 来和其他线程进行通信。</li>
<li>在线程中使用 timer 。</li>
<li>在 Cocoa 的应用中使用任何与 <code>performSelector…</code>相关的方法。</li>
<li>让你的线程继续执行周期性的任务。</li>
</ul>


<p>如果你选择使用 run loop，配置和建立它是非常简单的。如同所有的多线程编程一样，你需要有计划的在合适的情况下退出子线程。让它（run loop）更好的退出而不是迫使它终止永远都是更好的更干净的结束线程的方法。关于如何配置并且退出的方法将在<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5">使用Run Loop对象</a>中向大家展示。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（三）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(3)/"/>
    <updated>2016-01-07T11:54:24+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(3)</id>
    <content type="html"><![CDATA[<h2>苹果用 RunLoop 实现的功能</h2>

<p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>

<pre><code class="objc">CFRunLoop {
    current mode = kCFRunLoopDefaultMode
    common modes = {
        UITrackingRunLoopMode
        kCFRunLoopDefaultMode
    }

    common mode items = {

        // source0 (manual)
        CFRunLoopSource {order =-1, {
            callout = _UIApplicationHandleEventQueue}}
        CFRunLoopSource {order =-1, {
            callout = PurpleEventSignalCallback }}
        CFRunLoopSource {order = 0, {
            callout = FBSSerialQueueRunLoopSourceHandler}}

        // source1 (mach port)
        CFRunLoopSource {order = 0,  {port = 17923}}
        CFRunLoopSource {order = 0,  {port = 12039}}
        CFRunLoopSource {order = 0,  {port = 16647}}
        CFRunLoopSource {order =-1, {
            callout = PurpleEventCallback}}
        CFRunLoopSource {order = 0, {port = 2407,
            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_}}
        CFRunLoopSource {order = 0, {port = 1c03,
            callout = __IOHIDEventSystemClientAvailabilityCallback}}
        CFRunLoopSource {order = 0, {port = 1b03,
            callout = __IOHIDEventSystemClientQueueCallback}}
        CFRunLoopSource {order = 1, {port = 1903,
            callout = __IOMIGMachPortPortCallback}}

        // Ovserver
        CFRunLoopObserver {order = -2147483647, activities = 0x1, // Entry
            callout = _wrapRunLoopWithAutoreleasePoolHandler}
        CFRunLoopObserver {order = 0, activities = 0x20,          // BeforeWaiting
            callout = _UIGestureRecognizerUpdateObserver}
        CFRunLoopObserver {order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit
            callout = _afterCACommitHandler}
        CFRunLoopObserver {order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit
            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
        CFRunLoopObserver {order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit
            callout = _wrapRunLoopWithAutoreleasePoolHandler}

        // Timer
        CFRunLoopTimer {firing = No, interval = 3.1536e+09, tolerance = 0,
            next fire date = 453098071 (-4421.76019 @ 96223387169499),
            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)}
    },

    modes ＝ {
        CFRunLoopMode  {
            sources0 =  { /* same as 'common mode items' */ },
            sources1 =  { /* same as 'common mode items' */ },
            observers = { /* same as 'common mode items' */ },
            timers =    { /* same as 'common mode items' */ },
        },

        CFRunLoopMode  {
            sources0 =  { /* same as 'common mode items' */ },
            sources1 =  { /* same as 'common mode items' */ },
            observers = { /* same as 'common mode items' */ },
            timers =    { /* same as 'common mode items' */ },
        },

        CFRunLoopMode  {
            sources0 = {
                CFRunLoopSource {order = 0, {
                    callout = FBSSerialQueueRunLoopSourceHandler}}
            },
            sources1 = (null),
            observers = {
                CFRunLoopObserver &gt;{activities = 0xa0, order = 2000000,
                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv}
            )},
            timers = (null),
        },

        CFRunLoopMode  {
            sources0 = {
                CFRunLoopSource {order = -1, {
                    callout = PurpleEventSignalCallback}}
            },
            sources1 = {
                CFRunLoopSource {order = -1, {
                    callout = PurpleEventCallback}}
            },
            observers = (null),
            timers = (null),
        },

        CFRunLoopMode  {
            sources0 = (null),
            sources1 = (null),
            observers = (null),
            timers = (null),
        }
    }
}
</code></pre>

<p>可以看到，系统默认注册了5个Mode:</p>

<!--more-->


<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。
4: GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。
5: kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>


<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>

<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 1. 通知Observers，即将进入RunLoop</span>
</span><span class='line'>    <span class="c1">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="k">strong</span><span class="o">&gt;</span><span class="n">CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION</span><span class="o">&lt;/</span><span class="k">strong</span><span class="o">&gt;</span><span class="p">(</span><span class="n">kCFRunLoopEntry</span><span class="p">);</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="c1">/// 2. 通知 Observers: 即将触发 Timer 回调。</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeTimers</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeSources</span><span class="p">);</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 4. 触发 Source0 (非基于port的) 回调。</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><span class="p">(</span><span class="n">source0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 6. 通知Observers，即将进入休眠</span>
</span><span class='line'>    <span class="c1">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopBeforeWaiting</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 7. sleep to wait msg.</span>
</span><span class='line'>    <span class="n">mach_msg</span><span class="p">()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">mach_msg_trap</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 8. 通知Observers，线程被唤醒</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopAfterWaiting</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 9. 如果是被Timer唤醒的，回调Timer</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class="p">(</span><span class="n">dispatched_block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span>
</span><span class='line'>    <span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><span class="p">(</span><span class="n">source1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">}</span> <span class="k">while</span> <span class="p">(...);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// 10. 通知Observers，即将退出RunLoop</span>
</span><span class='line'><span class="c1">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span>
</span><span class='line'><span class="n">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class="p">(</span><span class="n">kCFRunLoopExit</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h3>AutoreleasePool</h3>

<p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>

<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>

<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<em>objc_autoreleasePoolPop() 和 </em>objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>

<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>

<h3>事件响应</h3>

<p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>

<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>

<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>

<h3>手势识别</h3>

<p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>

<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>

<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>

<h3>界面更新</h3>

<p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>

<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：
_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>

<p>这个函数内部的调用栈大概是这样的：</p>

<pre><code class="objc">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()
    QuartzCore:CA::Transaction::observer_callback:
        CA::Transaction::commit();
            CA::Context::commit_transaction();
                CA::Layer::layout_and_display_if_needed();
                    CA::Layer::layout_if_needed();
                        [CALayer layoutSublayers];
                            [UIView layoutSubviews];
                    CA::Layer::display_if_needed();
                        [CALayer display];
                            [UIView drawRect];
</code></pre>

<h3>定时器</h3>

<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>

<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>

<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>

<h3>PerformSelector</h3>

<p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>

<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>

<h3>关于GCD</h3>

<p>实际上 RunLoop 底层也会用到 GCD 的东西。同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>

<p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>

<h3>关于网络请求</h3>

<p>iOS 中，关于网络请求的接口自下至上有如下几层:
<code>objc
CFSocket
CFNetwork       -&gt;ASIHttpRequest
NSURLConnection -&gt;AFNetworking
NSURLSession    -&gt;AFNetworking2, Alamofire
</code>
• CFSocket 是最底层的接口，只负责 socket 通信。
• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。
• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。
• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</p>

<p>下面主要介绍下 NSURLConnection 的工作过程。</p>

<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>

<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_network.png?raw=true" alt="NSURLConnection" /></p>

<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>

<h2>RunLoop 的实际应用举例</h2>

<h3>AFNetworking</h3>

<p><a href="https://github.com/AFNetworking/AFNetworking/blob/2.6.3/AFNetworking/AFURLConnectionOperation.m">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">networkRequestThreadEntryPoint:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">__unused</span> <span class="n">object</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]</span> <span class="nl">setName</span><span class="p">:@</span><span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">AFNetworking</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;];</span>
</span><span class='line'>        <span class="bp">NSRunLoop</span> <span class="o">*</span><span class="n">runLoop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSRunLoop</span> <span class="n">currentRunLoop</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="nl">addPort</span><span class="p">:[</span><span class="bp">NSMachPort</span> <span class="n">port</span><span class="p">]</span> <span class="nl">forMode</span><span class="p">:</span><span class="n">NSDefaultRunLoopMode</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">runLoop</span> <span class="n">run</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="p">(</span><span class="bp">NSThread</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="n">networkRequestThread</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="bp">NSThread</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">networkRequestThread</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">oncePredicate</span><span class="p">;</span>
</span><span class='line'>  <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">oncePredicate</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">networkRequestThread</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">networkRequestThreadEntryPoint</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">networkRequestThread</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="n">networkRequestThread</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>
RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</li>
</ul>


<pre><code class="objc">- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
</code></pre>

<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>

<h3>AsyncDisplayKit</h3>

<p><a href="https://github.com/facebook/AsyncDisplayKit">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>

<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>

<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。
绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。
UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>

<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>

<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>

<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。
具体的代码可以看这里：<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m">_ASAsyncTransactionGroup</a>。</p>

<h4>特别致谢：</h4>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<h4>参考文章</h4>

<p>深入理解RunLoop(ibireme)：</p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p>iPhoneDevWiki :</p>

<p><a href="http://iphonedevwiki.net/index.php/CFRunLoop">iphonedevwiki.net/index.php/CFRunLoop</a>
<a href="http://iphonedevwiki.net/index.php/IOHIDFamily">iphonedevwiki.net/index.php/IOHIDFamily</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究（二）]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(er-)/"/>
    <updated>2016-01-07T10:38:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/07/runloopshen-du-tan-jiu-(er-)</id>
    <content type="html"><![CDATA[<h2>RunLoop 的内部逻辑</h2>

<p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">文档</a>里的说明，RunLoop 内部的逻辑大致如下:
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_1.png?raw=true" alt="内部逻辑" /></p>

<p>内部代码整理为：</p>

<!--more-->


<pre><code class="objc">/// 用DefaultMode启动
void CFRunLoopRun(void) {
    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
}

/// 用指定的Mode启动，允许设置RunLoop超时时间
int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) {
    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}

/// RunLoop的实现
int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) {

    /// 首先根据modeName找到对应mode
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);
    /// 如果mode里没有source/timer/observer, 直接返回。
    if (__CFRunLoopModeIsEmpty(currentMode)) return;

    /// 1. 通知 Observers: RunLoop 即将进入 loop。
    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);

    /// 内部函数，进入loop
    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) {

        Boolean sourceHandledThisLoop = NO;
        int retVal = 0;
        do {

            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);
            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);

            /// 4. RunLoop 触发 Source0 (非port) 回调。
            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);
            /// 执行被加入的block
            __CFRunLoopDoBlocks(runloop, currentMode);

            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。
            if (__Source0DidDispatchPortLastTime) {
                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)
                if (hasMsg) goto handle_msg;
            }

            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。
            if (!sourceHandledThisLoop) {
                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);
            }

            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。
            /// • 一个基于 port 的Source 的事件。
            /// • 一个 Timer 到时间了
            /// • RunLoop 自身的超时时间到了
            /// • 被其他什么调用者手动唤醒
            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) {
                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg
            }

            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。
            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);

            /// 收到消息，处理消息。
            handle_msg:

            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。
            if (msg_is_timer) {
                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())
            } 

            /// 9.2 如果有dispatch到main_queue的block，执行block。
            else if (msg_is_dispatch) {
                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
            } 

            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件
            else {
                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);
                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);
                if (sourceHandledThisLoop) {
                    mach_msg(reply, MACH_SEND_MSG, reply);
                }
            }

            /// 执行加入到Loop的block
            __CFRunLoopDoBlocks(runloop, currentMode);


            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
                /// 进入loop时参数说处理完事件就返回。
                retVal = kCFRunLoopRunHandledSource;
            } else if (timeout) {
                /// 超出传入参数标记的超时时间了
                retVal = kCFRunLoopRunTimedOut;
            } else if (__CFRunLoopIsStopped(runloop)) {
                /// 被外部调用者强制停止了
                retVal = kCFRunLoopRunStopped;
            } else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) {
                /// source/timer/observer一个都没有了
                retVal = kCFRunLoopRunFinished;
            }

            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。
        } while (retVal == 0);
    }

    /// 10. 通知 Observers: RunLoop 即将退出。
    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
}
</code></pre>

<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回</p>

<h2>RunLoop 的底层实现</h2>

<p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。</p>

<p><img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_3.png?raw=true" alt="底层逻辑" /></p>

<p>苹果官方将整个系统大致划分为上述4个层次：
应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。
应用框架层即开发人员接触到的 Cocoa 等框架。
核心框架层包括各种核心框架、OpenGL 等内容。
Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="http://opensource.apple.com/">opensource.apple.com</a> 里找到。</p>

<p>我们在深入看一下 Darwin 这个核心的架构
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_4.png?raw=true" alt="Darwin" />
其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。
XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。
BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。
IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>

<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为"对象"。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。"消息"是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>

<p>Mach 的消息定义是在 &lt;mach/message.h> 头文件的，很简单：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">mach_msg_header_t</span> <span class="n">header</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_body_t</span> <span class="n">body</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="kt">mach_msg_base_t</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">mach_msg_bits_t</span> <span class="n">msgh_bits</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_size_t</span> <span class="n">msgh_size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_t</span> <span class="n">msgh_remote_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_t</span> <span class="n">msgh_local_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_port_name_t</span> <span class="n">msgh_voucher_port</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">mach_msg_id_t</span> <span class="n">msgh_id</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="kt">mach_msg_header_t</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">一条</span> <span class="n">Mach</span> <span class="err">消息实际上就是一个二进制数据包</span> <span class="p">(</span><span class="n">BLOB</span><span class="p">)</span><span class="err">，其头部定义了当前端口</span> <span class="n">local_port</span> <span class="err">和目标端口</span> <span class="n">remote_port</span><span class="err">，</span>
</span><span class='line'><span class="err">发送和接受消息是通过同一个</span> <span class="n">API</span> <span class="err">进行的，其</span> <span class="n">option</span> <span class="err">标记了消息传递的方向：</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="n">objc</span>
</span><span class='line'><span class="kt">mach_msg_return_t</span> <span class="n">mach_msg</span><span class="p">(</span>
</span><span class='line'>            <span class="kt">mach_msg_header_t</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_msg_option_t</span> <span class="n">option</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_msg_size_t</span> <span class="n">send_size</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_msg_size_t</span> <span class="n">rcv_size</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_port_name_t</span> <span class="n">rcv_name</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_msg_timeout_t</span> <span class="n">timeout</span><span class="p">,</span>
</span><span class='line'>            <span class="kt">mach_port_name_t</span> <span class="n">notify</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>
为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_5.png?raw=true" alt="Darwin" />
这些概念可以参考维基百科:<a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing">Trap_(computing)</a>)</p>

<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>

<p>关于具体的如何利用 mach port 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/">NSHipster</a> 这一篇文章，或者<a href="http://segmentfault.com/a/1190000002400329">这里</a>的中文翻译 。</p>

<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://history.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>

<h4>特别致谢：</h4>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p><strong>参考文章：</strong></p>

<p>深入理解RunLoop(ibireme)：</p>

<p><a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/
2015/05/18/runloop/#more-41710</a></p>

<p>Apple Document：
<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html</a></p>

<p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">Apple&ndash;RunLoopManagement文档</a></p>

<p><a href="http://opensource.apple.com/">opensource.apple.com</a></p>

<p>维基百科：</p>

<p><a href="http://en.wikipedia.org/wiki/System_call">System_call</a>、
<a href="http://en.wikipedia.org/wiki/Trap_(computing">Trap_(computing)</a>)</p>

<p>NSHipster：</p>

<p><a href="http://nshipster.com/inter-process-communication/">inter-process-
communication</a> <a href="http://segmentfault.com/a/1190000002400329">inter-process-communication中文</a></p>

<p><a href="http://history.programmer.com.cn/8121/">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a></p>
]]></content>
  </entry>
  
</feed>
