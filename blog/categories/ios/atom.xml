<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | SuperYang`s Blog]]></title>
  <link href="http://yangchao0033.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yangchao0033.github.io/"/>
  <updated>2016-01-06T19:01:44+08:00</updated>
  <id>http://yangchao0033.github.io/</id>
  <author>
    <name><![CDATA[Super Yang]]></name>
    <email><![CDATA[757097678@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RunLoop深度探究]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/06/runloopshen-du-tan-jiu/"/>
    <updated>2016-01-06T18:15:48+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/06/runloopshen-du-tan-jiu</id>
    <content type="html"><![CDATA[<h2>RunLoop的概念</h2>

<p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：
<code>swift
function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
</code>
这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>

<!--more-->


<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 &ldquo;接受消息->等待->处理&rdquo; 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>

<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。
CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。
NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>

<p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c">开源</a>的，你可以在这里 <a href="http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz">http://opensource.apple.com/tarballs/CF/CF-855.17.tar.gz</a> 下载到整个 CoreFoundation 的源码。为了方便跟踪和查看，你可以新建一个 Xcode 工程，把这堆源码拖进去看。</p>

<h2>RunLoop与线程的关系</h2>

<p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>

<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span>
</span><span class='line'><span class="k">static</span> <span class="n">CFMutableDictionaryRef</span> <span class="n">loopsDic</span><span class="p">;</span>
</span><span class='line'><span class="c1">/// 访问 loopsDic 时的锁</span>
</span><span class='line'><span class="k">static</span> <span class="n">CFSpinLock_t</span> <span class="n">loopsLock</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">/// 获取一个 pthread 对应的 RunLoop。</span>
</span><span class='line'><span class="n">CFRunLoopRef</span> <span class="n">_CFRunLoopGet</span><span class="p">(</span><span class="kt">pthread_t</span> <span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">OSSpinLockLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">loopsLock</span><span class="p">);</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loopsDic</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span>
</span><span class='line'>    <span class="n">loopsDic</span> <span class="o">=</span> <span class="n">CFDictionaryCreateMutable</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CFRunLoopRef</span> <span class="n">mainLoop</span> <span class="o">=</span> <span class="n">_CFRunLoopCreate</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CFDictionarySetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="n">pthread_main_thread_np</span><span class="p">(),</span> <span class="n">mainLoop</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// 直接从 Dictionary 里获取。</span>
</span><span class='line'><span class="n">CFRunLoopRef</span> <span class="n">loop</span> <span class="o">=</span> <span class="n">CFDictionaryGetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="kr">thread</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">/// 取不到时，创建一个</span>
</span><span class='line'>    <span class="n">loop</span> <span class="o">=</span> <span class="n">_CFRunLoopCreate</span><span class="p">();</span>
</span><span class='line'>    <span class="n">CFDictionarySetValue</span><span class="p">(</span><span class="n">loopsDic</span><span class="p">,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">loop</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span>
</span><span class='line'>    <span class="n">_CFSetTSD</span><span class="p">(...,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">loop</span><span class="p">,</span> <span class="n">__CFFinalizeRunLoop</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">OSSpinLockUnLock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">loopsLock</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="n">loop</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">CFRunLoopRef</span> <span class="n">CFRunLoopGetMain</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_CFRunLoopGet</span><span class="p">(</span><span class="n">pthread_main_thread_np</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">CFRunLoopRef</span> <span class="n">CFRunLoopGetCurrent</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">_CFRunLoopGet</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
综上：线程和RunLoop之间是一一对应的，并且关系是保存在一个全局的字典中的，并且线程刚创建时是没有RunLoop的，如果你不获取它，他一直都不会有，RunLoop的创建发生在第一次获取的时候，RunLoop的销毁发生在线程结束时。并且只能在线程内部获取runloop（主线程除外）。</p>

<h1>RunLoop 对外的接口</h1>

<p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>

<pre><code class="objc">CFRunLoopRef
CFRunLoopModeRef
CFRunLoopSourceRef
CFRunLoopTimerRef
CFRunLoopObserverRef
</code></pre>

<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/RunLoop_0.png?raw=true" alt="image" />
一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>

<p><strong>CFRunLoopSourceRef</strong>是事件产生的地方。Source有两个版本：Source0 和 Source1。
• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。
• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopSourceRef.png?raw=true" alt="image" /></p>

<p><strong>CFRunLoopTimerRef</strong>是基于时间的触发器，他和NSTimer是toll-free bridged的，可以混用。其包含一个时间长度和一个回调（函数指针）。
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopTimeRef.png?raw=true" alt="image" /></p>

<p><strong>CFRunLoopObserverRef</strong>是观察者，每个Observer都包含了一个回调（函数指针），当RunLoop的状态发生变法时，观察者就能通过回调接受这个变化。可以观测的时间点有以下几个：
<img src="https://github.com/yangchao0033/blog/blob/master/ios/2015/12/Image/CFRunLoopObserverRef.png?raw=true" alt="image" />
<code>objc
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop
};
</code></p>

<h2>RunLoop的Mode</h2>

<p>CFRunLoopMode和CFRunLoop的结构大致如下：
<code>objc
struct __CFRunLoopMode {
    CFStringRef _name;            // Mode Name, 例如 @"kCFRunLoopDefaultMode"
    CFMutableSetRef _sources0;    // Set
    CFMutableSetRef _sources1;    // Set
    CFMutableArrayRef _observers; // Array
    CFMutableArrayRef _timers;    // Array
    ...
};
struct __CFRunLoop {
    CFMutableSetRef _commonModes;     // Set
    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;
    CFRunLoopModeRef _currentMode;    // Current Runloop Mode
    CFMutableSetRef _modes;           // Set
    ...
};
</code>
这里有个概念叫：“CommonModes”一个Mode可以将自己标记为“Common”属性（通过将其ModeName添加到RunLoop得“commonModes”中）。每当RnuLoop的内容发生变化时，RunLoop的都会自动将_commonModeItems里的Source/Timer/Observer同步到具有“Common”标记的所有的Mode。
应用举例：主线程 RunLoop 默认会预制两个 Mode ：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个Mode都已经被标记为“Common”属性。DefaultMode是App平时所处的状态，TrackingRunLoop是为了追踪ScrollView滑动时的状态。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调。此时滑动TableView时，RunLoop会将mode切换为TrackingRunLoopMode，这时Timer就不会被回调，也不会影响滑动的操作了。具体用例类似于在tableView中加入滚动广告栏，当你在操作tableView时会回调自动滚动栏的Timer，造成滚动栏的滑动出现卡顿。</p>

<p>有时你需要一个Timer，在两个Mode中都能得到回调，一种办法就是讲这个Timer加入两个Mode。还有一种就是讲Timer加入到顶层的RunLoop的“commonModeItems”中。“commonModeItems”被RunLoop自动更新到所有具有“Common”属性的Mode里去。</p>

<p>CFRunLoop对外暴漏的管理Mode的接口只有下面两个：
<code>objc
CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName); // 给RunLoop添加到CommonMode中
CFRunLoopRunInMode(CFStringRef modeName, ...); // 返回当前线程中指定mode的CFRunLoop对象
</code>
Mode暴露的管理mode item的接口有下面几个
<code>objc
CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);// 添加一个CFRunLoopSource对象到一个run loop mode中（如果添加的Source是source0的话，这个方法将会调用 schedule 回调在source的上下文结构（context structure）的指定方法）。一个runloop source 可以同时被注册到多个 runloop 和 runloop modes 中。当source被发出信号，无论哪一个被注册的 runloop 都会开始检测第一个发出信号的 source 。 如过rl的mode中已经包含source时，这个方法将不会做任何事。
CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName); // 添加CFRunLoopObserver对象到一个run loop mode中去。 讨论：一个 runloop 观察者只能被同时注册在一个 runloop 中，尽管它可以被通过他的tunloop添加到多个runloop modes中。 如果rl已经在 mode中 包含 obsever 中，这个方法将不会做任何事。
CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);
CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName); // 添加CFRunLoopTimer 对象到一个runloop mode中 讨论：一个runloop timer 在同一时刻只能注册在一个run loop，尽管它可以被通过他的tunloop添加到多个runloop modes中。 如果rl已经在 mode中 包含 obsever 中，这个方法将不会做任何事
CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName); // 从run loop mode 移除 Observer 对象，如果 rl 没有包含参数中的Observer，则该函数不做任何处理
CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); // 从run loop mode 移除 timer 对象，如果 rl 没有包含参数中的timer，则该函数不做任何处理
</code>
以上接口可以看出，只能通过mode name操作内部mode，当你传入一个新的mode name但runloop内部没有对应的mode时，runloop会自动帮你创建对应的CFRunloopModeRef。并且官方文档明确指出，对于runloop来说，其内部的mode只能增加不能删除。</p>

<p>苹果官方公开的内部mode有两个：CFRunLoopDefaultMode（NSDefaultRunLoopMode）和UITrackingRunLoopMode，你可以用这两个 Mode Name来操作对应的 Mode。
同时苹果还提出了一个操作Common标记的字符串：kCFRunLoopCommonModes（NSRunLoopCommonModes），你可以用这个字符串来操作Common Items，或标记一个Mode为“Common”。使用时注意区分该字符串与其他mode name。</p>

<p>参考文章：</p>

<p>深入理解RunLoop&mdash;&mdash;&mdash;-<a href="http://blog.ibireme.com/2015/05/18/runloop/#more-41710">http://blog.ibireme.com/2015/05/18/runloop/#more-41710</a></p>

<p>Apple Document&mdash;&mdash;&mdash;&ndash;<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[宏定义的高级用法]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/definede-gao-ji-yong-fa/"/>
    <updated>2016-01-04T11:44:51+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/definede-gao-ji-yong-fa</id>
    <content type="html"><![CDATA[<p>1、# （stringizing）字符串化操作符。其作用是：将宏定义中的传入参数名转换成用一对双引号括起来参数名字符串。其只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。
如：</p>

<pre><code class="c">#define example(instr) printf("the input string is:\t%s\n",#instr)
#define example1(instr) #instr
</code></pre>

<p>当使用该宏定义时：</p>

<!--more-->


<pre><code class="c">example(abc)；
</code></pre>

<p> 在编译时将会展开成：</p>

<pre><code>printf("the input string is:\t%s\n","abc");
string str=example1(abc);
</code></pre>

<p>将会展成：</p>

<p><code>string str="abc";</code></p>

<p>注意：
对空格的处理
a。忽略传入参数名前面和后面的空格。</p>

<p>   如：<code>str=example1(   abc )</code>； 将会被扩展成<code>str="abc"</code>；</p>

<p>b.当传入参数名间存在空格时，编译器将会自动连接各个子字符串，用每个子字符串中只以一个空格连接，忽略其中多余一个的空格。</p>

<p>   如：<code>str=exapme( abc    def)</code>; 将会被扩展成 <code>str="abc def"</code>；</p>

<p>2、## （token-pasting）符号连接操作符(让参数值转换为参数名)
宏定义中：参数名，即为形参，如#define sum(a,b) (a+b)；中a和b均为某一参数的代表符号，即形式参数。
而##的作用则是将宏定义的多个形参成一个实际参数名。</p>

<p>如：</p>

<p><code>#define exampleNum(n) num##n
</code></p>

<p><code>int num9=9</code>;</p>

<p>使用：</p>

<p><code>int num=exampleNum(9)</code>;</p>

<p>将会扩展成 <code>int num=num9</code>;</p>

<p>注意：</p>

<p>1.当用##连接形参时，##前后的空格可有可无。</p>

<p>如：<code>#define exampleNum(n) num ## n</code>相当于 <code>#define exampleNum(n) num##n</code></p>

<p>2.连接后的实际参数名，必须为实际存在的参数名或是编译器已知的宏定义</p>

<p>// preprocessor_token_pasting.cpp</p>

<pre><code>#include 
#define paster( n ) printf_s( "token" #n " = %d", token##n )
int token9 = 9;
int main()
{
   paster(9);
}
</code></pre>

<p>运行结果：</p>

<p><code>token9 = 9</code></p>

<p>3、@# （charizing）字符化操作符。
只能用于有传入参数的宏定义中，且必须置于宏定义体中的参数名前。作用是将传的单字符参数名转换成字符，以一对单引用括起来。</p>

<p><code>#define makechar(x)  #@x
a = makechar(b);</code></p>

<p>展开后变成了：</p>

<p><code>a= 'b';</code></p>

<p>4、\ 行继续操作符
当定义的宏不能用一行表达完整时，可以用"\&ldquo;表示下一行继续此宏的定义。</p>

<p><a href="http://blog.csdn.net/hjmhz/article/details/8667185">更多高级用法&hellip;</a></p>

<p><a href="http://blog.chinaunix.net/uid-23254875-id-341055.html">转自http://blog.chinaunix.net/uid-23254875-id-341055.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于block使用的5点注意事项]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/guan-yu-blockshi-yong-de-5dian-zhu-yi-shi-xiang-d/"/>
    <updated>2016-01-04T11:24:25+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/guan-yu-blockshi-yong-de-5dian-zhu-yi-shi-xiang-d</id>
    <content type="html"><![CDATA[<p><div class="post">
        <div class="clear"></div>
        <div class="postBody">
            <div id="cnblogs_post_body"><div id="main-content" class="wiki-content">
<p>1、在使用block前需要对block指针做判空处理。</p>
<p>不判空直接使用，一旦指针为空直接产生崩溃。</p>
</div>
<div class="wiki-content">
<pre><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">self.isOnlyNet) {
    </span><span style="color: #0000ff;">if</span> (succBlock == NULL) { <span style="color: #008000;">//</span><span style="color: #008000;">后面使用block之前要先做判空处理</span>
        <span style="color: #0000ff;">return</span><span style="color: #000000;">;
    }
    </span><span style="color: #0000ff;">id</span> data =<span style="color: #000000;"> [NSKeyedUnarchiver unarchiveObjectWithFile:[self favoriteFile]];
    </span><span style="color: #0000ff;">if</span> ([data isKindOfClass:[NSMutableArray <span style="color: #0000ff;">class</span><span style="color: #000000;">]]) {
        succBlock(data,YES);
    }</span><span style="color: #0000ff;">else</span><span style="color: #000000;">{
        succBlock(nil,YES);
    }
}</span></pre>
<p>&nbsp;</p>
</div>
<!--more-->
<div class="wiki-content">2、在MRC的编译环境下，block如果作为成员参数要copy一下将栈上的block拷贝到堆上（示例见下，<a class="external-link" href="http://www.cnblogs.com/biosli/archive/2013/05/29/iOS_Objective-C_Block.html" rel="nofollow">原因参考</a>）
<p>3、在block使用之后要对，block指针做赋空值处理，如果是MRC的编译环境下，要先release掉block对象。</p>
<p>block作为类对象的成员变量，使用block的人有可能用类对象参与block中的运算而产生循环引用。</p>
<p>将block赋值为空，是解掉循环引用的重要方法。（不能只在dealloc里面做赋空值操作，这样已经产生的循环引用不会被破坏掉）</p>
<pre>typedef <span style="color: #0000ff;">void</span>(^SuccBlock)(<span style="color: #0000ff;">id</span><span style="color: #000000;"> data);
</span><span style="color: #0000ff;">@interface</span><span style="color: #000000;"> NetworkClass {
    SuccessBlock _sucBlock;
}
@property (nonatomic,assign)BOOL propertyUseInCallBack;
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) requestWithSucBlock: (SuccessBlock) callbackBlock;
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> NetworkClass
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) requestWithSucBlock: (SuccessBlock) callbackBlock {
    <em>sucBlock </span>= callbackBlock;<span style="color: #008000;">//</span><span style="color: #008000;">MRC下：</em>sucBlock = [callbackBlock copy]; 不copy block会在栈上被回收。</span>
<span style="color: #000000;">}</p>

<p></span>- (<span style="color: #0000ff;">void</span>) netwrokDataBack: (<span style="color: #0000ff;">id</span><span style="color: #000000;">) data {
    </span><span style="color: #0000ff;">if</span> (data != nil &amp;&amp; <em>sucBlock !=<span style="color: #000000;"> NULL) {
        </em>sucBlock(data);
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;">MRC下：要先将[<em>sucBlock release];（之前copy过）</span>
    </em>sucBlock = nil; <span style="color: #008000;">//</span><span style="color: #008000;">Importent: 在使用之后将Block赋空值，解引用 !!!</span>
<span style="color: #000000;">}
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #008000;">//</span><span style="color: #008000;">=======================以下是使用方===========================</span>
<span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> UserCode
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) temporaryNetworkCall
{
    NetworkClass </span><em>netObj =<span style="color: #000000;"> [[NetworkClass alloc] init];
    netObj.propertyUseInCallBack </span>=<span style="color: #000000;"> NO;
    [netObj requestWithSucBlock: </span>^(<span style="color: #0000ff;">id</span><span style="color: #000000;"> data) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">由于block里面引用netObj的指针所以这里产生了循环引用，且由于这个block是作为参数传入对象的，编译器不会报错。
        </span><span style="color: #008000;">//</span><span style="color: #008000;">因此，NetworkClass使用完block之后一定要将作为成员变量的block赋空值。</span>
        <span style="color: #0000ff;">if</span> (netObj.propertyUseInCallBack ==<span style="color: #000000;"> YES) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">Do Something&hellip;</span>
<span style="color: #000000;">        }
    }];
}
</span><span style="color: #0000ff;">@end</span></pre>
<p>&nbsp;</p>
<p>还有一种改法，在block接口设计时，将可能需要的变量作为形参传到block中，从设计上解决循环引用的问题。</p>
<p>如果上面Network类设计成这个样子：</p>
<div class="code panel pdl" style="border-width: 1px;">
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">
<pre><span style="color: #0000ff;">@class</span><span style="color: #000000;"> NetowrkClass;
typedef </span><span style="color: #0000ff;">void</span>(^SuccBlock)(NetworkClass </em>aNetworkObj, <span style="color: #0000ff;">id</span><span style="color: #000000;"> data);
</span><span style="color: #0000ff;">@interface</span><span style="color: #000000;"> NetworkClass
</span><span style="color: #008000;">//</span><span style="color: #008000;">&hellip;</span>
<span style="color: #0000ff;">@end</span>
<span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> NetworkClass
</span><span style="color: #0000ff;">@end</span></p>

<p><span style="color: #0000ff;">@implementation</span><span style="color: #000000;"> UserCode
</span>- (<span style="color: #0000ff;">void</span><span style="color: #000000;">) temporaryNetworkCall
{
    NetworkClass </span><em>netObj =<span style="color: #000000;"> [[NetworkClass alloc] init];
    netObj.propertyUseInCallBack </span>=<span style="color: #000000;"> NO;
    [netObj requestWithSucBlock: </span>^(NetworkClass </em>aNetworkObj, <span style="color: #0000ff;">id</span><span style="color: #000000;"> data) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">这里参数中已经有netObj的对象了，使用者不用再从block外引用指针了。</span>
        <span style="color: #0000ff;">if</span> (aNetworkObj.propertyUseInCallBack ==<span style="color: #000000;"> YES) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;">Do Something&hellip;</span>
<span style="color: #000000;">        }
    }];
}
</span><span style="color: #0000ff;">@end</span></pre>
<p>&nbsp;</p>
</div>
</div>
<p>4、使用方将self或成员变量加入block之前要先将self变为<strong>weak</p>
<p>5、在多线程环境下（block中的weakSelf有可能被析构的情况下），需要先将self转为strong指针，避免在运行到某个关键步骤时self对象被析构。</p>
<p>第四、第五条合起来有个名词叫weak–strong dance，来自于<a class="external-link" style="text-decoration: none;" href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;ved=0CDkQFjAA&amp;url=%68%74%74%70%3a%2f%2f%64%65%76%65%6c%6f%70%65%72%2e%61%70%70%6c%65%2e%63%6f%6d%2f%76%69%64%65%6f%73%2f%77%77%64%63%2f%32%30%31%31%2f&amp;ei=mDl_UcKaEtDZkgXG14GoDg&amp;usg=AFQjCNENM0Mbw7vrvpPYNzjg2R9u6IUiEA&amp;sig2=wwwajZBQ62fO7EsU4RvSOg&amp;bvm=bv.45645796,d.dGI&amp;cad=rjt" rel="nofollow">2011 WWDC Session #322 (Objective-C Advancements in Depth）</a></p>
<p>以下代码来自AFNetworking，堪称使用weak–strong dance的经典。</p>
<div class="code panel pdl" style="border-width: 1px;">
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">
<pre></strong>weak <strong>typeof(self)weakSelf =<span style="color: #000000;"> self;
AFNetworkReachabilityStatusBlock callback </span>= ^<span style="color: #000000;">(AFNetworkReachabilityStatus status) {
    </strong>strong <strong>typeof(weakSelf)strongSelf </span>=<span style="color: #000000;"> weakSelf;
    strongSelf.networkReachabilityStatus </span>=<span style="color: #000000;"> status;
    </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (strongSelf.networkReachabilityStatusBlock) {
        strongSelf.networkReachabilityStatusBlock(status);
    }
};</span></pre>
</div>
<div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;">Review一下上面这段代码，里面玄机不少。</div>
</div>
<p>第一行：</strong>weak <strong>typeof(self)weakSelf = self;</p>
<p>如之前第四条所说，为防止callback内部对self强引用，weak一下。</p>
<p>其中用到了</strong>typeof(self)，这里涉及几个知识点：</p>
<p>a. <strong>typeof、</strong>typeof<strong>、typeof的区别</p>
<p>恩~~他们没有区别，但是这牵扯一段往事，在早期C语言中没有typeof这个关键字，</strong>typeof、<strong>typeof</strong>是在C语言的扩展关键字的时候出现的。</p>
<p>typeof是现代GNU C++的关键字，从Objective-C的根源说，他其实来自于C语言，所以AFNetworking使用了继承自C的关键字。</p>
<p>b.对于老的LLVM编译器上面这句话会编译报错，所以在很早的ARC使用者中流行<strong>typeof(&amp;*self)这种写法，<a class="external-link" href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references/" rel="nofollow">原因如下</a></p>
<p>大致说法是老LLVM编译器会将</strong>typeof转义为 XXX类名 <em>const <strong>strong的</strong>strong和前面的__weak关键字对指针的修饰又冲突了，所以加上&amp;</em>对指针的修饰。</p>
<p>第三行：<strong>strong </strong>typeof(weakSelf)strongSelf = weakSelf;</p>
<p>按照之前第五条的说法给转回strong了，这里__typeof()里面写的是weakSelf，里面写self也没有问题，因为typeof是编译时确定变量类型，所以这里写self 不会被循环引用。</p>
<p>第四、五、六行，如果不转成strongSelf而使用weakSelf，后面几句话中，有可能在第四句执行之后self的对象可能被析构掉，然后后面的StausBlock没有执行，导致逻辑错误。</p>
<p>最后第五行，使用前对block判空。</p>
<p>&nbsp;</p>
<p>写在最后，阅读好的开源库源码是提高个人水平的一个很好途径，看见不懂的地方去查去摸索会得到更多。</p>
<p>&nbsp;</p>
<p>参考：</p>
<p><a class="external-link" href="http://blog.csdn.net/fhbystudy/article/details/17350951" rel="nofollow"><a href="http://blog.csdn.net/fhbystudy/article/details/17350951">http://blog.csdn.net/fhbystudy/article/details/17350951</a></a></p>
<p><a class="external-link" href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references" rel="nofollow"><a href="http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references">http://stackoverflow.com/questions/10892361/generic-typeof-for-weak-self-references</a></a></p>
<p><a class="external-link" href="http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c" rel="nofollow"><a href="http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c">http://stackoverflow.com/questions/14877415/difference-between-typeof-typeof-and-typeof-objective-c</a></a></p>
<p><a class="external-link" href="http://rocry.com/2012/12/18/objective-c-type-of/" rel="nofollow"><a href="http://rocry.com/2012/12/18/objective-c-type-of/">http://rocry.com/2012/12/18/objective-c-type-of/</a></a></p>
<p><a class="external-link" href="http://fuckingblocksyntax.com/" rel="nofollow"><a href="http://fuckingblocksyntax.com/">http://fuckingblocksyntax.com/</a></a> 这是个工具网站，我每次写block的时候都会用到。</p>
        <h4 class="title2">
            <a id="cb_post_title_url" class="postTitle3" href="http://www.cnblogs.com/biosli/p/block_usage.html">原文链接(<a href="http://www.cnblogs.com/biosli/p/block_usage.html">http://www.cnblogs.com/biosli/p/block_usage.html</a>)</a>
        </h4>
</div>
<div id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd">&nbsp;</div></div><div id="MySignature"></div>
<div class="clear"></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C错误模型]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/04/objective-ccuo-wu-mo-xing/"/>
    <updated>2016-01-04T11:04:51+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/04/objective-ccuo-wu-mo-xing</id>
    <content type="html"><![CDATA[<h2>为什么不使用异常处理机制？</h2>

<p>事实上，OC是具备异常处理机制的，但是具体情况下不会启用该机制。原因是ARC下默认不是“异常安全”的。
    理由是,如果抛出异常，那么本应该在作用域末尾释放的对象在现在不能自动释放了。 如果想生成“异常安全”的代码，需要设置编译标志“-fobjc-arc-exceptions”，并且需要引入额外的代码，在不抛出异常时，也照样执行这段代码。
及时不适用ARC，也很难在抛出异常后不会导致内存泄露。例如：
<code>objc
    id resource = [YCResource alloc] init] retain];
    if (/*有异常发生*/) {
    @throw [NSException exceptionWithName:@"/*异常名称*/" reason@"/*异常原因*/" userInfo:nil];
    }
    [resource callSomeMethod];
    [resource release];
</code></p>

<!--more-->


<p>以上代码：如果一旦有异常抛出，那么之后的代码都不会被执行，资源resource对象也就无法被释放。
虽然可以在异常发生前释放资源对象，但是如果需要释放的资源对象非常多，之后又有新的资源加入，往往会忘了在异常前释放新加入的资源。
OC现在所采取的方法是只有在极其罕见的异常下，才抛出异常，异常抛出后不必考虑恢复问题，此时程序应该直接退出，这样就不用在编写复杂的“异常安全”代码了。
现在异常只用于及其严重的错误（致命错误）。
其中一个用途：OC中没有抽象类，所以无法定义抽象方法，此时，如果你想定义一套抽象 的API，那么可以在方法的实现中抛出异常，告诉使用者需要覆写该方法：
<code>objc
- (void)absructMethd {
    NSString exceptionReason = [NSString stringWithFormat:@"%@ must be overridden", NSStringFromSelector(_cmd)];
    @throw [NSException exceptionWithName:NSInternalInnconsistencyException reson:exceptionReason userInfo:nil];
}
</code></p>

<h2>如何处理“不那么严重（非致命）”的错误？</h2>

<p>OC的范式是：另方法返回0/nil，或者使用NSError。</p>

<h2>如何使用<code>NSError</code>？</h2>

<p>NSErrow使用起来非常灵活，我们使用它告诉调用者发生了什么错误。
NSError构成：
* Error domain(错误范围)
描述错误发生的范围。例如处理URL的子系统，当url解析出现错误，就可以使用<code>NSURLErrorDomain</code>来表示错误范围。
* Error code（错误码）
独有的错误代码，用以表明具体发生了何种错误，一般用枚举定义，HTTP请求中可以存储状态码。
* User info（用户信息）
有关错误的额外附加信息，可以是一段本地化描述，也可能是用来存储该错误是由其他错误引起的，最终生成一条完整的错误链。</p>

<p>其应用场景类型：
* 在代理协议中返回NSError错误。
<code>objc
- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError - *)error;
</code>
这样，接口定义者和使用者都可以选择是否输入并处理该错误。
* 在方法中用对象指针来监测错误。
<code>objc
- (BOOL)doSomething:(NSError **)error;
/*使用方法*/
NSError *error = nil;
BOOL ret = [slef doSomething:&amp;error];
if (ret) {
        // 处理错误
}
</code>
这种方法一般都会返回BOOL值，用来判断是否操作成功，如果只是判断成功状态，则只要判断返回值并且error参数传为nil就行，而error指针可以用来输出错误信息。
<code>
笔记：实际上ARC时，编译器会把NSError**转换为NSError*__autorelease*</code>,当doSomething方法执行完毕后，会将调用者创建的对象自动释放掉。这是为了防止调用者不一定能确保会释放掉NSError对象，必须要求他自己可以自动释放掉，所以加入autorelease。这样就与打部分返回值具备的语义相同了。</p>

<p>doSomething方法的实现原理：
<code>objc
- (BOOL)doSomething:(NSError *)error {
        if(/*发生error*/) {
                if(error) {
                /*给外部传入参数初始化*/
                *error = [NSError errorWithDomain:domain code:code userinfo:userInfo];
                }
                return NO;
        } else {
                return YES;
        }
}
</code>
在给error解引用&ndash;<code>*error</code>之前，必须保证error不为空。</p>

<p>一般情况下，给error对象填入恰当的错误范围，错误码，错误信息后，调用者就可以更精准的定位错误。
我们一般对错误范围使用NSString全局变量进行定义。错误码常采用枚举，例如：
<code>objc
extern NSSring *const YCErrorDomain;
typedef NS_ENUM（NSInteger, YCError）{
    YCErrorUnknow   = -1,
    YCErrorInternalIncosistency  = 100,
    YCErrorGeneralFault  = 105,
    YCErrorBadInput  = 500,
};
NSString *const YCErrorDomain = @"YCErrorDomain";
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为Harpy（版本更新工具)制做兼容版本]]></title>
    <link href="http://yangchao0033.github.io/blog/2016/01/01/wei-harpy(ban-ben-geng-xin-gong-ju-zhi-zuo-jian-rong-ban-ben-)/"/>
    <updated>2016-01-01T03:58:09+08:00</updated>
    <id>http://yangchao0033.github.io/blog/2016/01/01/wei-harpy(ban-ben-geng-xin-gong-ju-zhi-zuo-jian-rong-ban-ben-)</id>
    <content type="html"><![CDATA[<p><strong>中文版：</strong></p>

<h1>Harpy（兼容版）</h1>

<h3>(iOS5-9适配版本,基于<a href="https://github.com/ArtSabintsev/Harpy">ArtSabintsev/Harpy v3.4.5</a>)</h3>

<h3>提醒用户你的应用有新的可用版本，并且及时的跳转到App Store进行更新。</h3>

<h2>关于</h2>

<p><strong>Harpy</strong> 将用户手机上已安装的iOS app版本与当前App Store最新可用版本进行检查对比。如果有新的可用版本时，使用弹窗及时提醒用户最新版本信息，并然用户选择是否需要进一步操作。</p>

<!--more-->


<p>Harry是基于<a href="Semantic%20Versioning">http://www.semver.org</a>版本号系统标准执行。
- <code>Semantic Versioning</code>是一个三位数的版本号系统（例如:1.0.0）
- Harry同样支持2位数的版本号(例如:1.0)
- Harpy同时支持4位数的版本号（例如:1.0.0.0）</p>

<h2>Swift 支持</h2>

<p>当前兼容版本（iOS5-9）暂时不支持swift</p>

<h2>特点</h2>

<!--- [x] CocoaPods Support-->


<ul>
<li>[x] 支持三种类型的弹框样式 (详见 <strong>截图 &amp; Alert Types</strong>)</li>
<li>[x] 提供可选的代理方法 (详见 <strong>Optional Delegate</strong> section)</li>
<li>[x] 本地化支持超过20+语言</li>
</ul>


<h2>屏幕截图</h2>

<ul>
<li><strong>左图：</strong>强制用户更新app</li>
<li><strong>中图：</strong>提供可选项是否前往更新</li>
<li><strong>右图：</strong>提供跳过当前版本更新的选项</li>
<li>这些样式全部可以通过<code>HarpyAletType</code>枚举进行控制，详见<code>Harpy.h</code></li>
</ul>


<p><img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/4.pic.jpg?raw=true" title="Forced Update" alt="Forced Update" />
<img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/5.pic.jpg?raw=true" title="Optional Update" alt="Optional Update" />
<img src="https://github.com/yangchao0033/Harpy/blob/master/samplePictures/3.pic.jpg?raw=true" title="Optional Update" alt="Skipped Update" /></p>

<h2>安装</h2>

<h3>手动安装（正在准备CocoaPods）</h3>

<p>将‘Harpy’文件夹拖入到你的项目中，并选择'copy if needed',包括 <code>Harpy.h</code> 和 <code>Harpy.m</code> 文件</p>

<h2>配置</h2>

<ol>
<li>import <strong>Harpy.h</strong> 导入到 AppDelefate 类中 或者 Pre-Complier Header(.pch)文件中</li>
<li>在你的<code>Appdelegate</code>中设置<strong>appID</strong>（必要），设置你的<strong>alertType</strong>（可选）</li>
<li>在你的<code>Appdelegate</code>中调用<code>checkVersion</code>方法，三个检测方法调用位置分别位于Appdelegate的启动的代理方法中，可以自行选择使用

<ul>
<li>在 <code>application:didFinishLaunchingWithOptions:</code> 中调用 <code>checkVersion</code></li>
<li>在 <code>applicationDidBecomeActive:</code> 中调用 <code>checkVersionDaily</code></li>
<li>在 <code>applicationDidBecomeActive:</code> 中调用 <code>checkVersionWeekly</code> .</li>
</ul>
</li>
</ol>


<pre><code class="obj-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{

    // 启用Harpy之前确保你的window可用
    [self.window makeKeyAndVisible];

    // 为你的应用设置app id
    [[Harpy sharedInstance] setAppID:@"&lt;#app_id#&gt;"];

    // 设置 UIAlertController 将要基于哪个控制器显示 （适配iOS8+）
    [[Harpy sharedInstance] setPresentingViewController:_window.rootViewController];

  // (可选)设置代理来追踪用户点击事件，活着的使用自定义的界面来展示你的信息
      [[Harpy sharedInstance] setDelegate:self];

    // (可选) 设置alertController的tincolor（iOS8+可用）
    [[Harpy sharedInstance] setAlertControllerTintColor:@"&lt;#alert_controller_tint_color#&gt;"];

    // (可选) 设置你的应用名
    [[Harpy sharedInstance] setAppName:@"&lt;#app_name#&gt;"];

     /* （可选）设置弹框类型 默认为HarpyAlertTypeOption */
    [[Harpy sharedInstance] setAlertType:&lt;#alert_type#&gt;];

     /* (可选)如果你的应用只在某些国家或地区可用，你必须使用两个字符的country code来设置应用的可用区域 */
    [[Harpy sharedInstance] setCountryCode:@"&lt;#country_code#&gt;"];

    /* (可选) 强制指定应用显示语言, 请使用 Harpy.h 中定义的 HarpyLanguage 进行设置。*/
    [[Harpy sharedInstance] setForceLanguageLocalization:&lt;#HarpyLanguageConstant#&gt;];

    // 执行版本检测
    [[Harpy sharedInstance] checkVersion];
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{

    /*
        执行每天检测你的app是否需要更新版本，需要在`applicationDidBecomeActive:`执行最合适
        因为这对于的你的应用进如后台很长时间后非常有用。

        同时，也会在应用第一次启动时执行版本检测
    */
    [[Harpy sharedInstance] checkVersionDaily];

    /*
        执行每周检测你的app新版本。同理需要将此代码放置在`applicationDidBecomeActive:`中执行。

        同时，也会在应用第一次启动时执行版本检测
     */
    [[Harpy sharedInstance] checkVersionWeekly];

}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    /*
     执行app新版本检测，放在此是为了让用户从App Sore跳转回来并重新从后台进入你的
     app，并且没有在从App Store中跳转回来之前更新他们app的时候调用

     注意：只有当你使用*HarpyAlertTypeForce*样式弹框类型是才使用这种方法

    并且会在你第一次启动应用时检测。
    */
    [[Harpy sharedInstance] checkVersion];
}
</code></pre>

<p>至此设置全部完成！</p>

<h2>为不同的升级类型设置弹窗样式</h2>

<p>如果你喜欢为不同的升级类型比如修改(revision)，补丁(patch)，轻微改动(minor)，重大修改(major)等升级类型仅仅添加下面的几行可选代码即可，添加位置必须在调用版本检查的方法（checkVersion）之前</p>

<pre><code class="obj-c">    /* 默认情况下Harpy会设置所有的版本升级样式为HarpyAlertTypeOption */
    [[Harpy sharedInstance] setPatchUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMinorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMajorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setRevisionUpdateAlertType:&lt;#alert_type#&gt;];
</code></pre>

<h2>可选的代理和代理方法</h2>

<p>如果你想要个处理或者追踪终端用户的的行为，Harpy会为你提供四个代理方法进行监控</p>

<pre><code class="obj-c">    // 用户界面展示升级提示对话框
    - (void)harpyDidShowUpdateDialog;

    // 用户已经点击升级按钮并且进入到App Sotore
    - (void)harpyUserDidLaunchAppStore;

    // 用户已经点击跳过此次版本更新
    - (void)harpyUserDidSkipVersion;

    // 用户已经点击取消更行对话框
    - (void)harpyUserDidCancel;
</code></pre>

<p>If you would like to use your own UI, please use the following delegate method to obtain the localized update message if a new version is available:
如果你想使用自己的UI，如果有可用的新版本，使用下面的代理来获得本地化的升级信息（需要设置AlertTpye为HarpyAlertTypeNone）</p>

<pre><code class="obj-c">- (void)harpyDidDetectNewVersionWithoutAlert:(NSString *)message;
</code></pre>

<h2>强制本地化</h2>

<p>Harpy 已经本地化了的语言包括 Arabic, Basque, 简体中文, 繁体中文, Danish, Dutch, English, Estonian, French, German, Hebrew, Hungarian, Italian, Japanese, Korean, Latvian, Lithuanian, Malay, Polish, Portuguese (Brazil), Portuguese (Portugal), Russian, Slovenian, Swedish, Spanish, Thai, and Turkish.</p>

<p>你可能想要你的升级对话框<em>永远</em>显示正确的语言，而忽略iOS的语言设置（比如在指定国家发行的app）</p>

<p>你可以使用以下代码实现强制本地化</p>

<pre><code class="obj-c">[[Harpy sharedInstance] setForceLanguageLocalization&lt;#HarpyLanguageConstant#&gt;];
</code></pre>

<h2>在App Store上提交的重要注意事项</h2>

<p>App Store 审核人员将不会看到升级弹框</p>

<p><strong>English</strong>：</p>

<h1>Harpy（Compatible version Base On <a href="https://github.com/ArtSabintsev/Harpy">ArtSabintsev/Harpy v3.4.5</a>）</h1>

<h3>Notify users when a new version of your app is available, and prompt them with the App Store link.</h3>

<hr />

<h2>About</h2>

<p><strong>Harpy</strong> checks a user&rsquo;s currently installed version of your iOS app against the version that is currently available in the App Store. If a new version is available, an alert can be presented to the user informing them of the newer version, and giving them the option to update the application.</p>

<p>Harpy is built to work with the <a href="Semantic%20Versioning">http://www.semver.org</a> system.
- Semantic Versioning is a three number versioning system (e.g., 1.0.0)
- Harpy also supports two-number versioning (e.g., 1.0)
- Harpy also supports four-number versioning (e.g., 1.0.0.0)</p>

<h2>Swift Support</h2>

<ul>
<li>not support yet</li>
</ul>


<h2>Features</h2>

<!--- [x] CocoaPods Support-->


<ul>
<li>[x] Three types of alerts (see <strong>Screenshots &amp; Alert Types</strong>)</li>
<li>[x] Optional delegate methods (see <strong>Optional Delegate</strong> section)</li>
<li>[x] Localized for 20+ languages</li>
</ul>


<h2>Screenshots</h2>

<ul>
<li>The <strong>left picture</strong> forces the user to update the app.</li>
<li>The <strong>center picture</strong> gives the user the option to update the app.</li>
<li>The <strong>right picture</strong> gives the user the option to skip the current update.</li>
<li>These options are controlled by the <code>HarpyAlertType</code> typede that is found in <code>Harpy.h</code>.</li>
</ul>


<p><img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picForcedUpdate.png?raw=true" title="Forced Update" alt="Forced Update" />
<img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picOptionalUpdate.png?raw=true" title="Optional Update" alt="Optional Update" />
<img src="https://github.com/ArtSabintsev/Harpy/blob/master/samplePictures/picSkippedUpdate.png?raw=true" title="Optional Update" alt="Skipped Update" /></p>

<h2>Installation Instructions</h2>

<!--### CocoaPods Installation
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">pod</span> <span class="err">&#39;</span><span class="n">Harpy</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>-->


<h3>Manual Installation</h3>

<p>Copy the &lsquo;Harpy&rsquo; folder into your Xcode project. It contains the Harpy.h and Harpy.m files.</p>

<h2>Setup</h2>

<ol>
<li>Import <strong>Harpy.h</strong> into your AppDelegate or Pre-Compiler Header (.pch)</li>
<li>In your <code>AppDelegate</code>, set the <strong>appID</strong>, and optionally, you can set the <strong>alertType</strong>.</li>
<li>In your <code>AppDelegate</code>, call <strong>only one</strong> of the <code>checkVersion</code> methods, as all three perform a check on your application&rsquo;s first launch. Use either:

<ul>
<li><code>checkVersion</code> in <code>application:didFinishLaunchingWithOptions:</code></li>
<li><code>checkVersionDaily</code> in <code>applicationDidBecomeActive:</code>.</li>
<li><code>checkVersionWeekly</code> in <code>applicationDidBecomeActive:</code>.</li>
</ul>
</li>
</ol>


<pre><code class="obj-c">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{

    // Present Window before calling Harpy
    [self.window makeKeyAndVisible];

    // Set the App ID for your app
    [[Harpy sharedInstance] setAppID:@"&lt;#app_id#&gt;"];

    // Set the UIViewController that will present an instance of UIAlertController
    [[Harpy sharedInstance] setPresentingViewController:_window.rootViewController];

  // (Optional) Set the Delegate to track what a user clicked on, or to use a custom UI to present your message.
      [[Harpy sharedInstance] setDelegate:self];

    // (Optional) The tintColor for the alertController
    [[Harpy sharedInstance] setAlertControllerTintColor:@"&lt;#alert_controller_tint_color#&gt;"];

    // (Optional) Set the App Name for your app
    [[Harpy sharedInstance] setAppName:@"&lt;#app_name#&gt;"];

    /* (Optional) Set the Alert Type for your app
     By default, Harpy is configured to use HarpyAlertTypeOption */
    [[Harpy sharedInstance] setAlertType:&lt;#alert_type#&gt;];

    /* (Optional) If your application is not available in the U.S. App Store, you must specify the two-letter
     country code for the region in which your applicaiton is available. */
    [[Harpy sharedInstance] setCountryCode:@"&lt;#country_code#&gt;"];

    /* (Optional) Overrides system language to predefined language.
     Please use the HarpyLanguage constants defined in Harpy.h. */
    [[Harpy sharedInstance] setForceLanguageLocalization:&lt;#HarpyLanguageConstant#&gt;];

    // Perform check for new version of your app
    [[Harpy sharedInstance] checkVersion];
}

- (void)applicationDidBecomeActive:(UIApplication *)application
{

    /*
     Perform daily check for new version of your app
     Useful if user returns to you app from background after extended period of time
     Place in applicationDidBecomeActive:

     Also, performs version check on first launch.
    */
    [[Harpy sharedInstance] checkVersionDaily];

    /*
     Perform weekly check for new version of your app
     Useful if you user returns to your app from background after extended period of time
     Place in applicationDidBecomeActive:

     Also, performs version check on first launch.
     */
    [[Harpy sharedInstance] checkVersionWeekly];

}

- (void)applicationWillEnterForeground:(UIApplication *)application
{
    /*
     Perform check for new version of your app
     Useful if user returns to you app from background after being sent tot he App Store,
     but doesn't update their app before coming back to your app.

     ONLY USE THIS IF YOU ARE USING *HarpyAlertTypeForce*

     Also, performs version check on first launch.
    */
    [[Harpy sharedInstance] checkVersion];
}
</code></pre>

<p>And you&rsquo;re all set!</p>

<h2>Differentiated Alerts for Patch, Minor, and Major Updates</h2>

<p>If you would like to set a different type of alert for revision, patch, minor, and/or major updates, simply add one or all of the following <em>optional</em> lines to your setup <em>before</em> calling any of the <code>checkVersion</code> methods:</p>

<pre><code class="obj-c">    /* By default, Harpy is configured to use HarpyAlertTypeOption for all version updates */
    [[Harpy sharedInstance] setPatchUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMinorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setMajorUpdateAlertType:&lt;#alert_type#&gt;];
    [[Harpy sharedInstance] setRevisionUpdateAlertType:&lt;#alert_type#&gt;];
</code></pre>

<h2>Optional Delegate and Delegate Methods</h2>

<p>If you&rsquo;d like to handle or track the end-user&rsquo;s behavior, four delegate methods have been made available to you:</p>

<pre><code class="obj-c">    // User presented with update dialog
    - (void)harpyDidShowUpdateDialog;

    // User did click on button that launched App Store.app
    - (void)harpyUserDidLaunchAppStore;

    // User did click on button that skips version update
    - (void)harpyUserDidSkipVersion;

    // User did click on button that cancels update dialog
    - (void)harpyUserDidCancel;
</code></pre>

<p>If you would like to use your own UI, please use the following delegate method to obtain the localized update message if a new version is available:</p>

<pre><code class="obj-c">- (void)harpyDidDetectNewVersionWithoutAlert:(NSString *)message;
</code></pre>

<h2>Force Localization</h2>

<p>Harpy has localizations for Arabic, Basque, Chinese (Simplified), Chinese (Traditional), Danish, Dutch, English, Estonian, French, German, Hebrew, Hungarian, Italian, Japanese, Korean, Latvian, Lithuanian, Malay, Polish, Portuguese (Brazil), Portuguese (Portugal), Russian, Slovenian, Swedish, Spanish, Thai, and Turkish.</p>

<p>You may want the update dialog to <em>always</em> appear in a certain language, ignoring iOS&rsquo;s language setting (e.g. apps released in a specific country).</p>

<p>You can enable it like this:</p>

<pre><code class="obj-c">[[Harpy sharedInstance] setForceLanguageLocalization&lt;#HarpyLanguageConstant#&gt;];
</code></pre>

<h2>Important Note on App Store Submissions</h2>

<p>The App Store reviewer will <strong>not</strong> see the alert.</p>

<h2>Created and maintained by</h2>

<p><a href="http://www.sabintsev.com/">Arthur Ariel Sabintsev</a></p>
]]></content>
  </entry>
  
</feed>
